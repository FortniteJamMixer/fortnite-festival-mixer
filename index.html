<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <meta name="theme-color" content="#0f1020" />
  <title>Fortnite Jam Mixer â€“ Cross-Browser Edition</title>
  <meta name="description" content="Fortnite Jam Mixer helps you build harmonious Fortnite Festival mashups with Camelot, BPM, and setlist tools." />
  <link rel="manifest" href="/manifest.webmanifest" />
  <script>document.documentElement.classList.add('tw-offline');</script>
  <link rel="stylesheet" href="/offline.css" />
  <script src="https://cdn.tailwindcss.com" onload="document.documentElement.classList.remove('tw-offline');" onerror="console.warn('Tailwind CDN unavailable; using offline fallback.');"></script>

  <!-- Firebase config injected from Vercel (serverless /api/firebase-config) -->
  <script src="/api/firebase-config"></script>

  <!-- Optional Firebase SDKs (compat). Enable only if you use Firebase. -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="/constants/appMeta.js"></script>
  <script src="/services/configService.js"></script>
  <script type="module" src="/services/profileStore.js"></script>
  <script type="module" src="/services/ownedLibraryStore.js"></script>

  <style>
    /* ---------------- Theme & Layout ---------------- */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html,body { height: 100%; }
    body {
      background: linear-gradient(135deg, #0f1020 0%, #14122a 40%, #071130 100%);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #e9f7ff;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      padding-bottom: env(safe-area-inset-bottom);
    }
    :root {
      --safe-top: env(safe-area-inset-top);
      --safe-bottom: env(safe-area-inset-bottom);
      --sticky-cta-height: 64px;
    }
    button,
    input:not([type="checkbox"]):not([type="radio"]):not([type="range"]),
    select,
    textarea {
      min-height: 44px;
    }
    .content-wrapper { max-width: 1200px; margin: 18px auto; padding: 12px; }
    .panel { background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.45)); border-radius: 12px; border: 1px solid rgba(255,255,255,0.03); padding: 12px; }
    .vinyl-spin { animation: spin 4s linear infinite; }
    .bounce-icon { animation: bounce 2s ease-in-out infinite; }
    @keyframes spin { from { transform: rotate(0) } to { transform: rotate(360deg) } }
    @keyframes bounce { 0%,100% { transform: translateY(0) } 50% { transform: translateY(-8px) } }
    .graffiti-text { text-shadow: 3px 3px 0 #ff6b9d, 6px 6px 0 rgba(255,107,157,0.22); letter-spacing: 1px; }
    .camelot-pill { padding: 6px 10px; border-radius: 10px; font-weight: 700; color: #fff; }
    .score-badge { font-weight: 800; letter-spacing: .6px; padding: 6px 10px; border-radius: 8px; display:inline-block; }
    .small-muted { color: rgba(230,247,255,0.7); font-size: 13px; }
    .sandbox-drop { min-height: 110px; border-radius: 12px; padding: 10px; border: 2px dashed rgba(255,255,255,0.04); }
    .context-menu { position: fixed; background: rgba(0,0,0,0.95); border-radius: 8px; padding: 8px; z-index:10000; backdrop-filter: blur(8px); border: 1px solid rgba(0,217,255,0.12); color: #e6f7ff; }
    .glow-perfect { box-shadow: 0 0 18px rgba(57,255,20,0.85), 0 0 48px rgba(57,255,20,0.12); }
    .glow-good { box-shadow: 0 0 12px rgba(255,230,65,0.9), 0 0 36px rgba(255,230,65,0.08); }
    .glow-bad { box-shadow: 0 0 12px rgba(255,63,63,0.9), 0 0 36px rgba(255,63,63,0.08); }
    .selected-panel { border: 2px solid rgba(0,217,255,0.6); box-shadow: 0 0 18px rgba(0,217,255,0.18), 0 0 32px rgba(255,107,157,0.18); background: linear-gradient(90deg, rgba(0,217,255,0.1), rgba(255,107,157,0.12)); }
    .selected-badge { background: linear-gradient(90deg,#06b6d4,#ec4899); color:#fff; font-weight:800; padding:6px 10px; border-radius:999px; font-size:11px; letter-spacing:0.5px; box-shadow: 0 0 12px rgba(6,182,212,0.4); }
    .selected-card { border: 2px solid rgba(0,217,255,0.8); box-shadow: 0 0 26px rgba(0,217,255,0.45), 0 0 12px rgba(236,72,153,0.25); }
    #adminToolsBtn { pointer-events: auto; cursor: pointer; }
    .admin-tools-menu { z-index: 6000; pointer-events: auto; position: absolute; }
    .song-grid { grid-template-columns: 1fr; contain: layout paint; }
    .song-card { content-visibility: auto; contain-intrinsic-size: 320px 220px; }
    .reduced-effects .vinyl-spin,
    .reduced-effects .bounce-icon { animation: none !important; }
    .reduced-effects .glow-perfect,
    .reduced-effects .glow-good,
    .reduced-effects .glow-bad,
    .reduced-effects .selected-card { box-shadow: none !important; }
    .reduced-effects .song-card { transition: none; }
    .header-actions { gap: 12px; }
    .header-secondary { margin-top: 8px; }
    .header-secondary[hidden] { display: none; }
    .safe-header { padding-top: var(--safe-top); }
    .mobile-hidden { display: none; }
    .mobile-only { display: none; }
    .sticky-cta-bar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 90;
      padding: 10px 16px calc(10px + var(--safe-bottom));
      background: rgba(10, 10, 24, 0.92);
      border-top: 1px solid rgba(0,217,255,0.2);
      backdrop-filter: blur(14px);
      box-shadow: 0 -6px 24px rgba(0,0,0,0.4);
      transform: translateY(0);
      transition: transform 0.2s ease;
    }
    .sticky-cta-bar.hidden { transform: translateY(110%); }
    .sticky-cta-button {
      width: 100%;
      min-height: 48px;
      border-radius: 14px;
      background: linear-gradient(90deg,#ff6b9d,#8b5cf6);
      color: #fff;
      font-weight: 800;
      letter-spacing: 0.3px;
      border: none;
    }
    .sticky-cta-copy { font-size: 12px; color: rgba(230,247,255,0.75); margin-top: 4px; text-align: center; }
    .sticky-cta-spotlight { opacity: 0.7; transition: opacity 0.2s ease; }
    .sticky-cta-active .sticky-cta-spotlight { opacity: 1; }
    .sticky-cta-active .dim-when-sticky { opacity: 0.7; }
    .song-list-highlight .song-card { border-color: rgba(0,217,255,0.45); }
    .skeleton-card {
      border-radius: 14px;
      padding: 16px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      animation: pulse 1.5s ease-in-out infinite;
    }
    .skeleton-line { height: 12px; border-radius: 999px; background: rgba(255,255,255,0.12); margin-bottom: 8px; }
    .skeleton-line.short { width: 50%; }
    .skeleton-line.medium { width: 70%; }
    .skeleton-line.long { width: 90%; }
    .inline-banner {
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(59,130,246,0.12);
      border: 1px solid rgba(59,130,246,0.4);
      color: #dff7ff;
      font-size: 12px;
      font-weight: 600;
    }
    .quickstart-modal {
      position: fixed;
      inset: 0;
      z-index: 21000;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(2,6,23,0.8);
      backdrop-filter: blur(8px);
      padding: 16px;
    }
    .quickstart-card {
      width: min(520px, 94vw);
      background: linear-gradient(180deg, rgba(8,13,30,0.98), rgba(16,10,32,0.98));
      border-radius: 18px;
      border: 1px solid rgba(0,217,255,0.2);
      padding: 18px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.6);
    }
    .quickstart-actions { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 16px; }
    .quickstart-actions button { flex: 1 1 140px; }
    .quickstart-option {
      width: 100%;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: #fff;
      font-weight: 700;
      text-align: left;
    }
    .quickstart-option strong { display: block; font-size: 15px; }
    .quickstart-track {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.12);
      cursor: pointer;
    }
    .quickstart-track:hover { border-color: rgba(0,217,255,0.6); }

    @media (max-width: 640px) {
      .header-secondary { display: none; }
      .header-secondary.is-open { display: block; }
      .mobile-hidden { display: none !important; }
      .mobile-only { display: inline-flex; }
      .header-actions { gap: 10px; }
      .content-wrapper { padding: 8px; }
    }
    @media (min-width: 1024px) {
      .login-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); align-items: stretch; }
      .camelot-wheel-graphic {
        width: 260px;
        height: 260px;
        --label-radius-outer: 108px;
        --label-radius-inner: 72px;
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .sticky-cta-bar { transition: none; }
    }
    @media (min-width: 768px) {
      .song-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    #profileView { position: relative; z-index: 10; }
    .profile-hit-target { min-height: 44px; }

    /* Help modal */
    #helpModal {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 20000;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      backdrop-filter: blur(6px);
    }
    #helpModal[aria-hidden="true"] { display: none; pointer-events: none; }
    #helpModal[aria-hidden="false"] { pointer-events: auto; }
    .helpBox {
      width: 92%;
      max-width: 760px;
      height: 80vh;
      background: linear-gradient(180deg, rgba(12,10,25,0.96), rgba(20,16,38,0.98));
      border-radius: 14px;
      border: 2px solid rgba(0,217,255,0.14);
      box-shadow: 0 10px 40px rgba(0,0,0,0.6), 0 0 50px rgba(0,217,255,0.06);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .helpHeader {
      padding: 14px 18px;
      border-bottom: 1px solid rgba(0,217,255,0.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .helpTitle { font-size:20px; font-weight:800; color:#fff; display:flex; gap:10px; align-items:center; }
    .helpTabs { display:flex; gap:8px; align-items:center; }
    .helpTabBtn { padding:8px 10px; border-radius:10px; border:1px solid rgba(0,217,255,0.18); background:rgba(255,255,255,0.06); color:#dff7ff; font-weight:800; cursor:pointer; }
    .helpTabBtn.active { background: linear-gradient(90deg,#ff6b9d,#8b5cf6); border-color: rgba(255,255,255,0.14); box-shadow:0 0 18px rgba(139,92,246,0.18); color:#fff; }
    .helpContent {
      padding: 14px 18px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      color: #dff7ff;
      line-height:1.45;
      font-size:14px;
    }
    .helpSection { margin-bottom: 18px; }
    .helpSection h3 { font-size: 16px; margin-bottom: 6px; font-weight: 800; color: #fff; }
    .helpSection h4 { font-size: 14px; margin-bottom: 6px; font-weight: 800; color: #9fe8ff; }
    .helpSection p, .helpSection ul, .helpSection ol { margin-bottom: 8px; }
    .helpSection ul { margin-left: 16px; }
    .helpSection ol { margin-left: 18px; }
    .helpComing { color: rgba(159,232,255,0.7); font-size: 12px; font-style: italic; display: none; }
    .helpFaq { border: 1px solid rgba(0,217,255,0.18); background: rgba(255,255,255,0.03); border-radius: 10px; padding: 8px 12px; margin-bottom: 10px; }
    .helpFaq summary { cursor: pointer; font-weight: 700; color: #e6f7ff; list-style: none; }
    .helpFaq summary::-webkit-details-marker { display: none; }
    .helpFaq p { margin-top: 6px; color: rgba(230,247,255,0.8); font-size: 13px; }
    .helpDivider { margin: 14px 0; border-color: rgba(0,217,255,0.08); }
    .anchorGrid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 8px; margin-bottom: 12px; }
    .anchorLink { display: block; padding: 10px 12px; border-radius: 10px; background: rgba(0,217,255,0.06); border: 1px solid rgba(0,217,255,0.12); color: #e6f7ff; text-decoration: none; font-weight: 700; }
    .anchorLink:hover { border-color: rgba(255,107,157,0.35); box-shadow: 0 0 12px rgba(255,107,157,0.18); }
    .callout { padding: 12px; border-radius: 10px; border: 1px solid rgba(0,217,255,0.14); background: rgba(0,217,255,0.05); margin-bottom: 10px; }
    .calloutTitle { font-weight: 800; margin-bottom: 6px; display: flex; align-items: center; gap: 6px; color: #9fe8ff; text-transform: uppercase; letter-spacing: 0.3px; font-size: 12px; }
    .tag { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 999px; background: rgba(0,217,255,0.12); color: #bdeeff; font-weight: 700; font-size: 12px; }
    .camelot-wheel { width: 100%; max-width: 520px; margin: 10px auto; display: flex; justify-content: center; }
    .camelot-wheel svg { width: 100%; height: auto; }
    .camelot-caption { text-align: center; color: #e6f7ff; font-size: 13px; margin-top: 6px; }
    .login-grid { width: min(1100px, 100%); display: grid; gap: 24px; }
    .camelot-panel {
      background: linear-gradient(180deg, rgba(8,13,30,0.9), rgba(12,10,30,0.85));
      border-radius: 18px;
      border: 1px solid rgba(255,107,157,0.25);
      box-shadow: 0 12px 32px rgba(0,0,0,0.45), 0 0 24px rgba(255,107,157,0.15);
    }
    .camelot-wheel-graphic {
      position: relative;
      width: 220px;
      height: 220px;
      margin: 0 auto 20px;
      --label-radius-outer: 92px;
      --label-radius-inner: 62px;
    }
    .camelot-wheel-graphic.is-mini {
      width: 140px;
      height: 140px;
      --label-radius-outer: 60px;
      --label-radius-inner: 40px;
    }
    .camelot-wheel-graphic.is-mini .camelot-wheel-label--outer { font-size: 10px; }
    .camelot-wheel-graphic.is-mini .camelot-wheel-label--inner { font-size: 9px; }
    .camelot-wheel-graphic.is-mini .camelot-wheel-center { font-size: 8px; }
    .camelot-wheel-ring {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      box-shadow: 0 0 30px rgba(0,217,255,0.18), 0 0 12px rgba(255,107,157,0.2);
      border: 1px solid rgba(255,255,255,0.12);
    }
    .camelot-wheel-ring-a {
      inset: 18%;
      border: 1px solid rgba(255,255,255,0.2);
    }
    .camelot-wheel-center {
      position: absolute;
      inset: 36%;
      border-radius: 50%;
      background: rgba(5,8,20,0.9);
      border: 1px solid rgba(0,217,255,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 11px;
      font-weight: 800;
      letter-spacing: 0.08em;
      color: #dff7ff;
      text-transform: uppercase;
      box-shadow: 0 0 18px rgba(0,217,255,0.25);
      padding: 6px;
    }
    .camelot-wheel-label {
      position: absolute;
      left: 50%;
      top: 50%;
      transform-origin: center;
      color: #fff;
      text-shadow: 0 0 8px rgba(0,217,255,0.5), 0 0 14px rgba(0,0,0,0.6);
      white-space: nowrap;
      font-weight: 800;
      letter-spacing: 0.02em;
    }
    .camelot-wheel-label--outer {
      transform: rotate(calc(var(--i) * 30deg)) translateY(calc(var(--label-radius-outer) * -1)) rotate(calc(var(--i) * -30deg)) translateX(-50%);
      font-size: 13px;
      line-height: 1;
    }
    .camelot-wheel-label--inner {
      transform: rotate(calc(var(--i) * 30deg)) translateY(calc(var(--label-radius-inner) * -1)) rotate(calc(var(--i) * -30deg)) translateX(-50%);
      font-size: 11px;
      line-height: 1;
      color: #dff7ff;
    }
    @media (max-width: 640px) {
      .camelot-wheel-graphic { width: 200px; height: 200px; --label-radius-outer: 82px; --label-radius-inner: 56px; }
      .camelot-wheel-label--outer { font-size: 12px; }
      .camelot-wheel-label--inner { font-size: 10px; }
    }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; font-weight: 800; font-size: 12px; }
    .helpFooter { padding: 10px 14px; border-top: 1px solid rgba(0,217,255,0.04); text-align:right; }
    .helpFooter { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .helpFooterActions { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .helpAltBtn {
      background: rgba(255,255,255,0.08);
      padding: 8px 12px;
      border-radius: 10px;
      color: #dff7ff;
      font-weight:700;
      cursor:pointer;
      border: 1px solid rgba(0,217,255,0.2);
      transition: all .2s ease;
    }
    .helpAltBtn:hover { background: rgba(255,255,255,0.16); color: #fff; border-color: rgba(255,255,255,0.3); }

    /* Custom neon scrollbar for helpContent */
    .helpContent::-webkit-scrollbar { width: 12px; }
    .helpContent::-webkit-scrollbar-track { background: linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.06)); border-radius:8px; }
    .helpContent::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(0,217,255,0.9), rgba(255,107,157,0.9));
      border-radius: 8px;
      border: 2px solid rgba(0,0,0,0.2);
      box-shadow: 0 0 12px rgba(0,217,255,0.14);
    }
    .helpCloseBtn {
      background: linear-gradient(90deg,#ff6b9d,#8b5cf6);
      padding: 8px 12px;
      border-radius: 10px;
      color: #fff;
      font-weight:700;
      cursor:pointer;
      border: none;
      box-shadow: 0 6px 24px rgba(139,92,246,0.12);
    }
    .helpIconBtn {
      width: 40px;
      height: 40px;
      min-width: 40px;
      min-height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      color: #e5f6ff;
      font-weight: 800;
      font-size: 14px;
      cursor: pointer;
      transition: all .2s ease;
    }
    .helpIconBtn:hover { background: rgba(255,255,255,0.2); color: #fff; }
    .helpIconBtn:focus-visible { outline: 2px solid rgba(0,217,255,0.8); outline-offset: 2px; }

    /* Admin editor modal */
    .admin-editor-modal { position: fixed; inset: 0; z-index: 7000; display: flex; align-items: center; justify-content: center; background: rgba(3,7,18,0.75); backdrop-filter: blur(8px); }
    .admin-editor-card { width: min(1100px, 95vw); max-height: 90vh; overflow: hidden; background: rgba(3,7,18,0.95); border: 1px solid rgba(0,217,255,0.2); border-radius: 18px; display: flex; flex-direction: column; }
    .admin-editor-header { padding: 16px 20px; border-bottom: 1px solid rgba(0,217,255,0.15); display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .admin-editor-body { padding: 18px 20px; overflow: auto; display: grid; gap: 16px; }
    .admin-editor-columns { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
    .admin-editor-section { border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 12px; background: rgba(255,255,255,0.04); }
    .admin-editor-row { display: grid; gap: 8px; align-items: center; grid-template-columns: 1fr auto; }
    .admin-editor-row + .admin-editor-row { margin-top: 8px; }
    .admin-editor-input, .admin-editor-textarea { width: 100%; background: rgba(15,23,42,0.9); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 8px 10px; color: #fff; font-size: 13px; }
    .admin-editor-textarea { min-height: 70px; resize: vertical; }
    .admin-editor-actions { display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-end; }
    .admin-editor-btn { padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.08); color: #fff; font-size: 12px; font-weight: 600; }
    .admin-editor-btn:hover { background: rgba(255,255,255,0.18); }
    .admin-editor-preview { border: 1px solid rgba(0,217,255,0.18); border-radius: 12px; padding: 12px; background: rgba(0,0,0,0.4); max-height: 520px; overflow: auto; }
    .admin-editor-inline-actions { display: flex; gap: 6px; flex-wrap: wrap; }

    /* Tour overlay */
    #tourOverlay {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 25000;
      pointer-events: none;
    }
    #tourOverlay[aria-hidden="true"] { display: none; pointer-events: none; }
    #tourOverlay[aria-hidden="false"] { pointer-events: auto; }
    #tourOverlay[data-open="true"] { display: block; pointer-events: auto; }
    .tour-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(5,8,20,0.75);
      backdrop-filter: blur(3px);
    }
    .tour-highlight {
      position: fixed;
      border-radius: 14px;
      border: 2px solid rgba(0,217,255,0.75);
      box-shadow: 0 0 0 2px rgba(0,217,255,0.15), 0 0 25px rgba(0,217,255,0.45);
      transition: all .2s ease;
      pointer-events: none;
    }
    .tour-tooltip {
      position: fixed;
      max-width: 320px;
      width: calc(100% - 32px);
      background: linear-gradient(180deg, rgba(12,10,25,0.98), rgba(20,16,38,0.98));
      border-radius: 14px;
      border: 1px solid rgba(0,217,255,0.22);
      box-shadow: 0 12px 35px rgba(0,0,0,0.55), 0 0 28px rgba(0,217,255,0.18);
      color: #e6f7ff;
      padding: 14px 16px;
      pointer-events: auto;
    }
    .tour-title { font-size: 16px; font-weight: 800; margin-bottom: 6px; }
    .tour-copy { font-size: 14px; color: rgba(230,247,255,0.85); margin-bottom: 10px; }
    .tour-hint { font-size: 12px; color: rgba(159,232,255,0.8); margin-bottom: 10px; }
    .tour-actions { display: flex; flex-wrap: wrap; gap: 8px; justify-content: space-between; }
    .tour-actions .tour-left { display:flex; gap:8px; flex-wrap:wrap; }
    .tour-actions .tour-right { display:flex; gap:8px; flex-wrap:wrap; margin-left:auto; }
    .tour-btn {
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 700;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      color: #e6f7ff;
      cursor: pointer;
    }
    .tour-btn:hover { background: rgba(255,255,255,0.18); }
    .tour-btn-primary { background: linear-gradient(90deg,#ff6b9d,#8b5cf6); border: none; color: #fff; }
    .tour-btn-primary:hover { filter: brightness(1.05); }
    .tour-btn-secondary { border-color: rgba(0,217,255,0.4); color: #bdf1ff; }
    .tour-btn[disabled] { opacity: 0.5; cursor: not-allowed; }

    /* responsive tweaks */
    @media (max-width: 980px) {
      .two-col { flex-direction: column; }
      .rightCol { width: 100% !important; min-width: auto; }
    }
  </style>
</head>
<body>
  <div class="content-wrapper">
    <div id="app">
      <div class="min-h-screen flex items-center justify-center">
        <div class="text-center">
          <div class="text-6xl mb-4 animate-pulse">ðŸŽµ</div>
          <div class="text-2xl font-bold text-white" data-brand="loading">Loading Fortnite Jam Mixer...</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Modal (outside #app so it persists) -->
  <div id="helpModal" aria-hidden="true">
      <div class="helpBox" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
      <div class="helpHeader">
        <div class="helpTitle" id="helpTitle">
          <div style="width:50px;height:50px;border-radius:10px;display:flex;align-items:center;justify-content:center;background:linear-gradient(90deg,#ff6b9d,#8b5cf6);box-shadow:0 8px 24px rgba(139,92,246,0.12);font-size:22px;">ðŸŽ§</div>
          <div>
            <div style="font-size:18px;font-weight:800">HELP & FEATURES</div>
            <div style="font-size:12px;color:#bdeeff">Everything the landing page explains â€” available anytime</div>
          </div>
        </div>
        <div class="helpTabs" role="tablist" aria-label="Help tabs">
          <button id="helpTabBasic" class="helpTabBtn active" data-tab="basic" role="tab" aria-selected="true" aria-controls="helpBasic">Basic</button>
          <button id="helpTabAdvanced" class="helpTabBtn" data-tab="advanced" role="tab" aria-selected="false" aria-controls="helpAdvanced" tabindex="-1">Advanced</button>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <button class="helpCloseBtn" onclick="closeHelp()" aria-label="Close help">âœ• Close</button>
        </div>
      </div>

      <div class="helpContent" id="helpContent">
        <div id="helpBasic" data-help-pane="basic">
          <div class="helpSection" id="welcome">
            <h3 data-brand="help-title">Fortnite Jam Mixer Help</h3>
            <p class="small-muted" data-brand="help-intro">Simple steps you can follow fast. Start with Quick Start, then skim the sections below.</p>
          </div>

          <div class="helpSection" id="quickstart">
            <h3>Quick Start (30 seconds)</h3>
            <ol id="helpQuickStartList" style="line-height:1.6"></ol>
          </div>

          <div class="helpSection" id="whatsNew">
            <h3>Whatâ€™s New</h3>
            <ul id="whatsNewList"></ul>
            <p class="small-muted" id="whatsNewEmpty" style="display:none">Nothing new right now â€” check back after the next update.</p>
          </div>

          <div id="helpBasicSections"></div>

          <div class="helpSection" id="helpFaq">
            <h3>Troubleshooting FAQ</h3>
            <div id="helpFaqList"></div>
          </div>
        </div>

        <div id="helpAdvanced" data-help-pane="advanced" style="display:none">
          <div id="helpAdvancedSections"></div>
        </div>
      </div>

      <div class="helpFooter">
        <span class="small-muted" id="helpVersion"></span>
        <div class="helpFooterActions">
          <button class="helpAltBtn" onclick="startTour('help',{ force: true })">Run Quick Tour</button>
          <button class="helpCloseBtn" onclick="closeHelp()">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Quick Start Modal -->
  <div id="quickStartModal" class="quickstart-modal" aria-hidden="true">
    <div class="quickstart-card" role="dialog" aria-modal="true" aria-labelledby="quickStartTitle">
      <div class="flex items-center justify-between mb-3">
        <div>
          <div id="quickStartTitle" class="text-lg font-bold text-white">Quick Start</div>
          <div id="quickStartSubtitle" class="text-xs text-cyan-200">Get mixing in under 30 seconds.</div>
        </div>
        <button class="text-sm text-gray-200 hover:text-white" data-action="closeQuickStart" aria-label="Close Quick Start">âœ•</button>
      </div>
      <div id="quickStartBody" class="space-y-3"></div>
      <div class="quickstart-actions">
        <button class="px-4 py-2 rounded-lg bg-white/10 border border-white/20 text-white" data-action="quickStartBack">Back</button>
        <button class="px-4 py-2 rounded-lg bg-white/10 border border-white/20 text-white" data-action="quickStartSkip">Skip for now</button>
      </div>
    </div>
  </div>

  <!-- Tour Overlay -->
  <div id="tourOverlay" aria-hidden="true">
    <div class="tour-backdrop"></div>
    <div class="tour-highlight" id="tourHighlight" style="display:none"></div>
    <div class="tour-tooltip" id="tourTooltip" role="dialog" aria-modal="true" aria-labelledby="tourTitle">
      <div class="tour-title" id="tourTitle"></div>
      <div class="tour-copy" id="tourCopy"></div>
      <div class="tour-hint" id="tourHint" style="display:none"></div>
      <div class="tour-actions">
        <div class="tour-left">
          <button class="tour-btn" id="tourBackBtn">Back</button>
          <button class="tour-btn tour-btn-secondary" id="tourRouteBtn" style="display:none">Go to Profile</button>
        </div>
        <div class="tour-right">
          <button class="tour-btn" id="tourSkipBtn">Skip</button>
          <button class="tour-btn tour-btn-primary" id="tourNextBtn">Next</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    window.__BOOT__ = window.__BOOT__ || { startedAt: Date.now(), steps: [], lastError: null };
    function pushBootStep(step){
      const entry = { step, at: new Date().toISOString() };
      if(!window.__BOOT__){
        window.__BOOT__ = { startedAt: Date.now(), steps: [], lastError: null };
      }
      window.__BOOT__.steps = window.__BOOT__.steps || [];
      window.__BOOT__.steps.push(entry);
      if(window.__BOOT__.steps.length > 50){
        window.__BOOT__.steps.shift();
      }
      return entry;
    }
    function storeBootError(err){
      const message = err?.message || String(err || 'Unknown error');
      if(!window.__BOOT__){
        window.__BOOT__ = { startedAt: Date.now(), steps: [], lastError: null };
      }
      window.__BOOT__.lastError = message;
      try{
        localStorage.setItem('ffjm:lastBootError', message);
      }catch(e){
        // ignore storage failures
      }
      return message;
    }
    function showFatalBootError(err){
      const message = storeBootError(err);
      if(typeof setAppBootState === 'function' && typeof APP_BOOT_STATES !== 'undefined'){
        setAppBootState(APP_BOOT_STATES.fatal, { error: err instanceof Error ? err : new Error(message) });
        return;
      }
      const steps = window.__BOOT__?.steps || [];
      const lastSteps = steps.slice(-5).map((entry) => `<div class="text-xs text-cyan-100/90">${entry.step} <span class="text-gray-400">${entry.at}</span></div>`).join('') || '<div class="text-xs text-gray-400">No boot steps recorded.</div>';
      document.getElementById('app').innerHTML = `
        <div class="min-h-screen flex items-center justify-center bg-black text-white">
          <div class="max-w-md text-center space-y-4 bg-black/60 border border-red-500/40 rounded-2xl p-6">
            <div class="text-xl font-bold text-red-200">Something went wrong while loading.</div>
            <div class="text-sm text-gray-200">${message}</div>
            <div class="space-y-2 text-left">${lastSteps}</div>
            <div class="flex items-center justify-center gap-3">
              <button onclick="location.reload()" class="px-4 py-2 rounded-lg bg-gradient-to-r from-pink-500 to-cyan-500 text-white font-bold">Retry</button>
              <button onclick="copyBootDebug()" class="px-4 py-2 rounded-lg bg-white/10 border border-white/20 text-white">Copy Debug</button>
            </div>
          </div>
        </div>
      `;
    }
    window.onerror = function(message, source, lineno, colno, error){
      showFatalBootError(error || message);
    };
    window.onunhandledrejection = function(event){
      showFatalBootError(event?.reason || event);
    };

    /**************************************************************************
     * Final merged app
     * - All fixes applied (setlist rendering, show-all toggle, mixable toggle, band member)
     * - Optional Firebase (see firebaseEnabled & firebaseConfig)
     * - Help modal integrated (manual open via header button)
     **************************************************************************/

const DEFAULT_VIEW = 'browse';
let view = DEFAULT_VIEW;
let bootState = 'BOOT_LOADING';
pushBootStep('script start');

const BRAND = Object.freeze({
  APP_NAME: 'Fortnite Jam Mixer',
  SHORT_NAME: 'Jam Mixer',
  EXPORT_PREFIX: 'fortnite-jam-mixer',
  BROWSER_TITLE: 'Fortnite Jam Mixer â€“ Cross-Browser Edition'
});
const DEBUG_UI = true;
const DEBUG_PROFILE = DEBUG_UI || (new URLSearchParams(window.location.search).get('debug') === '1');
let profileScriptError = null;
document.title = BRAND.BROWSER_TITLE;

    // -------------------- FIREBASE (auto-detect) ----------------------------
// We auto-enable Firebase if /api/firebase-config injected window.firebaseConfig (Vercel env vars).
// This prevents the "no signup option" problem when firebaseEnabled was left false.
const DEBUG_LOG_MAX = 50;
function logEvent(type, payload = {}) {
  const entry = {
    type,
    ts: Date.now(),
    payload
  };
  if (typeof location !== 'undefined' && location.hostname === 'localhost') {
    console.log('[telemetry]', entry);
  }
  try {
    const existing = JSON.parse(localStorage.getItem('debugLogs') || '[]');
    existing.push(entry);
    while (existing.length > DEBUG_LOG_MAX) existing.shift();
    localStorage.setItem('debugLogs', JSON.stringify(existing));
  } catch (e) {
    console.warn('Failed to persist debug log', e);
  }
}

function debugProfileLog(message, data = {}){
  if(!DEBUG_PROFILE) return;
  if(Object.keys(data || {}).length){
    console.log(`[debug][profile] ${message}`, data);
  } else {
    console.log(`[debug][profile] ${message}`);
  }
}

function getEventElement(event){
  if(!event) return null;
  const path = typeof event.composedPath === 'function' ? event.composedPath() : null;
  if(path && path.length){
    for(const node of path){
      if(node instanceof Element) return node;
    }
  }
  const target = event.target;
  if(target instanceof Element) return target;
  if(target && target.nodeType === Node.TEXT_NODE) return target.parentElement;
  if(target && target.parentElement) return target.parentElement;
  return null;
}

function closestFromEvent(event, selector, options = {}){
  const start = getEventElement(event);
  if(!start || !selector) return null;
  const match = start.closest(selector);
  if(!match) return null;
  const within = options.within;
  if(within){
    const boundary = typeof within === 'string' ? document.querySelector(within) : within;
    if(boundary instanceof Element && !boundary.contains(match)) return null;
  }
  return match;
}

function showDelegationToast(message){
  if(!DEBUG_UI && !DEBUG_PROFILE) return;
  const existing = document.getElementById('delegationDevToast');
  if(existing){
    existing.textContent = message;
    return;
  }
  const toast = document.createElement('div');
  toast.id = 'delegationDevToast';
  toast.textContent = message;
  toast.style.position = 'fixed';
  toast.style.bottom = '16px';
  toast.style.right = '16px';
  toast.style.zIndex = '9999';
  toast.style.background = 'rgba(0,0,0,0.75)';
  toast.style.color = '#fff';
  toast.style.padding = '8px 12px';
  toast.style.borderRadius = '8px';
  toast.style.fontSize = '12px';
  toast.style.pointerEvents = 'none';
  document.body.appendChild(toast);
  setTimeout(()=>{ toast.remove(); }, 3000);
}

function safeOn(type, handler, meta = {}){
  return function(event){
    try{
      handler(event);
    }catch(err){
      const detail = {
        type,
        action: meta.action || meta.selector || 'unknown',
        stack: err?.stack || String(err)
      };
      console.error('[delegation] handler error', detail);
      showDelegationToast(`[delegation] ${type} error`);
    }
  };
}

const firebaseConfig = window.firebaseConfig || {};
const firebaseConfigValid = !!firebaseConfig?.apiKey;
let firebaseEnabled = false;

    const ADMIN_USERS = ['BattleNeBody'];
    function applyAdminFlag(profile){
      if(!profile) return profile;
      return { ...profile, isAdmin: ADMIN_USERS.includes(profile.username) };
    }
    function adminStatusChanged(originalProfile, updatedProfile){
      if(!updatedProfile) return false;
      const previous = originalProfile?.isAdmin ?? false;
      return previous !== (updatedProfile.isAdmin ?? false) || typeof originalProfile?.isAdmin === 'undefined';
    }
    async function persistAdminFlagIfNeeded(originalProfile, updatedProfile){
      if(!updatedProfile) return;
      if(adminStatusChanged(originalProfile, updatedProfile)){
        await saveUserProfileToBackend(updatedProfile);
      }
    }

function applyBrandingCopy(){
  const loading = document.querySelector('[data-brand="loading"]');
  if(loading) loading.textContent = `Loading ${BRAND.APP_NAME}...`;
  const helpTitle = document.querySelector('[data-brand="help-title"]');
  if(helpTitle) helpTitle.textContent = `${BRAND.APP_NAME} Help`;
  const helpIntro = document.querySelector('[data-brand="help-intro"]');
  if(helpIntro) helpIntro.textContent = `A fast guide to the working features in ${BRAND.APP_NAME}. Open this help anytime with the â“ button in the header.`;
  const camelotAnchor = document.querySelector('[data-brand="help-anchor-camelot"]');
  if(camelotAnchor) camelotAnchor.textContent = `How ${BRAND.APP_NAME} uses Camelot`;
  const priorityDesc = document.querySelector('[data-brand="priority-desc"]');
  if(priorityDesc) priorityDesc.textContent = `${BRAND.APP_NAME} always calculates a blended compatibility score (Key â†’ BPM â†’ Genre). Priority modes only decide how ties are broken, not the overall score.`;
  const camelotHeading = document.querySelector('[data-brand="camelot-heading"]');
  if(camelotHeading) camelotHeading.textContent = `How ${BRAND.APP_NAME} Uses Camelot`;
}

let delegationSelfTested = false;
function runDelegationSelfTest(){
  if(delegationSelfTested || (!DEBUG_UI && !DEBUG_PROFILE)) return;
  delegationSelfTested = true;
  const helpersReady = typeof getEventElement === 'function' && typeof closestFromEvent === 'function' && typeof safeOn === 'function';
  console.log('[delegation] hardened listeners active', { helpersReady, documentClick: dataActionDelegatesBound === true });
}

applyBrandingCopy();

window.addEventListener('error', (event) => {
  logEvent('error', {
    message: event?.message || 'Unknown error',
    stack: event?.error?.stack || null,
    view,
    firebaseEnabled,
    online: navigator.onLine
  });
  notifyProfileScriptError(event?.message || 'Profile scripts failed. Open console.', event?.error || event);
});
window.addEventListener('unhandledrejection', (event) => {
  logEvent('unhandledrejection', {
    message: event?.reason?.message || event?.reason || 'Unknown rejection',
    stack: event?.reason?.stack || null,
    view,
    firebaseEnabled,
    online: navigator.onLine
  });
  notifyProfileScriptError(event?.reason?.message || 'Profile scripts failed. Open console.', event?.reason || event);
});

function buildExportFilename(username = 'profile'){
  const safeName = (username || 'profile').trim() || 'profile';
  return `${BRAND.EXPORT_PREFIX}-${safeName}.json`;
}

function formatSyncTimestamp(value){
  if(!value) return 'â€”';
  const date = new Date(Number(value));
  if(Number.isNaN(date.getTime())) return 'â€”';
  return date.toLocaleString();
}

let firebaseApp = null, firebaseAuth = null, firestore = null;
let firebaseAuthUnsub = null;
let userProfileUnsub = null;
let authSettledUser = null;
let authProcessing = false;
let authInFlight = false;
let appConfigLoaded = false;
if (firebaseConfigValid && window.firebase?.initializeApp && window.firebase?.auth && window.firebase?.firestore) {
  try {
    firebaseApp = firebase.initializeApp(firebaseConfig);
    firebaseAuth = firebase.auth();
    firestore = firebase.firestore();
    firebaseEnabled = true;
    if(window.profileStore?.setFirestore) window.profileStore.setFirestore(firestore);
    if(window.profileStore?.setFirebase) window.profileStore.setFirebase(firebase);
    console.log('Firebase initialized');
    logEvent('firebase_init', { projectId: firebaseConfig.projectId });
  } catch (e) {
    console.warn('Firebase init failed', e);
    logEvent('firebase_init_fail', { message: e?.message, code: e?.code });
    firebaseApp = null;
    firebaseAuth = null;
    firestore = null;
    firebaseEnabled = false;
  }
} else {
  logEvent('firebase_disabled', { reason: 'missing config or sdk', firebaseConfigValid });
}

function getAppVersion(){
  return window.appVersion || window.APP_VERSION || firebaseConfig?.appVersion || firebaseConfig?.version || null;
}
function warnIfWhatsNewStale(){
  const host = typeof location !== 'undefined' ? location.hostname : '';
  const isDevHost = host === 'localhost' || host === '127.0.0.1';
  if(!isDevHost) return;
  const appVersion = getAppVersion();
  const items = Array.isArray(window.DEFAULT_WHATS_NEW?.items) ? window.DEFAULT_WHATS_NEW.items : [];
  if(!appVersion || items.length === 0) return;
  const signature = items.map(item => item.id).join('|');
  let previous = {};
  try{
    previous = JSON.parse(localStorage.getItem('whatsNewSignature') || '{}');
  }catch(_){}
  if(previous?.version && previous.version !== appVersion && previous.signature === signature){
    console.warn(`[whats-new] APP_VERSION changed to ${appVersion} but WHATS_NEW looks unchanged.`);
  }
  localStorage.setItem('whatsNewSignature', JSON.stringify({ version: appVersion, signature }));
}
warnIfWhatsNewStale();
let helpContentState = window.DEFAULT_HELP_CONTENT || null;
let whatsNewState = window.DEFAULT_WHATS_NEW || null;
let configLoadPromise = null;
function getFirebaseAnalytics(){
  if(!firebaseEnabled) return null;
  if(typeof firebase?.analytics !== 'function') return null;
  try {
    return firebase.analytics();
  } catch (e) {
    console.warn('Firebase analytics unavailable', e);
    return null;
  }
}
function track(eventName, payload = {}){
  const safePayload = payload && typeof payload === 'object' ? payload : {};
  const analyticsInstance = getFirebaseAnalytics();
  if(analyticsInstance && typeof analyticsInstance.logEvent === 'function'){
    try {
      analyticsInstance.logEvent(eventName, safePayload);
      return;
    } catch (e) {
      console.warn('Analytics logEvent failed', e);
    }
  }
  console.debug('[analytics]', eventName, safePayload);
}


    function normalizeStreamUrlInput(value){
      const trimmed = (value || '').trim();
      if(!trimmed) return '';
      if(/^https?:\/\//i.test(trimmed)) return trimmed;
      if(/^www\./i.test(trimmed)) return `https://${trimmed}`;
      if(/^[\w.-]+\.[a-z]{2,}/i.test(trimmed)) return `https://${trimmed}`;
      return trimmed;
    }
    function isValidStreamUrl(value){
      if(!value) return false;
      try{
        const parsed = new URL(value);
        return ['http:','https:'].includes(parsed.protocol) && !!parsed.hostname;
      }catch(_){
        return false;
      }
    }
    function normalizeLiveProfileFields(profile){
      const streamUrl = normalizeStreamUrlInput(profile?.streamUrl || '');
      const streamUrlValid = isValidStreamUrl(streamUrl);
      const liveStartedAt = streamUrlValid ? (profile?.liveStartedAt || profile?.liveSince || null) : null;
      return {
        streamUrl,
        isLive: streamUrlValid ? profile?.isLive === true : false,
        liveStartedAt
      };
    }
    const RATING_TAGS = ['Vibes', 'Transitions', 'Song Selection', 'Crowd Control', 'FX', 'Mixing'];
    const RATING_MAX_COMMENT = 140;
    const RATING_UPDATE_LIMIT = 3;
    const RATING_WINDOW_MS = 60 * 60 * 1000;

    function normalizeRatingBreakdown(breakdown){
      const base = { 1:0, 2:0, 3:0, 4:0, 5:0 };
      if(!breakdown) return base;
      Object.keys(base).forEach(key=>{
        const val = Number(breakdown[key] ?? breakdown[Number(key)]);
        base[key] = Number.isFinite(val) && val > 0 ? Math.floor(val) : 0;
      });
      return base;
    }

    function computeRatingAggregates(breakdown){
      const ratingBreakdown = normalizeRatingBreakdown(breakdown);
      const ratingCount = Object.values(ratingBreakdown).reduce((sum, val)=> sum + val, 0);
      const totalStars = Object.entries(ratingBreakdown).reduce((sum, [stars, count])=> sum + (Number(stars) * count), 0);
      const avgRating = ratingCount ? Number((totalStars / ratingCount).toFixed(2)) : 0;
      return { avgRating, ratingCount, ratingBreakdown };
    }

    function normalizeRatingFields(profile){
      const ratingBreakdown = normalizeRatingBreakdown(profile?.ratingBreakdown);
      const computed = computeRatingAggregates(ratingBreakdown);
      const avgCandidate = Number(profile?.avgRating);
      const countCandidate = Number(profile?.ratingCount);
      return {
        avgRating: Number.isFinite(avgCandidate) ? avgCandidate : computed.avgRating,
        ratingCount: Number.isFinite(countCandidate) ? countCandidate : computed.ratingCount,
        ratingBreakdown: ratingBreakdown
      };
    }

    const PROFILE_COLLECTION = 'users';
    const LEGACY_PROFILE_COLLECTION = 'profiles';
    const PROFILE_BIO_MAX = 160;
    const PERSONA_STORAGE_KEYS = Object.freeze({
      id: 'profilePersonaId',
      theme: 'profilePersonaTheme',
      seed: 'profilePersonaSeed'
    });
    const PERSONA_THEMES = [
      { id: 'neonPop', label: 'Neon Pop', ring: ['#ff6b9d', '#38bdf8'], background: ['#1e1b4b', '#0f172a'], accent: '#facc15', glow: 'rgba(255,107,157,0.55)', particle: '#fef3c7' },
      { id: 'midnight', label: 'Midnight', ring: ['#0ea5e9', '#6366f1'], background: ['#0f172a', '#111827'], accent: '#38bdf8', glow: 'rgba(56,189,248,0.4)', particle: '#e0f2fe' },
      { id: 'sunset', label: 'Sunset', ring: ['#fb7185', '#f97316'], background: ['#3b0a2a', '#1f2937'], accent: '#facc15', glow: 'rgba(249,115,22,0.4)', particle: '#fde68a' },
      { id: 'mintwave', label: 'Mintwave', ring: ['#22d3ee', '#34d399'], background: ['#0f172a', '#064e3b'], accent: '#a7f3d0', glow: 'rgba(52,211,153,0.4)', particle: '#ccfbf1' },
      { id: 'orbit', label: 'Orbit', ring: ['#60a5fa', '#c084fc'], background: ['#111827', '#312e81'], accent: '#f472b6', glow: 'rgba(192,132,252,0.45)', particle: '#fbcfe8' }
    ];
    const PERSONAS = Object.freeze({
      raver: {
        id: 'raver',
        name: 'Raver',
        energy: 'âš¡',
        render: ({ theme }) => `
          <circle cx="128" cy="86" r="22" fill="${theme.accent}" opacity="0.9"/>
          <path d="M58 128 L96 96" stroke="${theme.accent}" stroke-width="10" stroke-linecap="round"/>
          <path d="M198 128 L160 96" stroke="${theme.accent}" stroke-width="10" stroke-linecap="round"/>
          <path d="M92 188 L128 138 L164 188" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round" opacity="0.9"/>
          <circle cx="68" cy="116" r="6" fill="${theme.particle}"/>
          <circle cx="188" cy="116" r="6" fill="${theme.particle}"/>
        `
      },
      mc: {
        id: 'mc',
        name: 'MC',
        energy: 'ðŸŽ¤',
        render: ({ theme }) => `
          <circle cx="128" cy="90" r="22" fill="${theme.accent}" opacity="0.95"/>
          <rect x="96" y="70" width="64" height="16" rx="8" fill="${theme.ring[0]}" opacity="0.9"/>
          <path d="M92 168 L128 128 L164 168" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/>
          <rect x="178" y="120" width="18" height="40" rx="6" fill="${theme.ring[1]}" opacity="0.9"/>
          <circle cx="187" cy="112" r="10" fill="${theme.accent}"/>
        `
      },
      breaker: {
        id: 'breaker',
        name: 'Breaker',
        energy: 'ðŸ”¥',
        render: ({ theme }) => `
          <circle cx="110" cy="92" r="18" fill="${theme.accent}" opacity="0.95"/>
          <path d="M70 172 L122 132 L170 154" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M156 104 L182 70" stroke="${theme.ring[1]}" stroke-width="12" stroke-linecap="round"/>
          <path d="M84 130 L52 92" stroke="${theme.ring[0]}" stroke-width="12" stroke-linecap="round"/>
        `
      },
      turntablist: {
        id: 'turntablist',
        name: 'Turntablist',
        energy: 'ðŸŽ§',
        render: ({ theme }) => `
          <circle cx="128" cy="78" r="20" fill="${theme.accent}" opacity="0.95"/>
          <rect x="64" y="120" width="128" height="48" rx="14" fill="rgba(255,255,255,0.12)" stroke="${theme.ring[1]}" stroke-width="4"/>
          <circle cx="104" cy="144" r="16" fill="${theme.ring[0]}" opacity="0.9"/>
          <circle cx="152" cy="144" r="12" fill="${theme.ring[1]}" opacity="0.9"/>
          <path d="M110 178 L128 148 L146 178" stroke="white" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/>
        `
      },
      producer: {
        id: 'producer',
        name: 'Producer',
        energy: 'ðŸ’»',
        render: ({ theme }) => `
          <circle cx="128" cy="80" r="20" fill="${theme.accent}" opacity="0.95"/>
          <rect x="70" y="120" width="116" height="54" rx="10" fill="rgba(255,255,255,0.1)" stroke="${theme.ring[0]}" stroke-width="4"/>
          <path d="M86 148 L106 138 L126 146 L146 132 L170 140" stroke="${theme.accent}" stroke-width="6" stroke-linecap="round"/>
        `
      },
      rocker: {
        id: 'rocker',
        name: 'Rock Shredder',
        energy: 'ðŸŽ¸',
        render: ({ theme }) => `
          <circle cx="108" cy="86" r="20" fill="${theme.accent}" opacity="0.95"/>
          <path d="M88 160 L132 118 L176 170" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/>
          <circle cx="188" cy="178" r="14" fill="${theme.ring[1]}" opacity="0.9"/>
          <rect x="150" y="146" width="48" height="10" rx="5" fill="${theme.ring[0]}"/>
        `
      },
      disco: {
        id: 'disco',
        name: 'Disco Diva',
        energy: 'âœ¨',
        render: ({ theme }) => `
          <circle cx="128" cy="78" r="20" fill="${theme.accent}" opacity="0.95"/>
          <circle cx="128" cy="122" r="22" fill="rgba(255,255,255,0.18)" stroke="${theme.ring[0]}" stroke-width="4"/>
          <path d="M90 176 L128 136 L166 176" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/>
          <circle cx="112" cy="118" r="6" fill="${theme.particle}"/>
          <circle cx="144" cy="126" r="6" fill="${theme.particle}"/>
        `
      },
      cyber: {
        id: 'cyber',
        name: 'Cyber DJ',
        energy: 'ðŸ›¸',
        render: ({ theme }) => `
          <circle cx="128" cy="88" r="22" fill="${theme.accent}" opacity="0.95"/>
          <rect x="90" y="78" width="76" height="18" rx="9" fill="${theme.ring[1]}" opacity="0.9"/>
          <path d="M88 170 L128 130 L168 170" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M104 108 L152 108" stroke="${theme.particle}" stroke-width="4" stroke-linecap="round"/>
        `
      },
      punk: {
        id: 'punk',
        name: 'Punk',
        energy: 'ðŸ”Š',
        render: ({ theme }) => `
          <circle cx="128" cy="86" r="20" fill="${theme.accent}" opacity="0.95"/>
          <path d="M112 64 L128 40 L144 64" stroke="${theme.ring[0]}" stroke-width="8" stroke-linecap="round"/>
          <rect x="70" y="130" width="116" height="46" rx="12" fill="rgba(255,255,255,0.12)" stroke="${theme.ring[1]}" stroke-width="4"/>
          <circle cx="102" cy="152" r="10" fill="${theme.accent}"/>
          <circle cx="154" cy="152" r="10" fill="${theme.accent}"/>
        `
      },
      kpop: {
        id: 'kpop',
        name: 'K-Pop',
        energy: 'â­',
        render: ({ theme }) => `
          <circle cx="128" cy="84" r="20" fill="${theme.accent}" opacity="0.95"/>
          <path d="M94 178 L128 136 L162 178" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M70 118 L90 88" stroke="${theme.ring[0]}" stroke-width="8" stroke-linecap="round"/>
          <path d="M186 118 L166 88" stroke="${theme.ring[1]}" stroke-width="8" stroke-linecap="round"/>
          <circle cx="70" cy="124" r="6" fill="${theme.particle}"/>
          <circle cx="186" cy="124" r="6" fill="${theme.particle}"/>
        `
      }
    });
    const PERSONA_LIST = Object.values(PERSONAS);
    // Persona QA checklist:
    // 1) Profile â†’ pick a persona â†’ refresh â†’ selection persists.
    // 2) Change theme â†’ ring/background update instantly.
    // 3) Randomize seed â†’ sparkles/accents shift.
    // 4) Go offline â†’ persona picker still works with no errors.
    const THEME_ACCENTS = [
      { id: 'pink-pop', label: 'Pink Pop', color: '#ff6b9d' },
      { id: 'electric-blue', label: 'Electric Blue', color: '#38bdf8' },
      { id: 'neon-violet', label: 'Neon Violet', color: '#a855f7' },
      { id: 'sunset-gold', label: 'Sunset Gold', color: '#facc15' },
      { id: 'mint-laser', label: 'Mint Laser', color: '#34d399' }
    ];

    function getProfileCollection(){
      return firestore ? firestore.collection(PROFILE_COLLECTION) : null;
    }

    function getLegacyProfileCollection(){
      return firestore ? firestore.collection(LEGACY_PROFILE_COLLECTION) : null;
    }

    function normalizeUsernameLower(value){
      return (value || '').trim().toLowerCase();
    }

    function buildSearchTokens(value){
      const normalized = normalizeUsernameLower(value);
      const maxTokens = Math.min(20, normalized.length);
      const tokens = [];
      for(let i=1; i<=maxTokens; i+=1){
        tokens.push(normalized.slice(0, i));
      }
      return tokens;
    }

    function hexToRgba(hex, alpha = 0.45){
      const clean = (hex || '').replace('#','');
      const normalized = clean.length === 3
        ? clean.split('').map(ch => ch + ch).join('')
        : clean;
      if(normalized.length !== 6) return `rgba(255,107,157,${alpha})`;
      const r = parseInt(normalized.slice(0,2), 16);
      const g = parseInt(normalized.slice(2,4), 16);
      const b = parseInt(normalized.slice(4,6), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function resolveThemeAccent(accent){
      const preset = THEME_ACCENTS.find(item => item.id === accent);
      if(preset) return preset.color;
      if(/^#([0-9a-f]{3}){1,2}$/i.test(accent || '')) return accent;
      return THEME_ACCENTS[0].color;
    }

    function createSeededRandom(seed){
      let hash = 0;
      String(seed || '').split('').forEach((char)=>{
        hash = ((hash << 5) - hash) + char.charCodeAt(0);
        hash |= 0;
      });
      let value = Math.abs(hash) || 1;
      return () => {
        value = (value * 9301 + 49297) % 233280;
        return value / 233280;
      };
    }

    function getStoredPersona(){
      return {
        personaId: localStorage.getItem(PERSONA_STORAGE_KEYS.id),
        personaTheme: localStorage.getItem(PERSONA_STORAGE_KEYS.theme),
        personaSeed: localStorage.getItem(PERSONA_STORAGE_KEYS.seed)
      };
    }

    function persistPersonaToStorage(persona){
      if(!persona) return;
      if(persona.personaId) localStorage.setItem(PERSONA_STORAGE_KEYS.id, persona.personaId);
      if(persona.personaTheme) localStorage.setItem(PERSONA_STORAGE_KEYS.theme, persona.personaTheme);
      if(persona.personaSeed) localStorage.setItem(PERSONA_STORAGE_KEYS.seed, persona.personaSeed);
    }

    function ensurePersona(profile){
      const fallbackSeed = profile?.username || profile?.uid || localDeviceId || Math.random().toString(36).slice(2, 8);
      const isSelf = !!(profile && currentUser && ((profile.uid && profile.uid === currentUser.uid) || (profile.username && profile.username === currentUser.username)));
      const stored = isSelf || !profile ? getStoredPersona() : {};
      const personaId = profile?.personaId || stored.personaId || 'turntablist';
      const personaTheme = profile?.personaTheme || stored.personaTheme || 'neonPop';
      const personaSeed = profile?.personaSeed || stored.personaSeed || fallbackSeed;
      return { personaId, personaTheme, personaSeed };
    }

    function getPersonaTheme(themeId){
      return PERSONA_THEMES.find(item => item.id === themeId) || PERSONA_THEMES[0];
    }

    function renderPersonaSVG({ personaId, themeId, seed, size = 96 }){
      const persona = PERSONAS[personaId] || PERSONAS.turntablist;
      const theme = getPersonaTheme(themeId);
      const random = createSeededRandom(`${seed}-${personaId}-${themeId}`);
      const unique = Math.abs(Math.floor(random() * 100000));
      const bgId = `persona-bg-${personaId}-${unique}`;
      const ringId = `persona-ring-${personaId}-${unique}`;
      const accentId = `persona-accent-${personaId}-${unique}`;
      const sparkles = Array.from({ length: 5 }).map(() => {
        const cx = 48 + Math.floor(random() * 160);
        const cy = 48 + Math.floor(random() * 160);
        const r = 3 + Math.floor(random() * 5);
        return `<circle class="persona-spark" cx="${cx}" cy="${cy}" r="${r}" fill="${theme.particle}" opacity="0.7"/>`;
      }).join('');
      return `
        <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 256 256" role="img" aria-label="${persona.name} persona">
          <defs>
            <linearGradient id="${bgId}" x1="0" x2="1" y1="0" y2="1">
              <stop offset="0%" stop-color="${theme.background[0]}"/>
              <stop offset="100%" stop-color="${theme.background[1]}"/>
            </linearGradient>
            <linearGradient id="${ringId}" x1="0" x2="1" y1="0" y2="1">
              <stop offset="0%" stop-color="${theme.ring[0]}"/>
              <stop offset="100%" stop-color="${theme.ring[1]}"/>
            </linearGradient>
            <radialGradient id="${accentId}" cx="0.5" cy="0.4" r="0.6">
              <stop offset="0%" stop-color="${theme.accent}"/>
              <stop offset="100%" stop-color="rgba(255,255,255,0)"/>
            </radialGradient>
          </defs>
          <rect width="256" height="256" rx="56" fill="url(#${bgId})"/>
          <circle cx="128" cy="128" r="102" fill="url(#${accentId})" opacity="0.45"/>
          ${sparkles}
          <circle class="persona-ring" cx="128" cy="128" r="108" fill="none" stroke="url(#${ringId})" stroke-width="10" opacity="0.9"/>
          ${persona.render({ theme })}
        </svg>
      `.trim();
    }

    function renderPersonaBadge(profile, size = 48, extraClass = ''){
      const persona = ensurePersona(profile);
      const personaSvg = renderPersonaSVG({
        personaId: persona.personaId,
        themeId: persona.personaTheme,
        seed: persona.personaSeed,
        size
      });
      const energy = (PERSONAS[persona.personaId] || PERSONAS.turntablist).energy || 'âš¡';
      const label = escapeHtml(profile?.djName || profile?.username || 'DJ');
      return `
        <div class="persona-badge ${extraClass}" style="width:${size}px;height:${size}px;" aria-label="${label} persona">
          ${personaSvg}
          <span class="persona-energy">${energy}</span>
        </div>
      `.trim();
    }

    // Backend save/load wrappers (Firestore or localStorage)
    function normalizeProfileShape(profile, fallbackId){
      if(!profile) return null;
      const ownedFromMap = Object.keys(profile.ownedMap || {});
      const ownedArray = Array.isArray(profile.ownedTracks) ? profile.ownedTracks : ownedFromMap;
      const username = profile.username || fallbackId || profile.uid || '';
      const djName = profile.djName || username;
      const email = profile.email || profile.mail || '';
      const oauth = profile.oauth || {};
      const isAdmin = profile.isAdmin === true;
      const normalizedSetlist = normalizeSetlistIds(profile.setlist || profile.setlistIds || profile.setlists);
      const liveDefaults = normalizeLiveProfileFields(profile);
      const ratingDefaults = normalizeRatingFields(profile);
      const persona = ensurePersona(profile);
      const bio = (profile.bio || '').slice(0, PROFILE_BIO_MAX);
      const themeAccent = profile.themeAccent || THEME_ACCENTS[0].id;
      const isPublic = profile.isPublic !== false;
      const allowFriendRequests = profile.allowFriendRequests !== false;
      const rulesAccepted = profile.rulesAccepted === true;
      const rulesAcceptedAt = profile.rulesAcceptedAt || null;
      const usernameLower = profile.usernameLower || normalizeUsernameLower(username);
      const djNameLower = profile.djNameLower || normalizeUsernameLower(djName);
      const searchNameLower = profile.searchNameLower || usernameLower;
      const searchTokens = Array.isArray(profile.searchTokens) ? profile.searchTokens : buildSearchTokens(usernameLower);
      const { setlists, setlistIds, ...profileRest } = profile;
      return {
        ...profileRest,
        ...liveDefaults,
        ...ratingDefaults,
        username,
        djName,
        email,
        ownedTracks: ownedArray,
        setlist: normalizedSetlist,
        oauth,
        isAdmin,
        bio,
        themeAccent,
        personaId: persona.personaId,
        personaTheme: persona.personaTheme,
        personaSeed: persona.personaSeed,
        isPublic,
        allowFriendRequests,
        rulesAccepted,
        rulesAcceptedAt,
        usernameLower,
        djNameLower,
        searchNameLower,
        searchTokens
      };
    }

    function migrateProfile(profile){
      const safe = profile ? { ...profile } : {};
      const owned = Array.isArray(safe.ownedTracks) ? safe.ownedTracks : [];
      const band = Array.isArray(safe.bandMembers) ? safe.bandMembers : [];
      const setlistIds = normalizeSetlistIds(safe.setlist || safe.setlistIds || safe.setlists || []);
      const genre = safe.genreOverrides && typeof safe.genreOverrides === 'object' ? safe.genreOverrides : {};
      const ownedNormalized = normalizeOwnedList(owned).map(id => String(id));
      safe.ownedTracks = ownedNormalized;
      safe.bandMembers = band.filter(Boolean).map(member => ({
        ...member,
        username: member?.username ? String(member.username) : member?.username,
        djName: member?.djName ? String(member.djName) : member?.djName
      }));
      safe.setlist = setlistIds;
      safe.setlists = Array.isArray(safe.setlists) ? safe.setlists : [];
      safe.genreOverrides = genre;
      safe.schemaVersion = 1;
      safe.updatedAt = Number.isFinite(safe.updatedAt) ? safe.updatedAt : Date.now();
      if(!safe.createdAt) safe.createdAt = safe.updatedAt;
      return safe;
    }

    function mergeProfileSources({ localProfile, snapshotProfile, remoteProfile }){
      const local = localProfile || {};
      const snapshot = snapshotProfile || {};
      const remote = remoteProfile || {};
      const owned = new Set([
        ...(local.ownedTracks || []),
        ...(snapshot.ownedTracks || []),
        ...(remote.ownedTracks || [])
      ].map(id => String(id)));
      const bandMembers = new Map();
      [local.bandMembers, snapshot.bandMembers, remote.bandMembers].forEach(list => {
        (list || []).forEach(member => {
          const key = member?.username || member?.uid;
          if(key && !bandMembers.has(key)) bandMembers.set(key, member);
        });
      });
      const genreOverrides = {
        ...(remote.genreOverrides || {}),
        ...(snapshot.genreOverrides || {}),
        ...(local.genreOverrides || {})
      };
      const candidates = [local, snapshot, remote].filter(Boolean);
      const newest = candidates.reduce((acc, item) => {
        const accTime = Number(acc?.updatedAt) || 0;
        const itemTime = Number(item?.updatedAt) || 0;
        return itemTime > accTime ? item : acc;
      }, null);
      const merged = {
        ...remote,
        ...snapshot,
        ...local,
        ownedTracks: Array.from(owned),
        bandMembers: Array.from(bandMembers.values()),
        genreOverrides,
        setlist: normalizeSetlistIds(newest?.setlist || newest?.setlistIds || newest?.setlists || local?.setlist || [])
      };
      return merged;
    }

    function getProfileStorageKey(){
      return firebaseAuth?.currentUser?.uid
        || currentUser?.uid
        || currentUser?.username
        || getSavedUsername()
        || getLocalDeviceId();
    }

    async function hydrateProfileRobust(){
      const profileKey = getProfileStorageKey();
      const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');
      const localProfile = profiles[profileKey] || profiles[currentUser?.username] || profiles[currentUser?.uid] || null;
      let snapshotProfile = null;
      if(!localProfile){
        snapshotProfile = JSON.parse(localStorage.getItem(`${PROFILE_SNAPSHOT_PREFIX}${profileKey}`) || 'null');
        if(snapshotProfile){
          boot.usedSnapshotProfile = true;
        }
      }
      let remoteProfile = null;
      if(firebaseEnabled && firebaseAuth?.currentUser && navigator.onLine){
        await awaitAuthReady();
        try{
          remoteProfile = await window.profileStore?.readCloudProfile?.(firebaseAuth.currentUser.uid);
          if(remoteProfile?.uid){
            try{
              const ownedSnapshot = await window.profileStore?.readOwnedLibraryDoc?.(remoteProfile.uid);
              if(ownedSnapshot?.trackIds?.length){
                remoteProfile.ownedTracks = ownedSnapshot.trackIds;
              }
            }catch(err){
              console.warn('[profile] owned library fetch failed', err);
            }
          }
        }catch(err){
          console.warn('[profile] remote profile fetch failed', err);
          boot.errors.push(err?.message || String(err));
        }
      }
      const merged = mergeProfileSources({ localProfile, snapshotProfile, remoteProfile });
      const migrated = migrateProfile(normalizeProfileShape(merged, profileKey) || merged);
      localStorage.setItem(`${PROFILE_SNAPSHOT_PREFIX}${profileKey}`, JSON.stringify(migrated));
      return migrated;
    }

    function currentProfileFromState(){
      if(!currentUser) return null;
      syncPreferencesIntoProfile();
      const normalizedStreamUrl = normalizeStreamUrlInput(currentUser.streamUrl || '');
      const streamUrlValid = isValidStreamUrl(normalizedStreamUrl);
      const usernameLower = normalizeUsernameLower(currentUser.username);
      const djNameLower = normalizeUsernameLower(currentUser.djName || currentUser.username);
      const displayNameLower = normalizeUsernameLower(currentUser.djName || currentUser.username);
      const searchNameLower = usernameLower;
      const persona = ensurePersona(currentUser);
      persistPersonaToStorage(persona);
      const bio = (currentUser.bio || '').slice(0, PROFILE_BIO_MAX);
      const themeAccent = currentUser.themeAccent || THEME_ACCENTS[0].id;
      const isPublic = currentUser.isPublic !== false;
      const allowFriendRequests = currentUser.allowFriendRequests !== false;
      const rulesAccepted = currentUser.rulesAccepted === true;
      const rulesAcceptedAt = currentUser.rulesAcceptedAt || null;
      const { ownedTracks: currentOwnedTracks, ownedMap: currentOwnedMap, ...currentUserRest } = currentUser || {};
      const mergedProfile = {
        ...currentUserRest,
        uid: firebaseAuth?.currentUser?.uid || currentUser.uid,
        username: currentUser.username,
        djName: (currentUser.djName || currentUser.username || '').trim() || currentUser.username,
        usernameLower,
        djNameLower,
        displayNameLower,
        searchNameLower,
        searchTokens: buildSearchTokens(usernameLower),
        bio,
        themeAccent,
        personaId: persona.personaId,
        personaTheme: persona.personaTheme,
        personaSeed: persona.personaSeed,
        isPublic,
        allowFriendRequests,
        rulesAccepted,
        rulesAcceptedAt,
        setlist: setlist || [],
        bandMembers,
        genreOverrides,
        streamUrl: normalizedStreamUrl,
        isLive: streamUrlValid ? currentUser.isLive === true : false,
        liveStartedAt: streamUrlValid ? (currentUser.liveStartedAt || currentUser.liveSince || null) : null,
        oauth: currentUser.oauth || {},
        tour: currentUser.tour || {},
        preferences: {
          keyMatchMode,
          maxSemitoneRange,
          includeOppositeMode,
          priorityStrength
        }
      };
      return migrateProfile({ ...mergedProfile, ownedTracks: normalizeOwnedList(currentOwnedTracks || ownedTracks || []) });
    }

    async function persistProfileRobust(profile, { force = false, reason = 'system' } = {}){
      if(!profile) return { backendOk: false, blocked: true };
      const migrated = migrateProfile(profile);
      const safeOwnedTracks = resolveSafeOwnedTracks(migrated, { reason });
      migrated.ownedTracks = safeOwnedTracks;
      const ownedCount = safeOwnedTracks.length;
      const fenceActive = boot.phase !== 'ready' && boot.initialOwnedCount > 0 && ownedCount === 0;
      const shrinkDetected = ownedCount < boot.initialOwnedCount && boot.initialOwnedCount > 0 && !userInitiatedClear && !shouldAllowEmptyOwnedWrite(reason);
      if(!force && (fenceActive || shrinkDetected)){
        writeFenceBlockedSave = true;
        maybeShowRecoveryBanner();
        console.warn('[profile] write fence blocked save', { fenceActive, shrinkDetected, phase: boot.phase });
        return { backendOk: false, blocked: true };
      }
      writeFenceBlockedSave = false;
      const profileKey = migrated.uid || migrated.username;
      const updatedAt = Date.now();
      migrated.updatedAt = updatedAt;
      migrated.schemaVersion = window.profileStore?.PROFILE_SCHEMA_VERSION || 2;
      if(shouldUseLegacyStorage(migrated)){
        const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');
        const shouldStoreByUsername = !migrated.uid || migrated.uid.startsWith('local:') || migrated.mode === 'local';
        if(migrated.username && shouldStoreByUsername){
          profiles[migrated.username] = { ...(profiles[migrated.username] || {}), ...migrated };
        }
        if(profileKey) profiles[profileKey] = { ...(profiles[profileKey] || {}), ...migrated };
        localStorage.setItem('userProfiles', JSON.stringify(profiles));
      }
      if(profileKey){
        localStorage.setItem(`${PROFILE_SNAPSHOT_PREFIX}${profileKey}`, JSON.stringify(migrated));
      }
      persistUserSession(migrated, { reason, skipBackend: true }).catch(()=>{});
      const backendOk = await saveUserProfileToBackend(migrated, { reason });
      return { backendOk, profile: migrated };
    }

    async function applyProfileToState(profile, { loadEpic = false, loadOverrides = false, skipPersist = false } = {}){
      if(!profile) return;
      const nextSessionKey = getUserStorageId(profile);
      const switchingUser = activeSessionKey && nextSessionKey && activeSessionKey !== nextSessionKey;
      if(switchingUser){
        ownedTracks = [];
        setlist = [];
        bandMembers = [];
        genreOverrides = {};
      }
      activeSessionKey = nextSessionKey || activeSessionKey;
      const hydratedProfile = await hydrateUserSession(profile);
      currentUser = applyAdminFlag(hydratedProfile);
      justEnteredProfile = true;
      await persistAdminFlagIfNeeded(hydratedProfile, currentUser);
      applyPreferencesFromProfile(currentUser);
      loadSandboxState();
      loadOverridesFromStorage();
      if(loadOverrides){
        await loadUserOverridesFromBackend();
      }
      const incomingOwned = normalizeOwnedList(currentUser.ownedTracks || []);
      const store = ensureOwnedLibraryStore();
      if(store){
        const storeUid = store.getMeta?.().uid;
        const targetUid = currentUser.uid || ensureLocalDeviceId();
        if(storeUid !== targetUid){
          await initOwnedLibraryForUser(targetUid, { initialTrackIds: incomingOwned.length ? incomingOwned : ownedTracks, skipCloud: !firebaseAuth?.currentUser });
        }
      } else if(incomingOwned.length){
        ownedTracks = incomingOwned;
      }
      setlist = normalizeSetlistIds(currentUser.setlist || currentUser.setlistIds || currentUser.setlists || []);
      bandMembers = currentUser.bandMembers || [];
      genreOverrides = currentUser.genreOverrides || {};
      refreshDraftProfileFromCurrentUser();
      if(loadEpic){
        await fetchEpicLinkStatus();
      }
      if(currentUser?.uid || currentUser?.username){
        const profileKey = currentUser.uid || currentUser.username;
        localStorage.setItem('currentUser', profileKey);
      }
      if(currentUser?.mode === 'local' || currentUser?.uid?.startsWith('local:')){
        localStorage.setItem('localProfile', JSON.stringify(currentUser));
        localStorage.setItem('activeProfileUid', currentUser.uid);
        localStorage.setItem('isAuthed', 'true');
      }
      view = 'browse';
      if(!skipPersist){
        await persistProfileRobust(currentProfileFromState(), { force: false, reason: 'system' });
      }
    }
    function buildOwnedMap(ids){
      const map = {};
      (ids||[]).forEach(id=>{ map[id] = true; });
      return map;
    }
    async function saveUserProfileToBackend(profile, { reason = 'system' } = {}) {
      if (!profile) return;
      await awaitAuthReady();
      const safeOwned = resolveSafeOwnedTracks(profile, { reason });
      if(profile.ownedTracks?.length === 0 && safeOwned.length){
        profile = { ...profile, ownedTracks: safeOwned };
      }
      const firebaseUser = firebaseAuth?.currentUser;
      const profileKey = firebaseUser?.uid || profile.uid;
      if(firebaseUser && !firebaseUser.uid){
        throw { code: 'missing_uid', step: 'savingRemote' };
      }
      const setlistItems = profile.setlist || [];
      const serverTimestamp = firebase?.firestore?.FieldValue?.serverTimestamp;
      const usernameLower = normalizeUsernameLower(profile.username || profileKey);
      const djNameLower = normalizeUsernameLower(profile.djName || profile.username || profileKey);
      const searchNameLower = profile.searchNameLower || usernameLower;
      const persona = ensurePersona(profile);
      const { setlists, setlistIds, ownedTracks, ownedMap, ...profileRest } = profile;
      const payload = {
        ...profileRest,
        uid: profileKey,
        username: profile.username || profileKey,
        djName: profile.djName || profile.username || profileKey,
        usernameLower,
        djNameLower,
        searchNameLower,
        searchTokens: Array.isArray(profile.searchTokens) ? profile.searchTokens : buildSearchTokens(usernameLower),
        bio: (profile.bio || '').slice(0, PROFILE_BIO_MAX),
        themeAccent: profile.themeAccent || THEME_ACCENTS[0].id,
        personaId: persona.personaId,
        personaTheme: persona.personaTheme,
        personaSeed: persona.personaSeed,
        isPublic: profile.isPublic !== false,
        allowFriendRequests: profile.allowFriendRequests !== false,
        rulesAccepted: profile.rulesAccepted === true,
        rulesAcceptedAt: profile.rulesAcceptedAt || null,
        email: profile.email || firebaseUser?.email || '',
        setlist: setlistItems,
        schemaVersion: window.profileStore?.PROFILE_SCHEMA_VERSION || 2,
        updatedAt: serverTimestamp ? serverTimestamp() : new Date().toISOString()
      };
      let backendOk = true;
      if (firestore && firebaseUser && profileKey) {
        try {
          const collection = getProfileCollection();
          if(collection){
            await collection.doc(profileKey).set(payload, { merge: true });
          }
        } catch (e) {
          console.error('[SYNC] Firestore save failed', e);
          setSyncError({
            code: e?.code || 'profile_save_failed',
            step: 'savingRemote',
            message: e?.message || 'Sync failed. Retry.'
          });
          backendOk = false;
        }
      }
      return backendOk;
    }
    async function loadUserProfileFromBackend(identifier) {
      if (!identifier && !firebaseAuth?.currentUser) return null;
      await awaitAuthReady();
      const firebaseUser = firebaseAuth?.currentUser;
      const lookupKey = identifier || firebaseUser?.uid;
      const isLikelyUid = typeof lookupKey === 'string' && (lookupKey.startsWith('local:') || lookupKey.length >= 20);
      if (firestore && lookupKey) {
        try {
          const primaryCollection = getProfileCollection();
          const legacyCollection = getLegacyProfileCollection();
          if(primaryCollection && isLikelyUid){
            const doc = await primaryCollection.doc(lookupKey).get();
            if (doc.exists) return normalizeProfileShape(doc.data(), lookupKey);
          }
          if(legacyCollection && isLikelyUid){
            const legacyDoc = await legacyCollection.doc(lookupKey).get();
            if (legacyDoc.exists) return normalizeProfileShape(legacyDoc.data(), lookupKey);
          }
          if(identifier && primaryCollection){
            const query = await primaryCollection.where('usernameLower','==', normalizeUsernameLower(identifier)).limit(1).get();
            const match = query.docs[0];
            if(match?.exists) return normalizeProfileShape({ ...match.data(), uid: match.id }, match.id);
          }
        } catch (e) { console.warn('Firestore load failed', e); }
      }
      const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');
      if (lookupKey && profiles[lookupKey]) return normalizeProfileShape(profiles[lookupKey], lookupKey);
      if (firebaseUser?.uid && profiles[firebaseUser.uid]) return normalizeProfileShape(profiles[firebaseUser.uid], firebaseUser.uid);
      return identifier ? normalizeProfileShape(profiles[identifier], identifier) || null : null;
    }

    function getStreamPlatformInfo(streamUrl){
      if(!streamUrl) return { label: 'Other', icon: 'ðŸŒ' };
      try{
        const host = new URL(streamUrl).hostname.replace('www.','').toLowerCase();
        if(host.includes('twitch')) return { label: 'Twitch', icon: 'ðŸŸ£' };
        if(host.includes('youtube') || host.includes('youtu.be')) return { label: 'YouTube', icon: 'ðŸ”´' };
        if(host.includes('kick')) return { label: 'Kick', icon: 'ðŸŸ¢' };
        if(host.includes('tiktok')) return { label: 'TikTok', icon: 'ðŸŽµ' };
      }catch(_){}
      return { label: 'Other', icon: 'ðŸŒ' };
    }

    function getProfileRatingDisplay(profile){
      const ratingCount = Number(profile?.ratingCount) || 0;
      const avgRating = Number(profile?.avgRating) || 0;
      const roundedStars = Math.round(avgRating);
      const stars = Array.from({ length: 5 }, (_, i)=> i < roundedStars ? 'â˜…' : 'â˜†').join('');
      return { ratingCount, avgRating, stars };
    }

    function renderRatingBreakdownBars(breakdown, ratingCount){
      if(!ratingCount) return '';
      return `<div class="space-y-2">
        ${[5,4,3,2,1].map(star=>{
          const count = breakdown[String(star)] || 0;
          const pct = ratingCount ? Math.round((count / ratingCount) * 100) : 0;
          return `<div class="flex items-center gap-2 text-xs text-gray-300">
            <div class="w-6 text-right">${star}â˜…</div>
            <div class="flex-1 h-2 rounded-full bg-white/10 overflow-hidden">
              <div class="h-full bg-amber-400/80" style="width:${pct}%;"></div>
            </div>
            <div class="w-10 text-right text-gray-400">${count}</div>
          </div>`;
        }).join('')}
      </div>`;
    }

    function getLocalRatings(){
      return JSON.parse(localStorage.getItem('ratings') || '{}');
    }

    function saveLocalRatings(ratings){
      localStorage.setItem('ratings', JSON.stringify(ratings));
    }

    async function getExistingRating(streamerUid, raterUid){
      if(!streamerUid || !raterUid) return null;
      if(firestore){
        await awaitAuthReady();
        try{
          const collection = getProfileCollection();
          if(!collection) return null;
          const doc = await collection.doc(streamerUid).collection('ratings').doc(raterUid).get();
          return doc.exists ? doc.data() : null;
        }catch(err){ console.warn('rating load failed', err); }
      }
      const ratings = getLocalRatings();
      return ratings?.[streamerUid]?.[raterUid] || null;
    }

    function updateAggregatesWithRating(profile, previousStars, nextStars){
      const ratingBreakdown = normalizeRatingBreakdown(profile?.ratingBreakdown);
      let ratingCount = Math.max(0, Number(profile?.ratingCount) || 0);
      if(previousStars){
        const prevKey = String(previousStars);
        ratingBreakdown[prevKey] = Math.max(0, (ratingBreakdown[prevKey] || 0) - 1);
      } else {
        ratingCount += 1;
      }
      const nextKey = String(nextStars);
      ratingBreakdown[nextKey] = (ratingBreakdown[nextKey] || 0) + 1;
      const computed = computeRatingAggregates(ratingBreakdown);
      ratingCount = Math.max(ratingCount, computed.ratingCount);
      return { avgRating: computed.avgRating, ratingCount, ratingBreakdown };
    }

    function checkRatingUpdateLimit(streamerUid, raterUid){
      const now = Date.now();
      const logs = JSON.parse(localStorage.getItem('ratingUpdateLog') || '{}');
      const streamerLog = logs[streamerUid] || {};
      const updates = (streamerLog[raterUid] || []).filter(ts => now - ts < RATING_WINDOW_MS);
      if(updates.length >= RATING_UPDATE_LIMIT){
        const oldest = updates[0];
        return { allowed: false, retryAt: oldest + RATING_WINDOW_MS };
      }
      return { allowed: true, updates, logs };
    }

    function recordRatingUpdate(streamerUid, raterUid, updates, logs){
      const now = Date.now();
      const nextUpdates = [...updates, now];
      const streamerLog = logs[streamerUid] || {};
      streamerLog[raterUid] = nextUpdates;
      logs[streamerUid] = streamerLog;
      localStorage.setItem('ratingUpdateLog', JSON.stringify(logs));
    }

    async function getLiveUsers(){
      if(firestore){
        await awaitAuthReady();
        try{
          const collection = getProfileCollection();
          if(!collection) return [];
          const snap = await collection
            .where('isLive','==',true)
            .orderBy('liveStartedAt','desc')
            .get();
          return snap.docs
            .map(doc=> normalizeProfileShape({ ...doc.data(), uid: doc.id }, doc.id))
            .filter(profile=> isValidStreamUrl(profile.streamUrl));
        }catch(err){
          console.warn('live users query failed', err);
        }
      }
      const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');
      const unique = {};
      Object.values(profiles)
        .map(profile=> normalizeProfileShape(profile, profile?.username || profile?.uid || ''))
        .filter(profile=> profile?.isLive && isValidStreamUrl(profile.streamUrl))
        .forEach(profile=>{
          const key = profile?.username || profile?.uid;
          if(key && !unique[key]) unique[key] = profile;
        });
      return Object.values(unique)
        .sort((a,b)=> new Date(b.liveStartedAt || 0) - new Date(a.liveStartedAt || 0));
    }

    // ---------------------------- Data ------------------------------
    const camelotColors = {
      '1A':'#FF6B9D','1B':'#FF8FAB','2A':'#FFA07A','2B':'#FFB699','3A':'#FFD700','3B':'#FFE55C',
      '4A':'#98D8C8','4B':'#7FD8BE','5A':'#6BCB77','5B':'#8FD89F','6A':'#4D96FF','6B':'#6FB1FF',
      '7A':'#9D4EDD','7B':'#B877FF','8A':'#E84A5F','8B':'#FF6B81','9A':'#00D9FF','9B':'#4DFFFF',
      '10A':'#FFA400','10B':'#FFBB5C','11A':'#FE6D73','11B':'#FF8C94','12A':'#A8E6CF','12B':'#C1F0DD'
    };
    const knownCorrections = [
      { id: 'dont_fear_the_reaper', expectedCamelot: '8A' },
    ];
    const keyToCamelot = { 'C':'8B','Am':'8A','A Minor':'8A','C Major':'8B','G':'9B','Em':'9A','E Minor':'9A','G Major':'9B','D':'10B','Bm':'10A','B Minor':'10A','D Major':'10B','A':'11B','F#m':'11A','F# Minor':'11A','A Major':'11B','E':'12B','C#m':'12A','C# Minor':'12A','E Major':'12B','B':'1B','G#m':'1A','G# Minor':'1A','B Major':'1B','F#':'2B','D#m':'2A','D# Minor':'2A','F# Major':'2B','Db':'3B','Bbm':'3A','Bb Minor':'3A','Db Major':'3B','Ab':'4B','Fm':'4A','F Minor':'4A','Ab Major':'4B','Eb':'5B','Cm':'5A','C Minor':'5A','Eb Major':'5B','Bb':'6B','Gm':'6A','G Minor':'6A','Bb Major':'6B','F':'7B','Dm':'7A','D Minor':'7A','F Major':'7B' };

    const genreMap = {
      'Rock': ['foo fighters','nirvana','pearl jam','soundgarden','alice in chains','red hot chili peppers','radiohead','muse','queens of the stone age','rage against the machine'],
      'Classic Rock': ['beatles','rolling stones','led zeppelin','pink floyd','queen','the who','aerosmith'],
      'Alternative': ['green day','blink-182','sum 41','my chemical romance','fall out boy','arctic monkeys','the strokes','the killers'],
      'Punk': ['ramones','sex pistols','the clash'],
      'Metal': ['metallica','megadeth','slayer','anthrax','iron maiden'],
      'Pop': ['taylor swift','ariana grande','billie eilish','dua lipa','lady gaga','katy perry'],
      'Hip-Hop': ['eminem','dr. dre','snoop dogg','2pac','notorious b.i.g','jay-z','nas','kanye west','kendrick lamar','drake'],
      'R&B': ['the weeknd','bruno mars','usher','beyonce','rihanna'],
      'Electronic': ['daft punk','deadmau5','skrillex','diplo','zedd','avicii','calvin harris'],
      'Indie': ['vampire weekend','tame impala','mgmt','arctic monkeys','the strokes'],
      'Country': ['johnny cash','garth brooks','shania twain','tim mcgraw'],
      'Disco/Funk': ['bee gees','donna summer','chic','earth wind & fire','bruno mars'],
      'Blues': ['bb king','muddy waters','howlin wolf'],
      'Jazz': ['miles davis','john coltrane'],
      'Reggae': ['bob marley'],
      'Latin': ['shakira','ricky martin','enrique iglesias'],
      'Soul': ['aretha franklin','otis redding','sam cooke']
    };

    // -------------------------- State -----------------------------
    let currentUser = null;
    let songsLoaded = false;
    let userKey = null;
    let localDeviceId = localStorage.getItem('localDeviceId') || null;
    let songs = [];
    let songsById = {};
    let draftProfile = null;
    let ownedTracks = [];
    let activeSessionKey = null;
    let ownedLibraryState = { phase: 'idle', source: 'none', message: '' };
    let ownedStore = null;
    let logoutInProgress = false;
    let selectedSong = null;
    let sortMode = 'bpm';
    let previewSong = null;
    let setlist = [];
    let searchTerm = '';
    let showOwnedOnly = false;
    let showMixableOnly = false;
    let selectedGenre = 'All';
    let bandMembers = [];
    let viewingProfile = null;
    let friendSearchTerm = '';
    let socialFriendSearchTerm = '';
    let socialFriendSearchDebounce = null;
    let socialFriendSearchResults = [];
    let socialFriendSearchLoading = false;
    let socialFriendSearchError = '';
    let socialFriendSearchNotice = '';
    let socialFriendSearchNoticeTone = 'info';
    let socialFriendSearchQuery = '';
    let friendRequestsIncoming = [];
    let friendRequestsOutgoing = [];
    let friendsList = [];
    let friendsLoading = false;
    let friendsLoadedAt = 0;
    let friendsError = '';
    let friendLookupError = '';
    let friendLookupResults = [];
    let liveNowUsers = [];
    let liveNowLoading = false;
    let liveNowLoadedAt = 0;
    let liveNowError = '';
    let ratingDraft = { stars: 0, tags: [], comment: '', hasExisting: false };
    let ratingLoadedFor = '';
    let ratingLoading = false;
    let ratingSubmitting = false;
    let ratingStatusMessage = '';
    let ratingStatusTone = 'info';
    let genreOverrides = {};
    let sandboxTracks = [];
    let sandboxIds = [];
    let helpTab = 'basic';
    let helpScroll = { basic: 0, advanced: 0 };
    let helpOpenedAt = null;
    let helpOpenTarget = 'none';
    let helpOpenSource = 'other';
    let helpTabTracked = false;
    const profileUiState = {
      isEditMode: true,
      isSaving: false,
      lastError: null
    };
    let profileHandlersBound = false;
    let debugUiBound = false;
    let headerMoreOpen = false;
    let isLowPowerMode = false;
    let isSearchFocused = false;
    let searchDebounceTimer = null;
    let searchDebouncePending = false;
    let trackLoadState = { status: 'idle', loaded: 0, total: 0, message: '' };
    let trackLoadNotice = '';
    let loadSongsStartTime = 0;
    let firstListRenderLogged = false;
    let maxMobileCardsRendered = 0;
    let maxCardsLogged = false;
    let listRenderCount = 0;
    let songListRenderScheduled = false;
    let songListRenderReason = '';
    let selectedSongCriteria = null;
    let lastFilteredCount = 0;
    let mobileListObserver = null;
    let mixableInlineNotice = '';
    let mixableInlineTimer = null;
    let matchHintMessage = '';
    let quickStartState = { open: false, step: 0, preset: null };
    let stickyCtaDismissed = localStorage.getItem('jamMixer.stickyCtaDismissed') === 'true';
    let quickStartDone = localStorage.getItem('jamMixer.quickStartDone') === 'true';
    let quickStartPrompted = false;
    let quickStartDelegatesBound = false;
    let justEnteredProfile = false;
    let mobileWindowState = { start: 0, count: 40 };
    const TOUR_VERSION = 1;
    const TOUR_STORAGE_KEY = 'tour_done_v1';
    const TOUR_STEPS = [
      { id: 'browse', selector: '#searchInput', title: 'Browse Tracks', copy: 'Scroll or search to find songs you want to mix.', route: 'browse', routeLabel: 'Go to Browse' },
      { id: 'setlist', selector: '#setlistBtn', title: 'Build Your Setlist', copy: 'Tap a track to add it, then open Setlist to review your picks.', route: 'browse' },
      { id: 'profile', selector: '#profileBtn', title: 'Profile Overview', copy: 'Check your owned count and bandmates from Profile.', route: 'profile', routeLabel: 'Go to Profile' }
    ];
    const tourState = {
      isOpen: false,
      stepIndex: 0,
      steps: TOUR_STEPS,
      source: 'auto',
      lastFocused: null
    };
    const PAGE_SIZE_OPTIONS = [12,24,48,96];
    const PAGE_SIZE_KEY = 'jamMixer.pageSize';
    const CURRENT_PAGE_KEY = 'jamMixer.currentPage';
    const DEFAULT_PAGE_SIZE = 24;
    const MOBILE_PAGE_CHUNK = 40;
    const MOBILE_MAX_CARDS = 80;
    const MOBILE_BREAKPOINT = 768;
    const reducedMotionQuery = window.matchMedia ? window.matchMedia('(prefers-reduced-motion: reduce)') : null;
    const mobileViewportQuery = window.matchMedia ? window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`) : null;
    let friendPanelTab = 'friends';
    let mainPager = null;
    let priorityStrength = 'medium';
    const SYNC_STATES = Object.freeze({
      idle: 'idle',
      checkingAuth: 'checkingAuth',
      loadingRemote: 'loadingRemote',
      merging: 'merging',
      savingRemote: 'savingRemote',
      synced: 'synced',
      error: 'error'
    });
    const APP_BOOT_STATES = Object.freeze({
      bootLoading: 'BOOT_LOADING',
      signedOut: 'SIGNED_OUT',
      signedInLoading: 'SIGNED_IN_LOADING',
      ready: 'READY',
      fatal: 'FATAL_ERROR'
    });
    let appBootState = bootState;
    let bootstrapFatalError = null;
    const SYNC_TIMEOUT_MS = 6000;
    const BOOT_DEADLINE_MS = 8000;
    const BOOT_CALL_TIMEOUT_MS = 6000;
    const PROFILE_SAVE_DEBOUNCE_MS = 400;
    let syncState = {
      state: SYNC_STATES.idle,
      message: '',
      errorCode: null,
      errorStep: null,
      lastSyncedAt: null,
      lastSyncHash: null,
      updatedAt: null
    };
    let profileSaveTimeout = null;
    let pendingProfileSave = null;
    let pendingProfileSavePromise = null;
    let authReadyResolve = null;
    const authReadyPromise = new Promise((resolve) => {
      authReadyResolve = resolve;
    });
    let keyMatchMode = (localStorage.getItem('jamMixer.keyMatchMode') || 'camelot') === 'semitone' ? 'semitone' : 'camelot';
    let maxSemitoneRange = Math.min(6, Math.max(1, parseInt(localStorage.getItem('jamMixer.maxSemitoneRange') || '6', 10) || 6));
    let includeOppositeMode = localStorage.getItem('jamMixer.includeOppositeMode');
    includeOppositeMode = includeOppositeMode === null ? true : includeOppositeMode === 'true';
    function applyPreferencesFromProfile(profile){
      const prefs = profile?.preferences || {};
      if(prefs.keyMatchMode){ keyMatchMode = prefs.keyMatchMode === 'semitone' ? 'semitone' : 'camelot'; }
      if(Number.isFinite(prefs.maxSemitoneRange)){ maxSemitoneRange = Math.min(6, Math.max(1, Number(prefs.maxSemitoneRange))); }
      if(typeof prefs.includeOppositeMode === 'boolean'){ includeOppositeMode = prefs.includeOppositeMode; }
      if(['low','medium','high'].includes(prefs.priorityStrength)){ priorityStrength = prefs.priorityStrength; }
      const wasPersisting = profileUiState.isSaving;
      profileUiState.isSaving = true;
      persistKeyMatchSettings();
      profileUiState.isSaving = wasPersisting;
    }
    function syncPreferencesIntoProfile(){
      if(!currentUser) return;
      const prefs = { keyMatchMode, maxSemitoneRange, includeOppositeMode, priorityStrength };
      currentUser.preferences = prefs;
      if(draftProfile) draftProfile.preferences = prefs;
    }
    function updateSyncState(next){
      syncState = { ...syncState, ...next, updatedAt: Date.now() };
      console.debug('[sync]', syncState.state, { step: syncState.errorStep, code: syncState.errorCode, message: syncState.message });
      render();
      setupEventListeners();
    }
    function setSyncError({ code = 'sync_error', step = null, message = 'Sync failed. Retry.' } = {}){
      console.error('[SYNC]', { code, step, message });
      updateSyncState({
        state: SYNC_STATES.error,
        message,
        errorCode: code,
        errorStep: step
      });
    }
    function setSyncedState(message = 'Synced âœ…'){
      updateSyncState({
        state: SYNC_STATES.synced,
        message,
        errorCode: null,
        errorStep: null
      });
    }
    function withTimeout(promise, timeoutMs, step){
      let timer;
      const timeoutPromise = new Promise((_, reject)=>{
        timer = setTimeout(() => reject({ code: 'timeout', step, message: `${step || 'Operation'} timed out` }), timeoutMs);
      });
      return Promise.race([promise, timeoutPromise]).finally(() => clearTimeout(timer));
    }
    function withSyncTimeout(promise, { step, timeoutMs = SYNC_TIMEOUT_MS } = {}){
      return withTimeout(promise, timeoutMs, step);
    }
    async function awaitAuthReady(){
      if(!firebaseEnabled) return null;
      return authReadyPromise;
    }
    let preferenceSaveTimeout = null;
    function schedulePreferencePersist(){
      if(!currentUser) return;
      clearTimeout(preferenceSaveTimeout);
      preferenceSaveTimeout = setTimeout(()=>{
        if(!currentUser) return;
        persistCurrentUserProfile().catch(err=>console.warn('[profile] preference persistence failed', err));
      }, 300);
    }
    let camelotOverridesStore = { ids: {}, names: {} };
    let bpmOverridesStore = { ids: {}, names: {} };
    let auditSearch = '';
    let auditFilters = { flaggedOnly:false, overriddenOnly:false, invalidCamelot:false, modeMismatch:false, bpmOutlier:false };
    let regressionWarnings = [];
    let adminMenuOpen = false;
    let adminMenuListenersBound = false;
    let isOffline = !navigator.onLine;
    let trackSource = 'network';
    const boot = {
      phase: 'init',
      profileLoaded: false,
      songsLoaded: false,
      usedFallbackSongs: false,
      usedSnapshotProfile: false,
      initialOwnedCount: 0,
      errors: [],
      logs: window.__BOOT__?.steps ? window.__BOOT__.steps.slice() : [],
      lastError: window.__BOOT__?.lastError || null,
      startedAt: window.__BOOT__?.startedAt || Date.now()
    };
    const BOOT_LOG_LIMIT = 50;
    function recordBootStep(step){
      const entry = pushBootStep(step);
      boot.logs.push(entry);
      if(boot.logs.length > BOOT_LOG_LIMIT){
        boot.logs.shift();
      }
      window.__BOOT_LOGS__ = boot.logs;
      if(!window.__BOOT__){
        window.__BOOT__ = { steps: [], lastError: null, startedAt: boot.startedAt };
      }
      window.__BOOT__.steps = boot.logs.slice();
      return entry;
    }
    function recordBootError(error){
      const message = error?.message || String(error || 'Unknown error');
      boot.errors.push(message);
      boot.lastError = message;
      window.__BOOT_LAST_ERROR__ = message;
      if(!window.__BOOT__){
        window.__BOOT__ = { steps: boot.logs.slice(), lastError: message, startedAt: boot.startedAt };
      } else {
        window.__BOOT__.lastError = message;
      }
      try{
        localStorage.setItem('ffjm:lastBootError', message);
      }catch(e){
        // ignore storage failures
      }
      return message;
    }
    let profileSyncOutcome = { cloudMissing: false, syncError: false, migrationApplied: false };
    let writeFenceBlockedSave = false;
    let userInitiatedClear = false;
    let recoveryBannerState = { visible: false, message: '' };
    const FEATURE_SIGNIN_STATS = false;
    const communityStats = { totalDjs: 'â€¦' };
    const communityStatGraceTimers = {};
    const COMMUNITY_STAT_GRACE_MS = 3000;
    const COMMUNITY_TOTAL_DJS_CACHE_KEY = 'ffmCommunityTotalDjs';
    const SAMPLE_TRACKS = [
      { id:'s1', title:'Bad Guy', artist:'Billie Eilish', bpm:135, rawBpm:135, key:'C major', rawKey:'C', rawMode:'major', mode:'major', camelot:'8B', derivedCamelot:'8B', duration:180, albumArt:'', genre:'Pop'},
      { id:'s2', title:'Need You Tonight', artist:'INXS', bpm:115, rawBpm:115, key:'C minor', rawKey:'C', rawMode:'minor', mode:'minor', camelot:'8A', derivedCamelot:'8A', duration:210, albumArt:'', genre:'Rock'},
      { id:'s3', title:'Electric Night', artist:'Daft Sample', bpm:128, rawBpm:128, key:'D major', rawKey:'D', rawMode:'major', mode:'major', camelot:'10B', derivedCamelot:'10B', duration:200, albumArt:'', genre:'Electronic'},
      { id:'s4', title:'Slow Burn', artist:'Indie Star', bpm:95, rawBpm:95, key:'G minor', rawKey:'G', rawMode:'minor', mode:'minor', camelot:'9A', derivedCamelot:'9A', duration:190, albumArt:'', genre:'Indie'},
      { id:'s5', title:'Drop The Bass', artist:'SkrillSample', bpm:142, rawBpm:142, key:'A minor', rawKey:'A', rawMode:'minor', mode:'minor', camelot:'11A', derivedCamelot:'11A', duration:160, albumArt:'', genre:'Electronic'}
    ].map(t=>({ ...t, flags: computeTrackFlags ? computeTrackFlags(t) : {} }));
    const usernamePattern = /^[A-Za-z0-9_]{3,20}$/;
    const profileParam = new URLSearchParams(window.location.search).get('profile');
    const viewParam = new URLSearchParams(window.location.search).get('view');
    const showSyncDebugPanel = new URLSearchParams(window.location.search).get('debug') === '1';
    const pendingOAuthToast = sessionStorage.getItem('oauthSuccess');
    if(pendingOAuthToast){ sessionStorage.removeItem('oauthSuccess'); setTimeout(()=>alert(pendingOAuthToast), 500); }

    // ---------------------- Admin & identity helpers -----------------------
    function ensureLocalDeviceId(){
      if(!localDeviceId){
        localDeviceId = 'device_' + Math.random().toString(36).slice(2,10);
        localStorage.setItem('localDeviceId', localDeviceId);
      }
      return localDeviceId;
    }
    function computeUserKey(){
      const firebaseUser = firebaseAuth?.currentUser;
      if(firebaseUser?.uid) return firebaseUser.uid;
      if(currentUser?.uid) return currentUser.uid;
      return ensureLocalDeviceId();
    }
    function getNamespacedKey(base){
      const key = computeUserKey();
      userKey = key;
      return `${base}_${key}`;
    }
    const PROFILE_MIGRATION_KEY = 'ffjm_migrated_uid';
    const PROFILE_SNAPSHOT_PREFIX = 'lastKnownGoodProfile:';
    function hasCompletedProfileMigration(uid){
      return uid ? localStorage.getItem(PROFILE_MIGRATION_KEY) === uid : false;
    }
    function readLegacyLocalProfile(){
      const legacyOwned = JSON.parse(localStorage.getItem('ownedTracks') || '[]');
      const legacySetlist = JSON.parse(localStorage.getItem('setlist') || '[]');
      const legacySetlistIds = JSON.parse(localStorage.getItem('setlistIds') || '[]');
      const legacyGenre = JSON.parse(localStorage.getItem('genreOverrides') || '{}');
      const setlistSource = legacySetlistIds.length ? legacySetlistIds : legacySetlist;
      return {
        ownedTracks: normalizeOwnedList(legacyOwned),
        setlist: normalizeSetlistIds(setlistSource),
        genreOverrides: legacyGenre
      };
    }
    function getUserStorageId(profile){
      const uid = firebaseAuth?.currentUser?.uid || profile?.uid || currentUser?.uid;
      if(uid) return uid;
      const username = profile?.username || currentUser?.username;
      const fallback = getSavedUsername();
      return username || fallback || null;
    }
    function getUserStorageKey(base, profile){
      const id = getUserStorageId(profile);
      return id ? `${base}:${id}` : null;
    }
    function readUserStorageJson(base, profile, fallback){
      const key = getUserStorageKey(base, profile);
      if(!key) return fallback;
      try{
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : fallback;
      }catch(err){
        console.warn('[storage] read failed', err);
        return fallback;
      }
    }
    function writeUserStorageJson(base, profile, value){
      const key = getUserStorageKey(base, profile);
      if(!key) return;
      localStorage.setItem(key, JSON.stringify(value));
    }
    function shouldUseLegacyStorage(profile){
      if(!firebaseEnabled) return true;
      if(firebaseAuth?.currentUser?.uid) return false;
      return profile?.mode === 'local';
    }
    function readProfileCache(uid){
      if(uid && window.profileStore?.readProfileCache) return window.profileStore.readProfileCache(uid);
      return window.profileStore?.readLocalProfileCache?.() || {};
    }
    function writeProfileCache(uid, profile){
      if(uid && window.profileStore?.writeProfileCache) return window.profileStore.writeProfileCache(uid, profile);
      if(window.profileStore?.writeLocalProfileCache) window.profileStore.writeLocalProfileCache(profile);
    }
    function shouldAllowEmptyOwnedWrite(reason){
      return reason === 'clearAll';
    }
    function resolveSafeOwnedTracks(profile, { reason = 'system' } = {}){
      const incoming = normalizeOwnedList(profile?.ownedTracks || []);
      if(incoming.length || shouldAllowEmptyOwnedWrite(reason)) return incoming;
      if(shouldUseLegacyStorage(profile)){
        const storedLocal = normalizeOwnedList(readUserStorageJson('ownedTracks', profile, []));
        if(storedLocal.length) return storedLocal;
      }
      const cachedOwned = profile?.uid ? readOwnedTracksCache(profile.uid) : null;
      if(cachedOwned?.trackIds?.length) return normalizeOwnedList(cachedOwned.trackIds);
      return incoming;
    }
    function shallowEqual(a = {}, b = {}){
      const aKeys = Object.keys(a);
      const bKeys = Object.keys(b);
      if(aKeys.length !== bKeys.length) return false;
      return aKeys.every(key => a[key] === b[key]);
    }
    function arraysEqual(a = [], b = []){
      if(a.length !== b.length) return false;
      return a.every((val, idx) => val === b[idx]);
    }
    async function persistUserSession(profile, { reason = 'system', skipBackend = false } = {}){
      if(!profile) return;
      const safeOwned = resolveSafeOwnedTracks(profile, { reason });
      const safeSetlist = normalizeSetlistIds(profile.setlist || profile.setlistIds || profile.setlists || []);
      const safeGenre = profile.genreOverrides && typeof profile.genreOverrides === 'object' ? profile.genreOverrides : {};
      const uid = firebaseAuth?.currentUser?.uid || profile?.uid || null;
      if(uid && firebaseAuth?.currentUser){
        writeProfileCache(uid, {
          uid,
          email: profile.email || '',
          djName: profile.djName || profile.username || '',
          streamUrl: profile.streamUrl || '',
          isLive: profile.isLive === true,
          liveStartedAt: profile.liveStartedAt || profile.liveSince || null,
          setlist: safeSetlist,
          genreOverrides: safeGenre,
          bandMembers: profile.bandMembers || []
        });
        window.profileStore?.writeOwnedTracksCache?.(uid, {
          trackIds: safeOwned,
          updatedAt: new Date().toISOString(),
          schemaVersion: window.profileStore?.OWNED_LIBRARY_SCHEMA_VERSION || 1
        });
      } else {
        writeUserStorageJson('ownedTracks', profile, safeOwned);
        writeUserStorageJson('setlist', profile, safeSetlist);
        writeUserStorageJson('genreOverrides', profile, safeGenre);
      }
      if(!skipBackend){
        await saveUserProfileToBackend({ ...profile, ownedTracks: safeOwned, setlist: safeSetlist, genreOverrides: safeGenre }, { reason });
      }
    }
    async function hydrateUserSession(profile){
      if(!profile) return profile;
      const sessionId = getUserStorageId(profile);
      if(!sessionId) return profile;
      const uid = firebaseAuth?.currentUser?.uid || profile.uid || null;
      const localCache = uid ? readProfileCache(uid) : null;
      const localOwned = uid
        ? normalizeOwnedList(readOwnedTracksCache(uid)?.trackIds || [])
        : normalizeOwnedList(readUserStorageJson('ownedTracks', profile, []));
      const localSetlist = uid
        ? normalizeSetlistIds(localCache?.setlist || [])
        : normalizeSetlistIds(readUserStorageJson('setlist', profile, []));
      const localGenre = uid ? (localCache?.genreOverrides || {}) : readUserStorageJson('genreOverrides', profile, {});
      const backendOwned = normalizeOwnedList(profile.ownedTracks || []);
      const backendSetlist = normalizeSetlistIds(profile.setlist || profile.setlistIds || profile.setlists || []);
      const backendGenre = profile.genreOverrides && typeof profile.genreOverrides === 'object' ? profile.genreOverrides : {};

      let mergedOwned = backendOwned;
      let shouldWriteBackend = false;
      if(!backendOwned.length && localOwned.length){
        mergedOwned = localOwned;
        shouldWriteBackend = true;
      } else if(backendOwned.length && localOwned.length){
        mergedOwned = normalizeOwnedList([...backendOwned, ...localOwned]);
        if(!arraysEqual(mergedOwned, backendOwned)) shouldWriteBackend = true;
      }

      let mergedSetlist = backendSetlist;
      if(!backendSetlist.length && localSetlist.length){
        mergedSetlist = localSetlist;
        shouldWriteBackend = true;
      } else if(backendSetlist.length && localSetlist.length){
        mergedSetlist = normalizeSetlistIds([...backendSetlist, ...localSetlist]);
        if(!arraysEqual(mergedSetlist, backendSetlist)) shouldWriteBackend = true;
      }

      let mergedGenre = backendGenre;
      const hasLocalGenre = Object.keys(localGenre || {}).length > 0;
      const hasBackendGenre = Object.keys(backendGenre || {}).length > 0;
      if(!hasBackendGenre && hasLocalGenre){
        mergedGenre = localGenre;
        shouldWriteBackend = true;
      } else if(hasBackendGenre && hasLocalGenre){
        mergedGenre = { ...backendGenre, ...localGenre };
        if(!shallowEqual(mergedGenre, backendGenre)) shouldWriteBackend = true;
      }

      const mergedProfile = migrateProfile({
        ...profile,
        ownedTracks: mergedOwned,
        setlist: mergedSetlist,
        genreOverrides: mergedGenre,
        bandMembers: profile.bandMembers || []
      });

      ownedTracks = mergedOwned;
      setlist = mergedSetlist;
      genreOverrides = mergedGenre;
      bandMembers = mergedProfile.bandMembers || [];

      await persistUserSession(mergedProfile, { reason: 'system', skipBackend: !shouldWriteBackend });
      return mergedProfile;
    }
    function loadSandboxState(){
      sandboxIds = JSON.parse(localStorage.getItem(getNamespacedKey('sandboxTrackIds')) || '[]');
    }
    function persistProfileCache(){
      const uid = firebaseAuth?.currentUser?.uid || currentUser?.uid || ensureLocalDeviceId();
      writeProfileCache(uid, {
        uid,
        email: currentUser?.email || '',
        djName: currentUser?.djName || currentUser?.username || '',
        streamUrl: currentUser?.streamUrl || '',
        isLive: currentUser?.isLive === true,
        liveStartedAt: currentUser?.liveStartedAt || currentUser?.liveSince || null,
        setlist,
        genreOverrides,
        bandMembers
      });
    }
    function syncProfileCache(){
      if(currentUser){
        currentUser.setlist = setlist;
        currentUser.genreOverrides = genreOverrides;
        currentUser.bandMembers = bandMembers;
      }
      if(draftProfile){
        draftProfile.setlist = setlist;
        draftProfile.genreOverrides = genreOverrides;
        draftProfile.bandMembers = bandMembers;
      }
      persistProfileCache();
      if(currentUser){
        persistUserSession(currentProfileFromState(), { reason: 'system', skipBackend: true }).catch(()=>{});
      }
    }
    async function runProfileCloudSave(reason = 'system'){
      const uid = firebaseAuth?.currentUser?.uid;
      if(!uid){
        throw { code: 'missing_uid', step: 'checkingAuth' };
      }
      await awaitAuthReady();
      if(!firebaseEnabled || !firestore || !navigator.onLine){
        throw { code: 'offline', step: 'savingRemote' };
      }
      updateSyncState({ state: SYNC_STATES.savingRemote, message: 'Saving to cloudâ€¦', errorCode: null, errorStep: null });
      const payload = {
        uid,
        email: firebaseAuth?.currentUser?.email || currentUser?.email || '',
        djName: currentUser?.djName || currentUser?.username || '',
        streamUrl: currentUser?.streamUrl || '',
        isLive: currentUser?.isLive === true,
        liveStartedAt: currentUser?.liveStartedAt || currentUser?.liveSince || null,
        setlist,
        genreOverrides,
        bandMembers
      };
      await withSyncTimeout(window.profileStore.writeCloudProfile(uid, payload), { step: 'savingRemote' });
      setSyncedState('Synced âœ…');
      const lastSyncAt = Date.now();
      updateSyncState({ lastSyncedAt: lastSyncAt });
      return { ok: true };
    }
    function flushPendingProfileSave(){
      if(!pendingProfileSave) return;
      const pending = pendingProfileSave;
      pendingProfileSave = null;
      pendingProfileSavePromise = null;
      pendingProfileSave.resolve();
    }
    function queueSaveProfile({ reason = 'system', flush = false } = {}){
      syncProfileCache();
      if(!firebaseEnabled || !firebaseAuth?.currentUser){
        updateSyncState({ state: SYNC_STATES.idle, message: 'Sync paused', errorCode: null, errorStep: null });
        return Promise.resolve({ skipped: true });
      }
      if(!navigator.onLine && !flush){
        updateSyncState({ state: SYNC_STATES.idle, message: 'Offline â€” sync paused', errorCode: null, errorStep: null });
        return Promise.resolve({ skipped: true, offline: true });
      }
      if(!pendingProfileSavePromise){
        pendingProfileSavePromise = new Promise((resolve, reject)=>{
          pendingProfileSave = { resolve, reject };
        });
      }
      if(flush){
        clearTimeout(profileSaveTimeout);
        runProfileCloudSave(reason)
          .then((result)=>{
            flushPendingProfileSave();
            return result;
          })
          .catch((err)=>{
            pendingProfileSave?.reject?.(err);
            pendingProfileSave = null;
            pendingProfileSavePromise = null;
          });
        return pendingProfileSavePromise;
      }
      clearTimeout(profileSaveTimeout);
      profileSaveTimeout = setTimeout(() => {
        runProfileCloudSave(reason)
          .then(() => flushPendingProfileSave())
          .catch((err) => {
            console.warn('[profile] cloud sync failed', err);
            setSyncError({
              code: err?.code || 'profile_save_failed',
              step: err?.step || 'savingRemote',
              message: err?.message || (err?.code === 'offline' ? 'Offline â€” sync paused' : 'Sync failed. Retry.')
            });
            pendingProfileSave?.reject?.(err);
            pendingProfileSave = null;
            pendingProfileSavePromise = null;
          });
      }, PROFILE_SAVE_DEBOUNCE_MS);
      return pendingProfileSavePromise;
    }
    function scheduleProfileCacheSync(){
      queueSaveProfile({ reason: 'system' }).catch(()=>{});
    }
    function buildSyncDebugPayload(){
      const user = firebaseAuth?.currentUser;
      const uid = user?.uid || currentUser?.uid || null;
      const store = ensureOwnedLibraryStore();
      const provider = user?.providerData?.map(item => item?.providerId).filter(Boolean).join(', ') || 'â€”';
      const lastSyncedAt = uid ? window.profileStore?.readLastSyncAt?.(uid) : null;
      const lastSyncHash = uid ? window.profileStore?.readLastSyncHash?.(uid) : null;
      return {
        uid,
        provider,
        signedIn: !!user,
        firebaseReady: firebaseEnabled && !!firestore,
        online: navigator.onLine,
        syncState: syncState.state,
        syncMessage: syncState.message,
        lastSyncedAt,
        lastSyncHash,
        errorCode: syncState.errorCode,
        errorStep: syncState.errorStep,
        pendingOwnedOps: store?.hasUnsavedChanges?.() ? 1 : 0,
        lastErrorMessage: syncState.message
      };
    }
    function downloadJsonPayload(payload, filename){
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    }
    function exportOwnedBackupJson(){
      const uid = firebaseAuth?.currentUser?.uid || currentUser?.uid;
      const snapshot = uid
        ? window.profileStore?.readOwnedTracksBackup?.(uid)
        : null;
      const ownedSnapshot = snapshot || ensureOwnedLibraryStore()?.getSnapshot?.() || { trackIds: ownedTracks || [], count: (ownedTracks || []).length };
      const payload = {
        exportedAt: new Date().toISOString(),
        uid,
        ownedTracks: ownedSnapshot.trackIds || [],
        count: ownedSnapshot.count || (ownedSnapshot.trackIds || []).length,
        lastSyncedAt: uid ? window.profileStore?.readLastSyncAt?.(uid) : null,
        lastSyncHash: uid ? window.profileStore?.readLastSyncHash?.(uid) : null
      };
      downloadJsonPayload(payload, buildExportFilename(currentUser?.username || currentUser?.djName || 'owned-backup'));
    }
    function retryCloudSync(){
      if(syncState.state === SYNC_STATES.savingRemote) return;
      updateSyncState({ state: SYNC_STATES.loadingRemote, message: 'Retrying syncâ€¦', errorCode: null, errorStep: null });
      queueSaveProfile({ reason: 'retry', flush: true }).catch(()=>{});
      const store = ensureOwnedLibraryStore();
      if(store){
        store.flush('retry').catch(()=>{});
      }
    }
    function showSyncFailureModal(){
      return new Promise((resolve)=>{
        const modal = document.createElement('div');
        modal.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:40000;backdrop-filter:blur(6px);padding:12px;';
        modal.innerHTML = `
          <div class="w-full max-w-md bg-gradient-to-b from-black/85 to-black/90 border border-amber-500/40 rounded-2xl p-6 text-white shadow-2xl">
            <h3 class="text-xl font-bold mb-2">Sync failed</h3>
            <p class="text-sm text-gray-200 mb-4">Cloud Sync didnâ€™t finish. Retry now or download a backup JSON before signing out.</p>
            <div class="flex gap-2 justify-end">
              <button data-action="download" class="px-4 py-2 rounded-lg bg-white/10 border border-white/20">Download backup</button>
              <button data-action="retry" class="px-4 py-2 rounded-lg bg-gradient-to-r from-amber-500 to-orange-500 text-white font-bold">Retry sync</button>
            </div>
          </div>`;
        document.body.appendChild(modal);
        const cleanup = () => { modal.remove(); };
        modal.addEventListener('click', (event)=>{
          const target = event.target;
          if(target === modal){ cleanup(); resolve('cancel'); return; }
          const action = target?.dataset?.action;
          if(!action) return;
          cleanup();
          resolve(action);
        });
      });
    }
    function showOwnedLogoutModal(error){
      return new Promise((resolve)=>{
        const message = error?.message || 'Owned tracks did not finish saving.';
        const modal = document.createElement('div');
        modal.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:40000;backdrop-filter:blur(6px);padding:12px;';
        modal.innerHTML = `
          <div class="w-full max-w-md bg-gradient-to-b from-black/85 to-black/90 border border-amber-500/40 rounded-2xl p-6 text-white shadow-2xl">
            <h3 class="text-xl font-bold mb-2">Finish saving owned tracks?</h3>
            <p class="text-sm text-gray-200 mb-4">${message}</p>
            <div class="flex gap-2 justify-end">
              <button data-action="cancel" class="px-4 py-2 rounded-lg bg-white/10 border border-white/20">Cancel logout</button>
              <button data-action="download" class="px-4 py-2 rounded-lg bg-white/10 border border-white/20">Export backup JSON</button>
              <button data-action="retry" class="px-4 py-2 rounded-lg bg-gradient-to-r from-amber-500 to-orange-500 text-white font-bold">Retry save</button>
            </div>
          </div>`;
        document.body.appendChild(modal);
        const cleanup = () => { modal.remove(); };
        modal.addEventListener('click', (event)=>{
          const target = event.target;
          if(target === modal){ cleanup(); resolve('cancel'); return; }
          const action = target?.dataset?.action;
          if(!action) return;
          cleanup();
          resolve(action);
        });
      });
    }
    function createPaginationState({ pageIndex = 0, pageSize = DEFAULT_PAGE_SIZE } = {}){
      return { pageIndex, pageSize, pageSizeOptions: PAGE_SIZE_OPTIONS };
    }
    function loadPaginationPreferences(pager){
      if(!pager) return;
      const storedSize = parseInt(localStorage.getItem(PAGE_SIZE_KEY) || '', 10);
      if(PAGE_SIZE_OPTIONS.includes(storedSize)) pager.pageSize = storedSize;
      const storedPage = parseInt(sessionStorage.getItem(CURRENT_PAGE_KEY) || '', 10);
      if(Number.isFinite(storedPage)){
        pager.pageIndex = storedPage > 0 ? storedPage - 1 : 0;
      }
    }
    function persistPageSizePreference(pager){
      if(!pager) return;
      localStorage.setItem(PAGE_SIZE_KEY, String(pager.pageSize));
    }
    function persistMainPagerState(){
      if(!mainPager) return;
      persistPageSizePreference(mainPager);
      sessionStorage.setItem(CURRENT_PAGE_KEY, String(mainPager.pageIndex + 1));
    }
    function paginate(list, pageIndex, pageSize){
      const totalItems = list.length;
      const totalPages = totalItems ? Math.ceil(totalItems / pageSize) : 0;
      const safePageIndex = totalPages ? Math.min(Math.max(pageIndex, 0), totalPages - 1) : 0;
      const startIndex = safePageIndex * pageSize;
      const pageItems = totalItems ? list.slice(startIndex, startIndex + pageSize) : [];
      const from = totalItems ? startIndex + 1 : 0;
      const to = totalItems ? Math.min(totalItems, startIndex + pageItems.length) : 0;
      return { pageItems, totalItems, totalPages, from, to, pageIndex: safePageIndex };
    }
    function setPageSize(pager, size){
      if(!pager) return;
      const nextSize = Number(size);
      if(!PAGE_SIZE_OPTIONS.includes(nextSize)) return;
      if(pager.pageSize === nextSize) return;
      pager.pageSize = nextSize;
      pager.pageIndex = 0;
    }
    function nextPage(pager, totalPages){
      if(!pager || totalPages <= 0) return;
      pager.pageIndex = Math.min(pager.pageIndex + 1, totalPages - 1);
    }
    function prevPage(pager){
      if(!pager) return;
      pager.pageIndex = Math.max(pager.pageIndex - 1, 0);
    }
    function resetPage(pager){
      if(!pager) return;
      pager.pageIndex = 0;
    }
    function renderPaginationBar(targetEl, paginationState, callbacks, meta){
      if(!targetEl || !paginationState || !meta) return;
      const { totalItems, totalPages, from, to } = meta;
      const pageIndex = paginationState.pageIndex;
      const isEmpty = totalItems === 0;
      const rangeLabel = isEmpty
        ? 'Showing 0 of 0 tracks'
        : `Showing ${from}â€“${to} of ${totalItems} tracks`;
      const pageLabelCurrent = isEmpty ? 0 : pageIndex + 1;
      const pageLabelTotal = isEmpty ? 0 : totalPages;
      const container = document.createElement('div');
      container.className = 'flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 mt-2 bg-black/30 border border-white/5 rounded-lg px-3 py-3';
      const left = document.createElement('div');
      left.className = 'flex flex-col sm:flex-row sm:items-center gap-2 text-sm text-gray-200';
      left.innerHTML = `<span class="font-semibold text-white">${rangeLabel}</span><span class="text-xs text-gray-400">Page ${pageLabelCurrent} of ${pageLabelTotal}</span>`;
      const middle = document.createElement('div');
      middle.className = 'flex flex-wrap items-center gap-3';
      const label = document.createElement('label');
      label.className = 'flex items-center gap-2 text-sm text-gray-200';
      const labelText = document.createElement('span');
      labelText.textContent = 'Page size';
      const select = document.createElement('select');
      select.className = 'pageSizeSelect bg-white/10 border border-white/10 rounded-lg px-3 py-2 min-h-[44px] text-white';
      select.disabled = isEmpty;
      paginationState.pageSizeOptions.forEach(size=>{
        const opt = document.createElement('option');
        opt.value = String(size);
        opt.textContent = `${size} / page`;
        if(paginationState.pageSize === size) opt.selected = true;
        select.appendChild(opt);
      });
      select.addEventListener('change', (e)=>{
        const target = getEventElement(e);
        if(!target) return;
        const nextSize = Number(target.value);
        if(callbacks?.onPageSizeChange) callbacks.onPageSizeChange(nextSize);
      });
      label.appendChild(labelText);
      label.appendChild(select);
      middle.appendChild(label);
      const controls = document.createElement('div');
      controls.className = 'flex items-center gap-2';
      const prevBtn = document.createElement('button');
      prevBtn.className = `px-4 min-h-[44px] py-2 rounded-lg bg-white/10 border border-white/10 text-sm font-semibold ${pageIndex===0 || isEmpty ? 'opacity-50 cursor-not-allowed' : ''}`;
      prevBtn.textContent = 'Previous';
      prevBtn.disabled = pageIndex === 0 || isEmpty;
      prevBtn.addEventListener('click', ()=>{
        if(callbacks?.onPageChange) callbacks.onPageChange(pageIndex - 1);
      });
      const pageInfo = document.createElement('div');
      pageInfo.className = 'text-sm font-semibold text-white px-2';
      pageInfo.textContent = `Page ${pageLabelCurrent} / ${pageLabelTotal}`;
      const nextBtn = document.createElement('button');
      nextBtn.className = `px-4 min-h-[44px] py-2 rounded-lg bg-white/10 border border-white/10 text-sm font-semibold ${pageIndex >= totalPages - 1 || isEmpty ? 'opacity-50 cursor-not-allowed' : ''}`;
      nextBtn.textContent = 'Next';
      nextBtn.disabled = pageIndex >= totalPages - 1 || isEmpty;
      nextBtn.addEventListener('click', ()=>{
        if(callbacks?.onPageChange) callbacks.onPageChange(pageIndex + 1);
      });
      controls.appendChild(prevBtn);
      controls.appendChild(pageInfo);
      controls.appendChild(nextBtn);
      middle.appendChild(controls);
      container.appendChild(left);
      container.appendChild(middle);
      targetEl.innerHTML = '';
      targetEl.appendChild(container);
    }
    mainPager = createPaginationState();
    loadPaginationPreferences(mainPager);
    function cloneProfile(profile){
      if(!profile) return null;
      try { return structuredClone(profile); } catch(_) { return JSON.parse(JSON.stringify(profile)); }
    }
    function refreshDraftProfileFromCurrentUser(){
      if(viewingProfile) return;
      draftProfile = currentUser ? cloneProfile(currentUser) : null;
    }
    function isAdmin(){
      return currentUser?.isAdmin === true;
    }

    function isGuestUser(){
      return firebaseEnabled && !firebaseAuth?.currentUser;
    }

    function getOwnedCountInSongs(list){
      const ids = normalizeOwnedList(list || []);
      if(!ids.length || !songs.length) return 0;
      const songIdSet = new Set(songs.map(song => song.id));
      return ids.filter(id => songIdSet.has(id)).length;
    }

    function getHeaderTrackCountLabel(){
      const total = songs.length;
      if(!total){
        return isGuestUser() && !viewingProfile ? 'Tracks: â€”' : 'Owned: â€” / â€”';
      }
      if(isGuestUser() && !viewingProfile){
        return `Tracks: ${total}`;
      }
      const displayTracks = viewingProfile ? (viewingProfile.ownedTracks || []) : ownedTracks;
      const ownedCount = getOwnedCountInSongs(displayTracks);
      return `Owned: ${ownedCount}/${total}`;
    }

    function handleAdminMenuOutsideClick(e){
      if(!adminMenuOpen) return;
      const menu = document.getElementById('adminToolsMenu');
      const btn = document.getElementById('adminToolsBtn');
      const target = getEventElement(e);
      const clickInMenu = target ? menu?.contains(target) : false;
      const clickOnBtn = target ? btn?.contains(target) : false;
      if(menu && !clickInMenu && !clickOnBtn){
        toggleAdminTools(false);
      }
    }

    function handleAdminMenuKeydown(e){
      if(e.key === 'Escape'){
        closeHelp();
        if(adminMenuOpen) toggleAdminTools(false);
      }
    }

    function ensureAdminMenuListeners(){
      if(adminMenuListenersBound) return;
      document.addEventListener('click', safeOn('click', handleAdminMenuOutsideClick, { action: 'admin-menu-outside' }));
      document.addEventListener('keydown', safeOn('keydown', handleAdminMenuKeydown, { action: 'admin-menu-keydown' }));
      adminMenuListenersBound = true;
    }

    const toggleAdminTools = (force)=>{
      if(!isAdmin()) return;
      ensureAdminMenuListeners();
      const previous = adminMenuOpen;
      if(force === true) adminMenuOpen = true; else if(force === false) adminMenuOpen = false; else adminMenuOpen = !adminMenuOpen;
      if(adminMenuOpen !== previous){ console.debug('[admin] Admin menu state changed', { previous, next: adminMenuOpen }); }
      render();
      setupEventListeners();
    };

    function openAuditFromMenu(){
      if(!isAdmin()) return alert('Admin only');
      toggleAdminTools(false);
      switchView('audit');
    }

    // ---------------------- Community metrics -------------------
    function startCommunityStatGrace(key){
      clearTimeout(communityStatGraceTimers[key]);
      communityStatGraceTimers[key] = setTimeout(()=>{
        if(communityStats[key] === null || communityStats[key] === 'â€¦'){
          communityStats[key] = 'â€”';
          syncCommunityStatsUI();
        }
      }, COMMUNITY_STAT_GRACE_MS);
    }

    function formatStatValue(value){
      if(value === 'â€”' || value === 'â€¦') return value;
      if(typeof value === 'string') return value;
      if(typeof value === 'number' && !Number.isNaN(value)) return value.toLocaleString();
      return 'â€¦';
    }

    function syncCommunityStatsUI(){
      if(!FEATURE_SIGNIN_STATS) return;
      const mapping = {
        totalDjs: communityStats.totalDjs,
      };
      Object.entries(mapping).forEach(([key,val])=>{
        const el = document.querySelector(`[data-community-stat="${key}"]`);
        if(el) el.textContent = formatStatValue(val);
      });
    }

    function setCommunityStat(key, value){
      if(communityStats[key] === value) { syncCommunityStatsUI(); return; }
      communityStats[key] = value;
      if(value !== null && value !== 'â€¦'){
        clearTimeout(communityStatGraceTimers[key]);
      } else {
        startCommunityStatGrace(key);
      }
      syncCommunityStatsUI();
    }

    async function loadTotalDjs(force=false){
      const cachedTotal = Number(localStorage.getItem(COMMUNITY_TOTAL_DJS_CACHE_KEY) || '');
      if(Number.isFinite(cachedTotal)) setCommunityStat('totalDjs', cachedTotal);
      if(!force && communityStats.totalDjs !== 'â€¦' && communityStats.totalDjs !== 'â€”') return;
      try{
        const resp = await fetch('/api/total-djs');
        if(!resp.ok) throw new Error('Total DJs request failed');
        const data = await resp.json();
        const total = Number(data.totalDjs);
        if(Number.isFinite(total)){
          localStorage.setItem(COMMUNITY_TOTAL_DJS_CACHE_KEY, String(total));
          setCommunityStat('totalDjs', total);
          return;
        }
        throw new Error('Invalid total DJs value');
      } catch(err){
        console.error('Total DJs fetch failed', err);
        setCommunityStat('totalDjs', Number.isFinite(cachedTotal) ? cachedTotal : 'â€”');
      }
    }

    function initCommunityMetrics(){
      if(!FEATURE_SIGNIN_STATS) return;
      startCommunityStatGrace('totalDjs');
      loadTotalDjs();
    }

    // ---------------------- Offline helpers -----------------------
    function flushOwnedLibraryPendingWrite(){
      const store = ensureOwnedLibraryStore();
      if(!store) return Promise.resolve();
      return store.flush('reconnect').catch(()=>{});
    }
    function handleNetworkStatusChange(){
      isOffline = !navigator.onLine;
      const badges = document.querySelectorAll('[data-network-badge]');
      badges.forEach(el=>{
        el.textContent = isOffline ? 'Offline' : 'Online';
        el.className = isOffline
          ? 'inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold bg-red-600/30 border border-red-400/60 text-red-100'
          : 'inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold bg-emerald-600/30 border border-emerald-400/60 text-emerald-100';
      });
      render();
      setupEventListeners();
      if(!isOffline){
        flushOwnedLibraryPendingWrite().catch(err=>console.warn('[owned-library] pending flush failed', err));
        if(firebaseEnabled && firebaseAuth?.currentUser){
          updateSyncState({ state: SYNC_STATES.loadingRemote, message: 'Reconnecting syncâ€¦', errorCode: null, errorStep: null });
          queueSaveProfile({ reason: 'reconnect' }).catch(()=>{});
        }
      } else if(firebaseEnabled && firebaseAuth?.currentUser){
        updateSyncState({ state: SYNC_STATES.idle, message: 'Offline â€” sync paused', errorCode: null, errorStep: null });
      }
    }

    function isMobileViewport(){
      if(window.__forceMobileViewport === true) return true;
      if(mobileViewportQuery) return mobileViewportQuery.matches;
      return window.innerWidth < MOBILE_BREAKPOINT;
    }

    function updatePerformanceMode(){
      const prefersReducedMotion = reducedMotionQuery?.matches;
      const saveData = navigator?.connection?.saveData === true;
      isLowPowerMode = !!(prefersReducedMotion || saveData);
      document.documentElement.classList.toggle('reduced-effects', isLowPowerMode);
    }

    function updateMobileWindowState({ reset = false } = {}){
      if(reset){
        mobileWindowState = { start: 0, count: MOBILE_PAGE_CHUNK };
        return;
      }
      if(mobileWindowState.count < MOBILE_PAGE_CHUNK){
        mobileWindowState.count = MOBILE_PAGE_CHUNK;
      }
    }

    // ---------------------- Utils & Scoring -----------------------
    function normalizeMode(mode,keyStr){
      const m=(mode||'').toLowerCase();
      if(m.includes('min')) return 'minor';
      if(m.includes('maj')) return 'major';
      const k=(keyStr||'').toLowerCase();
      if(/m$/.test(k) || k.includes('minor')) return 'minor';
      if(k.includes('major')) return 'major';
      return '';
    }
    function normalizeKeyName(raw){
      if(!raw) return '';
      let cleaned = (raw||'').replace(/major|minor/ig,'').replace(/maj|min/ig,'').trim();
      cleaned = cleaned.replace(/m$/i,'');
      cleaned = cleaned.replace(/[^a-g#b]/ig,'');
      if(!cleaned) return '';
      const first = cleaned[0].toUpperCase();
      const rest = cleaned.slice(1).replace(/b/,'b').replace(/#/,'#');
      return (first + rest);
    }
    const pitchClassMap = { C:0,'C#':1,Db:1,D:2,'D#':3,Eb:3,E:4,F:5,'F#':6,Gb:6,G:7,'G#':8,Ab:8,A:9,'A#':10,Bb:10,B:11 };
    function parseKey(keyStr, modeStr){
      const raw = (keyStr||'').trim();
      let mode = normalizeMode(modeStr||'', keyStr||'') || null;
      let root = null;
      let pitchClass = null;
      let label = raw || '';
      const explicitMatch = raw.match(/^([A-Ga-g][#b]?)(?:\s*(major|minor))?$/i);
      const shorthandMinor = raw.match(/^([A-Ga-g][#b]?)m$/i);
      if(shorthandMinor){
        root = normalizeKeyName(shorthandMinor[1]);
        mode = mode || 'minor';
      } else if(explicitMatch){
        root = normalizeKeyName(explicitMatch[1]);
        if(explicitMatch[2]) mode = explicitMatch[2].toLowerCase();
      } else if(raw){
        const simpleRoot = raw.match(/^([A-Ga-g][#b]?)/);
        if(simpleRoot){ root = normalizeKeyName(simpleRoot[1]); }
        if(/minor/i.test(raw)) mode = mode || 'minor';
        if(/major/i.test(raw)) mode = mode || 'major';
      }
      if(root && Object.prototype.hasOwnProperty.call(pitchClassMap, root)){
        pitchClass = pitchClassMap[root];
      }
      if(root){
        const modeLabel = mode ? (mode === 'minor' ? 'Minor' : 'Major') : '';
        label = modeLabel ? `${root} ${modeLabel}` : root;
      } else {
        label = label || '?';
      }
      return { root, pitchClass, mode, label };
    }
    function convertToCamelot(key, mode) {
      if (!key && !mode) return '?';
      const modeNormalized = normalizeMode(mode,key);
      const base = normalizeKeyName(key);
      const variants = [];
      const modeWord = modeNormalized === 'minor' ? 'Minor' : 'Major';
      if(base){
        if(modeNormalized){ variants.push(`${base} ${modeWord}`); variants.push(`${base}${modeNormalized==='minor'?'m':''}`); }
        variants.push(base);
      }
      for(const v of variants){ if(keyToCamelot[v]) return keyToCamelot[v]; }
      return '?';
    }
    function deriveCamelotForTrack(track){
      const baseKey = normalizeKeyName(track.mk || track.key || '');
      const mode = normalizeMode(track.mm || track.mode || '', track.mk || track.key || '');
      const fallbackMode = mode || (((track.key||'') + (track.mk||'')).toLowerCase().includes('m') ? 'minor' : 'major');
      const camelot = convertToCamelot(baseKey || track.mk || track.key || '', fallbackMode);
      const keyLabel = baseKey ? `${baseKey} ${fallbackMode}` : '?';
      return { camelot, keyLabel, mode: fallbackMode };
    }
    function semitoneDistance(aPc,bPc){ if(aPc===null||aPc===undefined||bPc===null||bPc===undefined) return null; const d=Math.abs(aPc-bPc)%12; return Math.min(d,12-d); }
    function signedSemitoneDelta(aPc,bPc){ if(aPc===null||aPc===undefined||bPc===null||bPc===undefined) return null; let diff=(bPc-aPc)%12; if(diff>6) diff-=12; if(diff<-6) diff+=12; return diff; }
    function scoreSemitoneKeyMatch(a,b,maxRange, allowOpposite=true){
      if(!a || !b || a.pitchClass===null || b.pitchClass===null) return { eligibleSameMode:false, eligibleOppMode:false, dist:null, scoreSameMode:0, scoreOppMode:0 };
      const dist = semitoneDistance(a.pitchClass,b.pitchClass);
      if(dist===null) return { eligibleSameMode:false, eligibleOppMode:false, dist:null, scoreSameMode:0, scoreOppMode:0 };
      const sameMode = a.mode && b.mode && a.mode === b.mode;
      const eligibleSameMode = !!(sameMode && dist <= maxRange);
      const eligibleOppMode = !!(!sameMode && allowOpposite && dist <= maxRange);
      const scoreSameMode = eligibleSameMode ? Math.max(0, 40 - (dist*4)) : 0;
      const scoreOppMode = eligibleOppMode ? Math.max(4, 10 - dist) : 0;
      return { eligibleSameMode, eligibleOppMode, dist, scoreSameMode, scoreOppMode };
    }
    function getCompatibleKeys(camelot) {
      if (!camelot || camelot === '?') return [];
      const matches = camelot.match(/^(\d+)([AB])$/);
      if (!matches) return [];
      const num = parseInt(matches[1]); const letter = matches[2];
      const compatible = [camelot, `${num}${letter==='A'?'B':'A'}`];
      const nextNum = num === 12 ? 1 : num + 1; const prevNum = num === 1 ? 12 : num - 1;
      compatible.push(`${nextNum}${letter}`); compatible.push(`${prevNum}${letter}`);
      return compatible;
    }
    function ensureKeyInfo(track){ if(!track) return { root:null, pitchClass:null, mode:null, label:'?' }; if(!track.keyInfo){ track.keyInfo = parseKey(track.rawKey || track.key || '', track.rawMode || track.mode || ''); } return track.keyInfo; }
    function isMixable(song1,song2){
      if(!song1||!song2) return false;
      if(keyMatchMode === 'semitone'){
        const aInfo = ensureKeyInfo(song1);
        const bInfo = ensureKeyInfo(song2);
        const match = scoreSemitoneKeyMatch(aInfo,bInfo,maxSemitoneRange, includeOppositeMode);
        return match.eligibleSameMode || match.eligibleOppMode;
      }
      const compatible = getCompatibleKeys(song1.camelot);
      return compatible.includes(song2.camelot);
    }
    function isMixableWithBpm(song1,song2){ if(!song1||!song2) return false; const bpmOk = Math.abs(song1.bpm - song2.bpm) <= 4; return bpmOk && isMixable(song1,song2); }

    function scoreKeyMatch(aCamelot,bCamelot){ if(!aCamelot||!bCamelot||aCamelot==='?'||bCamelot==='?') return 0; if(aCamelot===bCamelot) return 50; const ma=aCamelot.match(/^(\d+)([AB])$/), mb=bCamelot.match(/^(\d+)([AB])$/); if(!ma||!mb) return 0; const numA=parseInt(ma[1]), letterA=ma[2], numB=parseInt(mb[1]), letterB=mb[2]; const ringDiff=Math.min(Math.abs(numA-numB),12-Math.abs(numA-numB)); if(numA===numB&&letterA!==letterB) return 42; if(letterA===letterB&&ringDiff===1) return 38; if(letterA!==letterB&&ringDiff===1) return 30; if(letterA===letterB&&ringDiff===2) return 26; return 14 - Math.min(ringDiff,6); }
    function scoreBpmMatch(aBpm,bBpm){ const diff=Math.abs(aBpm-bBpm); if(diff<=1) return 35; if(diff<=3) return 32; if(diff<=6) return 26; if(diff<=10) return 16; if(diff<=15) return 10; return 0; }
    function scoreGenreMatch(aGenre,bGenre){ if(!aGenre||!bGenre) return 0; return aGenre===bGenre?15:5; }
    function camelotDistance(aCamelot,bCamelot){ if(!aCamelot||!bCamelot||aCamelot==='?'||bCamelot==='?') return 99; const ma=aCamelot.match(/^(\d+)([AB])$/), mb=bCamelot.match(/^(\d+)([AB])$/); if(!ma||!mb) return 99; const numA=parseInt(ma[1]), letterA=ma[2], numB=parseInt(mb[1]), letterB=mb[2]; const numDiff=Math.min(Math.abs(numA-numB),12-Math.abs(numA-numB)); const letterDiff = letterA===letterB ? 0 : 0.5; return numDiff + letterDiff; }
    function mashupCompatibility(a,b){
      let keyScore = 0;
      if(keyMatchMode === 'semitone'){
        const aInfo = ensureKeyInfo(a);
        const bInfo = ensureKeyInfo(b);
        const match = scoreSemitoneKeyMatch(aInfo,bInfo,maxSemitoneRange, includeOppositeMode);
        keyScore = match.eligibleSameMode ? match.scoreSameMode : (match.eligibleOppMode ? match.scoreOppMode : 0);
      } else {
        keyScore = scoreKeyMatch(a.camelot,b.camelot);
      }
      const bpm=scoreBpmMatch(a.bpm,b.bpm); const genre=scoreGenreMatch(a.genre,b.genre); const total=keyScore+bpm+genre; return {total,breakdown:{key:keyScore,bpm,genre}};
    }
    function getPriorityBoost(strength){ if(strength==='low') return 60; if(strength==='high') return 200; return 120; }
    function priorityRank(anchor, candidate, mode){
      const comp = mashupCompatibility(anchor, candidate);
      const bpmDiff = Math.abs(candidate.bpm - anchor.bpm);
      const semitoneMatch = keyMatchMode==='semitone' ? (()=>{ const aInfo=ensureKeyInfo(anchor); const bInfo=ensureKeyInfo(candidate); const base=scoreSemitoneKeyMatch(aInfo,bInfo,maxSemitoneRange, includeOppositeMode); return { ...base, signedDelta: signedSemitoneDelta(aInfo.pitchClass,bInfo.pitchClass) }; })() : null;
      const keyDist = keyMatchMode==='semitone' ? (semitoneMatch ? semitoneMatch.dist : null) : camelotDistance(anchor.camelot, candidate.camelot);
      const sameGenre = candidate.genre === anchor.genre;

      const bpmScore = Math.max(0, 1 - (bpmDiff / 10));
      const keyScore = keyMatchMode==='semitone'
        ? Math.max(0, 1 - ((keyDist ?? 6) / 6))
        : Math.max(0, 1 - (keyDist / 6));
      const genreScore = sameGenre ? 1 : 0;

      const boost = getPriorityBoost(priorityStrength);
      let rank = comp.total * 10;

      if(mode === 'bpm') rank += bpmScore * boost;
      if(mode === 'camelot') rank += keyScore * boost;
      if(mode === 'genre') rank += genreScore * boost;

      if(bpmDiff > 12) rank -= 40;
      if(keyDist !== null && keyDist !== undefined && keyDist > 4) rank -= 40;

      return { rank, comp, bpmDiff, keyDist, sameGenre, semitoneMatch };
    }
    function bpmShiftSuggestion(aBpm,bBpm){ const shift=Math.round(bBpm-aBpm); if(shift===0) return 'No change'; return (shift>0?'+':'')+shift+' BPM = Perfect Match'; }
    function normalizeTitleArtist(title,artist){
      return `${(title||'').toLowerCase()}|${(artist||'').toLowerCase()}`;
    }
    function applyCamelotOverride(track, derivedCamelot){
      const key = normalizeTitleArtist(track.title || track.tt, track.artist || track.an);
      const fromId = camelotOverridesStore.ids[track.id];
      const fromName = camelotOverridesStore.names[key];
      const finalCamelot = fromId || fromName || derivedCamelot;
      return { camelot: finalCamelot, overridden: !!(fromId || fromName) };
    }
    function applyBpmOverride(track, rawBpm){
      const key = normalizeTitleArtist(track.title || track.tt, track.artist || track.an);
      const fromId = bpmOverridesStore.ids[track.id];
      const fromName = bpmOverridesStore.names[key];
      const finalBpm = fromId ? Number(fromId) : (fromName ? Number(fromName) : rawBpm);
      return { bpm: isNaN(finalBpm) ? rawBpm : finalBpm, overridden: !!(fromId || fromName) };
    }
    function computeTrackFlags(track){
      const flags = [];
      if(!track.camelot || !/^\d{1,2}[AB]$/.test(track.camelot)) flags.push('INVALID_CAMELOT');
      const modeLower = (track.mode||'').toLowerCase();
      if(track.camelot && /^\d{1,2}[AB]$/.test(track.camelot)){
        const letter = track.camelot.slice(-1);
        if(modeLower==='major' && letter==='A') flags.push('MODE_MISMATCH');
        if(modeLower==='minor' && letter==='B') flags.push('MODE_MISMATCH');
      }
      if(!track.rawKey && !track.rawMode) flags.push('WEAK_PARSE');
      if(!track.bpm || isNaN(track.bpm)) flags.push('BPM_MISSING');
      if(track.bpm && (track.bpm < 60 || track.bpm > 220)) flags.push('BPM_OUTLIER');
      if(track.camelotOverridden) flags.push('OVERRIDDEN_CAMELOT');
      if(track.bpmOverridden) flags.push('OVERRIDDEN_BPM');
      return flags;
    }
    function refreshSongOverrides(track){
      const camelotData = deriveCamelotForTrack({ mk: track.rawKey, mm: track.rawMode, key: track.key, title: track.title, artist: track.artist });
      const camelotApplied = applyCamelotOverride(track, camelotData.camelot);
      const bpmApplied = applyBpmOverride(track, track.rawBpm || track.bpm);
      track.keyInfo = parseKey(track.rawKey || track.key || '', track.rawMode || track.mode || '');
      track.key = track.keyInfo.label || camelotData.keyLabel || track.key;
      track.camelot = camelotApplied.camelot;
      track.camelotOverridden = camelotApplied.overridden;
      track.bpm = bpmApplied.bpm;
      track.bpmOverridden = bpmApplied.overridden;
      track.derivedCamelot = camelotData.camelot;
      track.flags = computeTrackFlags(track);
    }
    function hydrateKeyInfo(track){
      if(!track) return;
      track.keyInfo = parseKey(track.rawKey || track.key || '', track.rawMode || track.mode || '');
      if(track.keyInfo.label) track.key = track.keyInfo.label;
    }
    // ----------------------- Genre detection -----------------------
    function detectGenre(artist, title){
      artist=(artist||'').toLowerCase(); title=(title||'').toLowerCase();
      for(const [genre,artists] of Object.entries(genreMap)){
        if(artists.some(a=>artist.includes(a) || (a.length>3 && artist.includes(a.split(' ')[0])))) return genre;
      }
      if(title.includes('rock')||title.includes('metal')) return 'Rock';
      if(title.includes('funk')||title.includes('disco')) return 'Disco/Funk';
      if(title.includes('blues')) return 'Blues';
      if(title.includes('jazz')) return 'Jazz';
      if(title.includes('country')) return 'Country';
      if(title.includes('reggae')) return 'Reggae';
      return 'Other';
    }

    // ----------------------- Storage helpers -----------------------
    function loadOverridesFromStorage(){
      try{
        camelotOverridesStore = JSON.parse(localStorage.getItem('camelotOverrides_v2') || '{"ids":{},"names":{}}');
      }catch(e){ camelotOverridesStore = { ids:{}, names:{} }; }
      try{
        bpmOverridesStore = JSON.parse(localStorage.getItem('bpmOverrides_v1') || '{"ids":{},"names":{}}');
      }catch(e){ bpmOverridesStore = { ids:{}, names:{} }; }
    }
    async function persistOverrides(){
      localStorage.setItem('camelotOverrides_v2', JSON.stringify(camelotOverridesStore));
      localStorage.setItem('bpmOverrides_v1', JSON.stringify(bpmOverridesStore));
      if(isAdmin() && firestore && firebaseAuth?.currentUser){
        await awaitAuthReady();
        try{
          const collection = getProfileCollection();
          if(!collection) return;
          await collection.doc(firebaseAuth.currentUser.uid).set({
            camelotOverrides: camelotOverridesStore,
            bpmOverrides: bpmOverridesStore
          },{merge:true});
        }catch(err){ console.warn('persist override firestore', err); }
      }
    }
    async function loadUserOverridesFromBackend(){
      if(isAdmin() && firestore && firebaseAuth?.currentUser){
        await awaitAuthReady();
        try{
          const collection = getProfileCollection();
          if(!collection) return;
          const doc = await collection.doc(firebaseAuth.currentUser.uid).get();
          if(doc.exists){
            const data = doc.data()||{};
            if(data.camelotOverrides) camelotOverridesStore = data.camelotOverrides;
            if(data.bpmOverrides) bpmOverridesStore = data.bpmOverrides;
          }
        }catch(err){ console.warn('load override firestore', err); }
      }
    }
    function normalizeOwnedList(ids){
      const arr = Array.isArray(ids) ? ids.filter(Boolean) : [];
      return Array.from(new Set(arr)).sort();
    }
    function readOwnedTracksCache(uid){
      if(!uid) return null;
      return window.profileStore?.readOwnedTracksCache?.(uid) || null;
    }
    function ensureOwnedLibraryStore(){
      if(ownedStore) return ownedStore;
      const createStore = window.ownedLibraryStore?.createOwnedLibraryStore;
      if(!createStore) return null;
      ownedStore = createStore({
        readCache: (uid) => window.profileStore?.readOwnedTracksCache?.(uid) || null,
        writeCache: (uid, snapshot) => window.profileStore?.writeOwnedTracksCache?.(uid, snapshot) || snapshot,
        readCloud: (uid) => window.profileStore?.readOwnedLibraryDoc?.(uid) || null,
        writeCloud: (uid, snapshot) => window.profileStore?.writeOwnedLibraryDoc?.(uid, snapshot),
        buildPlan: window.profileStore?.buildOwnedLibraryPlan,
        normalizeSnapshot: window.profileStore?.normalizeOwnedLibrarySnapshot,
        getOnline: () => navigator.onLine,
        getCloudEnabled: () => firebaseEnabled && firestore,
        readLastGoodCount: (uid) => window.profileStore?.readLastGoodOwnedCount?.(uid) || null,
        writeLastGoodCount: (uid, value) => window.profileStore?.writeLastGoodOwnedCount?.(uid, value),
        readLastSyncAt: (uid) => window.profileStore?.readLastSyncAt?.(uid) || null,
        writeLastSyncAt: (uid, value) => window.profileStore?.writeLastSyncAt?.(uid, value),
        readLastSyncHash: (uid) => window.profileStore?.readLastSyncHash?.(uid) || null,
        writeLastSyncHash: (uid, value) => window.profileStore?.writeLastSyncHash?.(uid, value),
        readLastBackupAt: (uid) => window.profileStore?.readLastBackupAt?.(uid) || null,
        writeLastBackupAt: (uid, value) => window.profileStore?.writeLastBackupAt?.(uid, value),
        readLastLocalBackupAt: (uid) => window.profileStore?.readLastLocalBackupAt?.(uid) || null,
        writeLastLocalBackupAt: (uid, value) => window.profileStore?.writeLastLocalBackupAt?.(uid, value),
        readLocalBackup: (uid) => window.profileStore?.readOwnedTracksBackup?.(uid) || null,
        writeLocalBackup: (uid, snapshot) => window.profileStore?.writeOwnedTracksBackup?.(uid, snapshot) || snapshot,
        onSnapshot: (snapshot) => {
          ownedTracks = snapshot.trackIds || [];
          updateOwnedCount();
          if(currentUser){
            persistUserSession(currentProfileFromState(), { reason: 'toggleOwned', skipBackend: true }).catch(()=>{});
          }
        },
        onStatus: (next) => {
          ownedLibraryState = next;
          if(next?.phase === 'saving'){
            updateSyncState({ state: SYNC_STATES.savingRemote, message: 'Savingâ€¦', errorCode: null, errorStep: next?.errorStep || null });
          }
          if(next?.phase === 'error'){
            setSyncError({
              code: next?.errorCode || 'owned_library_sync_failed',
              step: next?.errorStep || 'savingRemote',
              message: next?.message || 'Sync failed. Retry.'
            });
          }
          if(next?.phase === 'ready' && navigator.onLine && firebaseEnabled && firestore){
            setSyncedState('Synced âœ…');
            const uid = firebaseAuth?.currentUser?.uid;
            if(uid){
              updateSyncState({
                lastSyncedAt: window.profileStore?.readLastSyncAt?.(uid) || syncState.lastSyncedAt,
                lastSyncHash: window.profileStore?.readLastSyncHash?.(uid) || syncState.lastSyncHash
              });
            }
          }
          render();
          setupEventListeners();
        },
        onSyncEvent: (event) => {
          console.debug('[owned-library] sync', event);
        }
      });
      return ownedStore;
    }
    function setOwnedLibraryStatus({ phase = 'idle', source = 'none', message = '' } = {}){
      ownedLibraryState = { phase, source, message };
    }
    function resolveOwnedLibraryStatusMessage(){
      if(ownedLibraryState?.message) return ownedLibraryState.message;
      if(ownedLibraryState?.phase === 'syncing') return 'Syncing libraryâ€¦';
      if(!navigator.onLine) return 'Offline â€” sync paused';
      if(!firebaseEnabled || !firestore) return 'Sync paused';
      return 'Synced âœ…';
    }
    async function initOwnedLibraryForUser(uid, { legacyOwnedTracks = [], initialTrackIds = [], skipCloud = false } = {}){
      const store = ensureOwnedLibraryStore();
      if(!store || !uid) return null;
      return store.initForUser(uid, { legacyOwnedTracks, initialTrackIds, skipCloud });
    }
    function normalizeSetlistIds(ids){
      if(!Array.isArray(ids)) return [];
      const list = ids.map(item => (typeof item === 'string' ? item : item?.id)).filter(Boolean);
      return Array.from(new Set(list));
    }
    function getTourProfileDone(profile){
      if(!profile?.tour) return false;
      const version = Number(profile.tour.version || 0);
      return profile.tour.done === true && version >= TOUR_VERSION;
    }
    function isTourDone(){
      if(localStorage.getItem(TOUR_STORAGE_KEY) === '1') return true;
      return getTourProfileDone(currentUser);
    }
    function markTourDone(){
      localStorage.setItem(TOUR_STORAGE_KEY, '1');
      if(currentUser && !viewingProfile){
        const tourData = { done: true, version: TOUR_VERSION, completedAt: new Date().toISOString() };
        currentUser = { ...currentUser, tour: tourData };
        if(draftProfile) draftProfile.tour = tourData;
        if(!profileUiState.isSaving){
          persistCurrentUserProfile().catch(err=>console.warn('[tour] profile persist failed', err));
        }
      }
    }
    function getTourElements(){
      return {
        overlay: document.getElementById('tourOverlay'),
        highlight: document.getElementById('tourHighlight'),
        tooltip: document.getElementById('tourTooltip'),
        title: document.getElementById('tourTitle'),
        copy: document.getElementById('tourCopy'),
        hint: document.getElementById('tourHint'),
        backBtn: document.getElementById('tourBackBtn'),
        routeBtn: document.getElementById('tourRouteBtn'),
        skipBtn: document.getElementById('tourSkipBtn'),
        nextBtn: document.getElementById('tourNextBtn')
      };
    }
    function openTourOverlay(){
      const { overlay } = getTourElements();
      if(!overlay) return;
      overlay.dataset.open = 'true';
      overlay.setAttribute('aria-hidden','false');
    }
    function closeTourOverlay(){
      const { overlay } = getTourElements();
      if(!overlay) return;
      overlay.dataset.open = 'false';
      overlay.setAttribute('aria-hidden','true');
    }
    function focusTour(){
      const { tooltip } = getTourElements();
      if(!tooltip) return;
      const focusables = tooltip.querySelectorAll('button,[href],[tabindex]:not([tabindex="-1"])');
      const first = focusables[0];
      if(first) first.focus();
    }
    function trapTourFocus(e){
      if(!tourState.isOpen || e.key !== 'Tab') return;
      const { tooltip } = getTourElements();
      if(!tooltip) return;
      const focusables = Array.from(tooltip.querySelectorAll('button,[href],[tabindex]:not([tabindex="-1"])'));
      if(!focusables.length) return;
      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      if(e.shiftKey && document.activeElement === first){
        e.preventDefault();
        last.focus();
      } else if(!e.shiftKey && document.activeElement === last){
        e.preventDefault();
        first.focus();
      }
    }
    function scrollTargetIntoView(targetEl){
      if(!targetEl) return;
      try{
        targetEl.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
      }catch(_){}
    }
    function positionTourElements(step){
      const { highlight, tooltip, hint, routeBtn, nextBtn } = getTourElements();
      if(!highlight || !tooltip) return;
      const routeMismatch = step.route && view !== step.route;
      const targetEl = routeMismatch ? null : document.querySelector(step.selector);
      const rect = targetEl?.getBoundingClientRect();
      const hasTarget = rect && rect.width > 0 && rect.height > 0;
      if(hasTarget){
        const padding = 6;
        highlight.style.display = 'block';
        highlight.style.top = `${Math.max(0, rect.top - padding)}px`;
        highlight.style.left = `${Math.max(0, rect.left - padding)}px`;
        highlight.style.width = `${rect.width + padding * 2}px`;
        highlight.style.height = `${rect.height + padding * 2}px`;
      } else {
        highlight.style.display = 'none';
      }
      if(hint){
        if(routeMismatch){
          hint.textContent = step.route === 'profile' ? 'Open Profile to continue.' : 'Open Browse to continue.';
          hint.style.display = 'block';
        } else if(!hasTarget){
          hint.textContent = 'Go to the next screen to continue.';
          hint.style.display = 'block';
        } else {
          hint.style.display = 'none';
        }
      }
      if(routeBtn){
        routeBtn.style.display = routeMismatch ? 'inline-flex' : 'none';
        routeBtn.textContent = step.routeLabel || (step.route === 'profile' ? 'Go to Profile' : 'Go to Browse');
      }
      if(nextBtn){
        nextBtn.disabled = routeMismatch;
      }
      if(!hasTarget){
        tooltip.style.top = '50%';
        tooltip.style.left = '50%';
        tooltip.style.transform = 'translate(-50%, -50%)';
        return;
      }
      tooltip.style.transform = 'translate(0, 0)';
      const tooltipRect = tooltip.getBoundingClientRect();
      const spacing = 12;
      let top = rect.bottom + spacing;
      if(top + tooltipRect.height > window.innerHeight - 12){
        top = rect.top - spacing - tooltipRect.height;
      }
      let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
      left = Math.max(12, Math.min(left, window.innerWidth - tooltipRect.width - 12));
      if(top < 12 || top + tooltipRect.height > window.innerHeight - 12){
        top = Math.max(12, Math.min(rect.bottom + spacing, window.innerHeight - tooltipRect.height - 12));
      }
      tooltip.style.top = `${top}px`;
      tooltip.style.left = `${left}px`;
      scrollTargetIntoView(targetEl);
    }
    function updateTourUI(){
      if(!tourState.isOpen) return;
      const step = tourState.steps[tourState.stepIndex];
      const { title, copy, backBtn, nextBtn } = getTourElements();
      if(title) title.textContent = step.title;
      if(copy) copy.textContent = step.copy;
      if(backBtn) backBtn.style.display = tourState.stepIndex === 0 ? 'none' : 'inline-flex';
      if(nextBtn) nextBtn.textContent = tourState.stepIndex === tourState.steps.length - 1 ? 'Done' : 'Next';
      requestAnimationFrame(()=> positionTourElements(step));
    }
    function startTour(source = 'auto', options = {}){
      if(tourState.isOpen) return;
      if(!options.force && isTourDone()) return;
      tourState.isOpen = true;
      tourState.stepIndex = 0;
      tourState.source = source;
      tourState.lastFocused = document.activeElement;
      bindTourEvents();
      const helpModal = document.getElementById('helpModal');
      if(helpModal && helpModal.style.display === 'flex'){
        closeHelp();
      }
      openTourOverlay();
      updateTourUI();
      focusTour();
    }
    function nextTourStep(){
      if(!tourState.isOpen) return;
      if(tourState.stepIndex >= tourState.steps.length - 1){
        finishTour();
        return;
      }
      tourState.stepIndex += 1;
      updateTourUI();
      focusTour();
    }
    function prevTourStep(){
      if(!tourState.isOpen) return;
      if(tourState.stepIndex === 0) return;
      tourState.stepIndex -= 1;
      updateTourUI();
      focusTour();
    }
    function skipTour(){
      if(!tourState.isOpen) return;
      tourState.isOpen = false;
      closeTourOverlay();
      markTourDone();
      if(tourState.lastFocused && typeof tourState.lastFocused.focus === 'function'){
        tourState.lastFocused.focus();
      }
    }
    function finishTour(){
      if(!tourState.isOpen) return;
      tourState.isOpen = false;
      closeTourOverlay();
      markTourDone();
      if(tourState.lastFocused && typeof tourState.lastFocused.focus === 'function'){
        tourState.lastFocused.focus();
      }
    }
    function goToTourRoute(route){
      if(!route) return;
      if(typeof window.switchView === 'function'){
        window.switchView(route);
      }
      updateTourUI();
    }
    function bindTourEvents(){
      const { backBtn, nextBtn, skipBtn, routeBtn } = getTourElements();
      if(backBtn && !backBtn.dataset.bound){
        backBtn.dataset.bound = 'true';
        backBtn.addEventListener('click', prevTourStep);
      }
      if(nextBtn && !nextBtn.dataset.bound){
        nextBtn.dataset.bound = 'true';
        nextBtn.addEventListener('click', nextTourStep);
      }
      if(skipBtn && !skipBtn.dataset.bound){
        skipBtn.dataset.bound = 'true';
        skipBtn.addEventListener('click', skipTour);
      }
      if(routeBtn && !routeBtn.dataset.bound){
        routeBtn.dataset.bound = 'true';
        routeBtn.addEventListener('click', ()=>{
          const step = tourState.steps[tourState.stepIndex];
          goToTourRoute(step.route);
        });
      }
    }
    function maybeAutoStartTour(){
      if(isTourDone()) return;
      if(tourState.isOpen) return;
      setTimeout(()=>{
        if(tourState.isOpen || isTourDone()) return;
        startTour('auto');
      }, 300);
    }
    async function persistCurrentUserProfile({ reason = 'system', force = false } = {}){
      console.debug('[profile] save clicked', { draftProfile, currentUser });
      if(viewingProfile) throw new Error('Cannot save while viewing another profile');
      if(!currentUser?.username) throw new Error('No current user to persist');
      const adminApplied = applyAdminFlag(currentUser);
      await persistAdminFlagIfNeeded(currentUser, adminApplied);
      currentUser = adminApplied;
      setProfileSaving(true, 'persistCurrentUserProfile');
      try{
        const mergedProfile = currentProfileFromState();
        console.debug('[profile] currentUser before persist', currentUser);
        currentUser = mergedProfile;
        console.debug('[profile] currentUser after merge', currentUser);
        refreshDraftProfileFromCurrentUser();
        persistProfileCache();
        persistKeyMatchSettings();
        const profileKey = currentUser.uid || currentUser.username;
        if(profileKey) localStorage.setItem('currentUser', profileKey);
        const { backendOk, profile: storedProfile, blocked } = await persistProfileRobust(mergedProfile, { force, reason });
        console[backendOk ? 'debug' : 'warn'](backendOk ? '[profile] backend save ok' : '[profile] backend save failed');
        if(blocked){
          maybeShowRecoveryBanner();
          return { backendOk: false, verifyProfile: null };
        }
        const verifyProfile = storedProfile || await loadUserProfile(currentUser.uid || currentUser.username);
        currentUser = verifyProfile || currentUser;
        applyPreferencesFromProfile(currentUser);
        refreshDraftProfileFromCurrentUser();
        console.debug('[profile] save verified', { verifyProfile });
        return { backendOk, verifyProfile };
      } finally {
        setProfileSaving(false, 'persistCurrentUserProfile');
      }
    }
    async function saveUserProfile({ reason = 'system', force = false } = {}){
      return persistCurrentUserProfile({ reason, force });
    }
    async function loadUserProfile(username){
      if(!username && !firebaseAuth?.currentUser) return null;
      await awaitAuthReady();
      const firebaseUser = firebaseAuth?.currentUser;
      if(firestore && (firebaseUser || username)){
        try{
          const collection = getProfileCollection();
          const legacyCollection = getLegacyProfileCollection();
          const lookupId = firebaseUser?.uid || username;
          const isLikelyUid = typeof lookupId === 'string' && (lookupId.startsWith('local:') || lookupId.length >= 20);
          if(collection && isLikelyUid){
            const doc = await collection.doc(lookupId).get();
            if(doc.exists) return normalizeProfileShape(doc.data(), lookupId);
          }
          if(legacyCollection && isLikelyUid){
            const legacyId = firebaseUser?.uid || username;
            const legacyDoc = await legacyCollection.doc(legacyId).get();
            if(legacyDoc.exists) return normalizeProfileShape(legacyDoc.data(), legacyId);
          }
          if(username && collection){
            const query = await collection.where('usernameLower','==', normalizeUsernameLower(username)).limit(1).get();
            const match = query.docs[0];
            if(match?.exists) return normalizeProfileShape({ ...match.data(), uid: match.id }, match.id);
          }
        }catch(e){ console.warn('Firestore load failed',e); }
      }
      const profiles = JSON.parse(localStorage.getItem('userProfiles')||'{}');
      if(firebaseUser?.uid && profiles[firebaseUser.uid]) return normalizeProfileShape(profiles[firebaseUser.uid], firebaseUser.uid);
      return normalizeProfileShape(profiles[username], username) || null;
    }

    async function loadProfileForViewing(username){
      if(!username) return null;
      const profile = await loadUserProfileFromBackend(username) || await loadUserProfile(username);
      if(profile?.isPublic === false){
        const ownerId = firebaseAuth?.currentUser?.uid || currentUser?.uid || currentUser?.username;
        if(ownerId !== profile.uid && ownerId !== profile.username){
          return null;
        }
      }
      if(profile?.uid && firebaseEnabled && firestore && navigator.onLine){
        await awaitAuthReady();
        try{
          const ownedSnapshot = await window.profileStore.readOwnedLibraryDoc(profile.uid);
          if(ownedSnapshot?.trackIds){
            profile.ownedTracks = ownedSnapshot.trackIds;
          }
        }catch(err){
          console.warn('[profile] owned library fetch failed', err);
        }
      }
      viewingProfile = profile || null;
      return viewingProfile;
    }

    async function fetchProfilesByField(field, value, { publicOnly = true } = {}){
      if(!firestore || !value) return [];
      await awaitAuthReady();
      try{
        const collection = getProfileCollection();
        if(!collection) return [];
        let query = collection.where(field,'==',value);
        if(publicOnly) query = query.where('isPublic','==',true);
        const snap = await query.get();
        return snap.docs.map(doc=> normalizeProfileShape({ ...doc.data(), uid: doc.id }, doc.id));
      }catch(err){ console.warn('profile lookup failed', err); return []; }
    }

    function getFriendsOnlineStatus(){
      const firebaseReady = firebaseEnabled && !!firestore;
      const signedIn = !!firebaseAuth?.currentUser;
      const offline = !navigator.onLine || isOffline;
      const online = firebaseReady && signedIn && !offline;
      return { firebaseReady, signedIn, offline, online };
    }

    function getFriendsGateMessage(status){
      if(!status) return '';
      if(status.offline) return 'Friends require Online mode.';
      if(!status.firebaseReady) return 'Friends require Firebase online mode.';
      if(!status.signedIn) return 'Sign in to search friends.';
      return '';
    }

    function isOnlineProfileMode(){
      return getFriendsOnlineStatus().online;
    }

    function setFriendSearchNotice(message, tone = 'info'){
      socialFriendSearchNotice = message;
      socialFriendSearchNoticeTone = tone;
    }

    function getFriendSearchQuery(){
      const input = document.getElementById('socialFriendSearchInput');
      const raw = input?.value || '';
      const trimmed = raw.trim();
      socialFriendSearchTerm = raw;
      socialFriendSearchQuery = trimmed;
      return trimmed;
    }

    function logFriendSearchClick(){
      const q = getFriendSearchQuery();
      console.debug('[friends] search click', { q });
    }

    function handleFriendSearch(event, { explicit = true } = {}){
      if(event?.preventDefault) event.preventDefault();
      if(viewingProfile) return;
      const query = getFriendSearchQuery();
      socialFriendSearchError = '';
      if(!query){
        if(explicit){
          socialFriendSearchResults = [];
          socialFriendSearchLoading = false;
          setFriendSearchNotice('Type a DJ name.', 'warn');
          renderProfile();
          setupEventListeners();
        }
        return;
      }
      const status = getFriendsOnlineStatus();
      const gateMessage = getFriendsGateMessage(status);
      if(gateMessage){
        socialFriendSearchResults = [];
        socialFriendSearchLoading = false;
        setFriendSearchNotice(gateMessage, 'warn');
        renderProfile();
        setupEventListeners();
        return;
      }
      setFriendSearchNotice('');
      searchProfilesForFriends();
    }

    async function fetchProfilesByUids(uids){
      await awaitAuthReady();
      const collection = getProfileCollection();
      if(!collection) return {};
      const unique = Array.from(new Set(uids)).filter(Boolean);
      const results = await Promise.all(unique.map(async (uid)=>{
        try{
          const doc = await collection.doc(uid).get();
          if(doc.exists) return [uid, normalizeProfileShape({ ...doc.data(), uid }, uid)];
        }catch(err){ console.warn('profile fetch failed', err); }
        return [uid, null];
      }));
      return results.reduce((acc, [uid, profile])=>{
        if(profile) acc[uid] = profile;
        return acc;
      }, {});
    }

    async function refreshFriendsData(force=false){
      if(!isOnlineProfileMode() || viewingProfile || friendsLoading) return;
      await awaitAuthReady();
      const now = Date.now();
      if(!force && now - friendsLoadedAt < 20000) return;
      friendsLoading = true;
      friendsError = '';
      try{
        const uid = firebaseAuth.currentUser.uid;
        const requestsRef = firestore.collection('friendRequests');
        const incomingSnap = await requestsRef.where('toUid','==',uid).where('status','==','pending').get();
        const outgoingSnap = await requestsRef.where('fromUid','==',uid).where('status','==','pending').get();
        const friendsSnap = await firestore.collection('friends').doc(uid).collection('list').get();
        const incoming = incomingSnap.docs.map(doc=>({ id: doc.id, ...doc.data() }));
        const outgoing = outgoingSnap.docs.map(doc=>({ id: doc.id, ...doc.data() }));
        const friendDocs = friendsSnap.docs.map(doc=>({ id: doc.id, ...doc.data() }));
        const profileMap = await fetchProfilesByUids([
          ...incoming.map(req=>req.fromUid),
          ...outgoing.map(req=>req.toUid),
          ...friendDocs.map(doc=>doc.friendUid || doc.id)
        ]);
        friendRequestsIncoming = incoming.map(req=>({ ...req, fromProfile: profileMap[req.fromUid] || null }));
        friendRequestsOutgoing = outgoing.map(req=>({ ...req, toProfile: profileMap[req.toUid] || null }));
        friendsList = friendDocs.map(doc=>({
          friendUid: doc.friendUid || doc.id,
          createdAt: doc.createdAt || null,
          profile: profileMap[doc.friendUid || doc.id] || null
        }));
        friendsLoadedAt = now;
      }catch(err){
        console.warn('friends refresh failed', err);
        friendsError = 'Unable to load friends right now.';
      } finally {
        friendsLoading = false;
        if(!viewingProfile){
          renderProfile();
          setupEventListeners();
        }
      }
    }

    function getFriendStatus(currentUid, otherUid){
      if(!currentUid || !otherUid) return 'none';
      if(currentUid === otherUid) return 'self';
      if(friendsList.some(item=> item.friendUid === otherUid)) return 'friends';
      if(friendRequestsIncoming.some(req=> req.fromUid === otherUid)) return 'incoming_pending';
      if(friendRequestsOutgoing.some(req=> req.toUid === otherUid)) return 'outgoing_pending';
      return 'none';
    }

    async function searchProfilesForFriends(){
      if(viewingProfile) return;
      const queryRaw = (socialFriendSearchQuery || socialFriendSearchTerm || '').trim();
      socialFriendSearchQuery = queryRaw;
      socialFriendSearchError = '';
      socialFriendSearchResults = [];
      if(!queryRaw){
        socialFriendSearchLoading = false;
        renderProfile();
        setupEventListeners();
        return;
      }
      socialFriendSearchLoading = true;
      setFriendSearchNotice('');
      renderProfile();
      setupEventListeners();
      try{
        const queryLower = normalizeUsernameLower(queryRaw);
        const collection = getProfileCollection();
        if(!collection) throw new Error('Profile collection unavailable');
        const resultsMap = {};
        const prefixQuery = async (field)=>{
          const snap = await collection
            .where(field, '>=', queryLower)
            .where(field, '<=', queryLower + '\uf8ff')
            .where('isPublic', '==', true)
            .limit(20)
            .get();
          snap.docs.forEach(doc=>{ resultsMap[doc.id] = normalizeProfileShape({ ...doc.data(), uid: doc.id }, doc.id); });
        };
        await Promise.all([
          prefixQuery('displayNameLower'),
          prefixQuery('usernameLower'),
          prefixQuery('djNameLower'),
          prefixQuery('searchNameLower')
        ]);
        const currentUid = firebaseAuth.currentUser.uid;
        socialFriendSearchResults = Object.values(resultsMap)
          .filter(profile=> profile?.uid !== currentUid)
          .slice(0, 20);
      }catch(err){
        console.error('[friends] search failed', err);
        socialFriendSearchError = 'Search failed. Try again later.';
      } finally {
        socialFriendSearchLoading = false;
        renderProfile();
        setupEventListeners();
      }
    }

    function getEditableDraftProfile(){
      if(viewingProfile) return null;
      draftProfile = draftProfile || cloneProfile(currentUser) || {};
      return draftProfile;
    }

    function updateDraftProfile(patch){
      const draft = getEditableDraftProfile();
      if(!draft) return null;
      Object.assign(draft, patch);
      return draft;
    }

    function updateDraftPersona(patch){
      const draft = getEditableDraftProfile();
      if(!draft) return null;
      const persona = ensurePersona(draft);
      const next = { ...persona, ...patch };
      draft.personaId = next.personaId;
      draft.personaTheme = next.personaTheme;
      draft.personaSeed = next.personaSeed;
      return next;
    }

    function persistPersonaSelection(persona){
      if(!persona || viewingProfile) return;
      persistPersonaToStorage(persona);
      const updated = { ...(currentUser || {}), ...persona };
      currentUser = updated;
      if(draftProfile) Object.assign(draftProfile, persona);
      saveUserProfileToBackend(updated).catch(err => console.warn('persona save failed', err));
    }

    function updatePersonaPreview(persona){
      const resolved = persona || ensurePersona(draftProfile || currentUser || {});
      const energy = (PERSONAS[resolved.personaId] || PERSONAS.turntablist).energy || 'âš¡';
      const preview = document.getElementById('profilePersonaPreview');
      if(preview) preview.innerHTML = `
        ${renderPersonaSVG({
          personaId: resolved.personaId,
          themeId: resolved.personaTheme,
          seed: resolved.personaSeed,
          size: 96
        })}
        <span class="persona-energy">${energy}</span>
      `;
      const builderPreview = document.getElementById('personaBuilderPreview');
      if(builderPreview) builderPreview.innerHTML = renderPersonaSVG({
        personaId: resolved.personaId,
        themeId: resolved.personaTheme,
        seed: resolved.personaSeed,
        size: 80
      });
      const seedLabel = document.getElementById('personaSeedLabel');
      if(seedLabel) seedLabel.textContent = resolved.personaSeed;
      const themeLabel = document.getElementById('profilePersonaThemeLabel');
      if(themeLabel){
        const themeName = getPersonaTheme(resolved.personaTheme).label;
        themeLabel.textContent = `Energy: ${themeName}`;
      }
    }

    function updatePersonaSelection(selector, activeValue, dataAttr){
      document.querySelectorAll(selector).forEach(btn=>{
        const key = dataAttr ? btn.dataset[dataAttr] : (btn.dataset.personaTheme || btn.dataset.personaId || btn.dataset.themeAccent);
        const isActive = key === activeValue;
        btn.classList.toggle('active', isActive);
      });
    }

    function applyThemeAccentPreview(accentId){
      const color = resolveThemeAccent(accentId);
      const root = document.querySelector('#profileView > div');
      if(root){
        root.style.setProperty('--profile-accent', color);
        root.style.setProperty('--profile-accent-glow', hexToRgba(color, 0.45));
      }
    }

    function updateBioCounter(text){
      const counter = document.getElementById('profileBioCounter');
      if(counter) counter.textContent = `${text.length}/${PROFILE_BIO_MAX}`;
    }

    function updateProfileErrorBanner(){
      const banner = document.getElementById('profileErrorBanner');
      if(!banner) return;
      banner.style.display = profileScriptError ? 'block' : 'none';
    }

    function notifyProfileScriptError(message, detail){
      if(profileScriptError) return;
      profileScriptError = { message, detail };
      console.error('[profile] script error', message, detail);
      updateProfileErrorBanner();
    }

    function bindUiDebugging(){
      if(!DEBUG_UI || debugUiBound) return;
      debugUiBound = true;
      document.addEventListener('click', safeOn('click', (e)=>{
        const target = getEventElement(e) || e.target;
        const path = typeof e.composedPath === 'function' ? e.composedPath() : [];
        console.log('[debug][ui] CLICK', target, { path });
        const probe = document.elementFromPoint(e.clientX, e.clientY);
        if(probe){
          const style = getComputedStyle(probe);
          console.log('[debug][ui] top element', probe, {
            pointerEvents: style.pointerEvents,
            zIndex: style.zIndex,
            position: style.position
          });
          if(path && path.length && !path.includes(probe)){
            console.warn('[debug][ui] INTERCEPTED BY OVERLAY', {
              target,
              probe,
              probeClass: probe.className,
              probeId: probe.id
            });
          }
          let node = probe;
          while(node && node !== document.body){
            const nodeStyle = getComputedStyle(node);
            const zIndex = nodeStyle.zIndex;
            if(nodeStyle.pointerEvents === 'none' || (zIndex !== 'auto' && Number(zIndex) >= 1000)){
              console.log('[debug][ui] ancestor check', node, {
                pointerEvents: nodeStyle.pointerEvents,
                zIndex,
                position: nodeStyle.position
              });
            }
            node = node.parentElement;
          }
        }
      }, { action: 'ui-debug-click' }), true);
    }

    function setProfileSaving(next, context = ''){
      profileUiState.isSaving = !!next;
      if(next){
        debugProfileLog('profile saving start', { context });
      } else {
        debugProfileLog('profile saving end', { context });
      }
    }

    function bindProfileHandlers(){
      if(profileHandlersBound || window.__profileEventsBound) return;
      if(DEBUG_UI) console.log('[debug][profile] bindProfileHandlers');
      window.__profileEventsBound = true;
      profileHandlersBound = true;
      runDelegationSelfTest();
    }

    window.setPersonaTheme = (themeId)=>{
      const persona = updateDraftPersona({ personaTheme: themeId });
      if(!persona) return;
      updatePersonaPreview();
      updatePersonaSelection('[data-persona-theme]', themeId, 'personaTheme');
      persistPersonaSelection(persona);
      console.debug('[persona] set', { personaId: persona.personaId, theme: persona.personaTheme, seed: persona.personaSeed });
      renderProfile();
      setupEventListeners();
    };

    window.setPersonaId = (personaId)=>{
      const persona = updateDraftPersona({ personaId });
      if(!persona) return;
      updatePersonaPreview();
      updatePersonaSelection('[data-persona-id]', personaId, 'personaId');
      persistPersonaSelection(persona);
      console.debug('[persona] set', { personaId: persona.personaId, theme: persona.personaTheme, seed: persona.personaSeed });
    };

    window.randomizePersonaSeed = ()=>{
      const seed = Math.random().toString(36).slice(2, 10);
      const persona = updateDraftPersona({ personaSeed: seed });
      if(!persona) return;
      updatePersonaPreview();
      persistPersonaSelection(persona);
      console.debug('[persona] set', { personaId: persona.personaId, theme: persona.personaTheme, seed: persona.personaSeed });
    };

    window.setThemeAccent = (accentId)=>{
      updateDraftProfile({ themeAccent: accentId });
      applyThemeAccentPreview(accentId);
      updatePersonaSelection('[data-theme-accent]', accentId, 'themeAccent');
      const label = THEME_ACCENTS.find(item=>item.id === accentId)?.label || 'Custom';
      const labelEl = document.getElementById('profileThemeLabel');
      if(labelEl) labelEl.textContent = `Theme: ${label}`;
    };

    window.searchFriends = ()=>{
      handleFriendSearch(null, { explicit: true });
    };

    window.setFriendPanelTab = (tab)=>{
      friendPanelTab = tab === 'requests' ? 'requests' : 'friends';
      renderProfile();
      setupEventListeners();
    };

    window.sendFriendRequest = async (toUid)=>{
      if(!isOnlineProfileMode() || !toUid) return;
      const fromUid = firebaseAuth.currentUser.uid;
      if(fromUid === toUid) return;
      try{
        const requestId = `${fromUid}_${toUid}`;
        const serverTimestamp = firebase?.firestore?.FieldValue?.serverTimestamp;
        const reciprocalId = `${toUid}_${fromUid}`;
        const reciprocalRef = firestore.collection('friendRequests').doc(reciprocalId);
        const reciprocalSnap = await reciprocalRef.get();
        if(reciprocalSnap.exists && reciprocalSnap.data()?.status === 'pending'){
          await acceptFriendRequest(reciprocalId, toUid);
          return;
        }
        await firestore.collection('friendRequests').doc(requestId).set({
          fromUid,
          toUid,
          status: 'pending',
          createdAt: serverTimestamp ? serverTimestamp() : new Date().toISOString()
        }, { merge: true });
        await refreshFriendsData(true);
        await searchProfilesForFriends();
      }catch(err){
        console.warn('friend request failed', err);
        socialFriendSearchError = 'Friend request failed.';
        renderProfile(); setupEventListeners();
      }
    };

    window.acceptFriendRequest = async (requestId, fromUid)=>{
      if(!isOnlineProfileMode()) return;
      try{
        const uid = firebaseAuth.currentUser.uid;
        const serverTimestamp = firebase?.firestore?.FieldValue?.serverTimestamp;
        const batch = firestore.batch();
        const requestRef = firestore.collection('friendRequests').doc(requestId);
        batch.update(requestRef, { status: 'accepted' });
        const reciprocalId = `${uid}_${fromUid}`;
        const reciprocalRef = firestore.collection('friendRequests').doc(reciprocalId);
        const reciprocalSnap = await reciprocalRef.get();
        if(reciprocalSnap.exists && reciprocalSnap.data()?.status === 'pending'){
          batch.update(reciprocalRef, { status: 'accepted' });
        }
        const myFriendRef = firestore.collection('friends').doc(uid).collection('list').doc(fromUid);
        const theirFriendRef = firestore.collection('friends').doc(fromUid).collection('list').doc(uid);
        batch.set(myFriendRef, { friendUid: fromUid, createdAt: serverTimestamp ? serverTimestamp() : new Date().toISOString() }, { merge: true });
        batch.set(theirFriendRef, { friendUid: uid, createdAt: serverTimestamp ? serverTimestamp() : new Date().toISOString() }, { merge: true });
        await batch.commit();
        await refreshFriendsData(true);
        renderProfile(); setupEventListeners();
      }catch(err){
        console.warn('accept request failed', err);
        friendsError = 'Unable to accept request.';
        renderProfile(); setupEventListeners();
      }
    };

    window.rejectFriendRequest = async (requestId)=>{
      if(!isOnlineProfileMode()) return;
      try{
        await firestore.collection('friendRequests').doc(requestId).set({ status: 'declined' }, { merge: true });
        await refreshFriendsData(true);
        renderProfile(); setupEventListeners();
      }catch(err){
        console.warn('reject request failed', err);
        friendsError = 'Unable to reject request.';
        renderProfile(); setupEventListeners();
      }
    };

    window.cancelFriendRequest = async (requestId)=>{
      if(!isOnlineProfileMode()) return;
      try{
        await firestore.collection('friendRequests').doc(requestId).set({ status: 'canceled' }, { merge: true });
        await refreshFriendsData(true);
        renderProfile(); setupEventListeners();
      }catch(err){
        console.warn('cancel request failed', err);
        friendsError = 'Unable to cancel request.';
        renderProfile(); setupEventListeners();
      }
    };

    window.removeFriend = async (friendUid)=>{
      if(!isOnlineProfileMode() || !friendUid) return;
      try{
        const uid = firebaseAuth.currentUser.uid;
        const batch = firestore.batch();
        const myFriendRef = firestore.collection('friends').doc(uid).collection('list').doc(friendUid);
        const theirFriendRef = firestore.collection('friends').doc(friendUid).collection('list').doc(uid);
        batch.delete(myFriendRef);
        batch.delete(theirFriendRef);
        await batch.commit();
        await refreshFriendsData(true);
        renderProfile(); setupEventListeners();
      }catch(err){
        console.warn('remove friend failed', err);
        friendsError = 'Unable to remove friend.';
        renderProfile(); setupEventListeners();
      }
    };

    async function refreshLiveNowUsers(){
      if(liveNowLoading) return;
      liveNowLoading = true;
      liveNowError = '';
      try{
        liveNowUsers = await getLiveUsers();
        liveNowLoadedAt = Date.now();
      }catch(err){
        liveNowError = 'Unable to load live profiles right now.';
      }finally{
        liveNowLoading = false;
        renderProfile();
        setupEventListeners();
      }
    }

    function ensureLiveNowLoaded(){
      const stale = Date.now() - liveNowLoadedAt > 30000;
      if((!liveNowLoadedAt || stale) && !liveNowLoading){
        refreshLiveNowUsers();
      }
    }

    async function ensureRatingLoaded(streamerUid){
      if(!streamerUid || ratingLoadedFor === streamerUid || ratingLoading) return;
      ratingLoadedFor = streamerUid;
      ratingLoading = true;
      ratingDraft = { stars: 0, tags: [], comment: '', hasExisting: false };
      if(!currentUser){
        ratingLoading = false;
        return;
      }
      try{
        const existing = await getExistingRating(streamerUid, currentUser.uid || currentUser.username);
        if(existing){
          ratingDraft = {
            stars: Number(existing.stars) || 0,
            tags: Array.isArray(existing.tags) ? existing.tags : [],
            comment: existing.comment || '',
            hasExisting: true
          };
        }
      }catch(err){
        console.warn('rating preload failed', err);
      }finally{
        ratingLoading = false;
        renderProfile();
        setupEventListeners();
      }
    }

    function updateRatingStarsUI(){
      const starRow = document.getElementById('ratingStarRow');
      if(!starRow) return;
      starRow.querySelectorAll('[data-star]').forEach(btn=>{
        const starVal = Number(btn.dataset.star);
        if(starVal <= ratingDraft.stars){
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
        btn.textContent = starVal <= ratingDraft.stars ? 'â˜…' : 'â˜†';
      });
    }

    function updateRatingTagsUI(){
      const tagRow = document.getElementById('ratingTagRow');
      if(!tagRow) return;
      tagRow.querySelectorAll('[data-tag]').forEach(btn=>{
        const tag = btn.dataset.tag;
        if(ratingDraft.tags.includes(tag)){
          btn.classList.add('border-emerald-400/60','bg-emerald-500/20','text-emerald-100');
          btn.classList.remove('border-white/10','bg-white/5','text-gray-200');
        } else {
          btn.classList.remove('border-emerald-400/60','bg-emerald-500/20','text-emerald-100');
          btn.classList.add('border-white/10','bg-white/5','text-gray-200');
        }
      });
    }

    window.setRatingStar = (value)=>{
      ratingDraft.stars = Number(value) || 0;
      updateRatingStarsUI();
    };

    window.toggleRatingTag = (tag)=>{
      if(!RATING_TAGS.includes(tag)) return;
      if(ratingDraft.tags.includes(tag)){
        ratingDraft.tags = ratingDraft.tags.filter(t=> t !== tag);
      } else {
        ratingDraft.tags = [...ratingDraft.tags, tag];
      }
      updateRatingTagsUI();
    };

    function openFriendProfile(profile){
      if(!profile) return;
      viewingProfile = normalizeProfileShape(profile, profile.uid || profile.username || '');
      setProfileQueryParam(viewingProfile?.username || viewingProfile?.uid || '');
      friendLookupResults = [];
      friendLookupError = '';
      ratingStatusMessage = '';
      ratingStatusTone = 'info';
      ratingLoadedFor = '';
      ratingDraft = { stars: 0, tags: [], comment: '', hasExisting: false };
      view = 'profile';
      render();
      setupEventListeners();
      updateOwnedCount();
    }

    window.selectFriendProfile = (username)=>{
      const pick = friendLookupResults.find(p=>p.username === username || p.uid === username);
      if(!pick){ friendLookupError = 'Profile not available anymore.'; renderProfile(); setupEventListeners(); return; }
      openFriendProfile(pick);
    };

    async function viewFriendProfile(){
      const input = (document.getElementById('friendSearchInput')?.value || '').trim();
      friendSearchTerm = input;
      friendLookupError = '';
      friendLookupResults = [];
      if(!firebaseAuth?.currentUser){
        friendLookupError = 'Sign in required to view other profiles.';
        renderProfile(); setupEventListeners(); return;
      }
      if(!input){ friendLookupError = 'Enter a DJ name or username to view.'; renderProfile(); setupEventListeners(); return; }
      const normalizedInput = normalizeUsernameLower(input);
      const tryMatches = async (field, value)=> await fetchProfilesByField(field, value);
      try{
        const usernameHits = await tryMatches('usernameLower', normalizedInput);
        if(usernameHits.length === 1) return openFriendProfile(usernameHits[0]);
        if(usernameHits.length > 1){ friendLookupResults = usernameHits; renderProfile(); setupEventListeners(); return; }

        const djHits = await tryMatches('djNameLower', normalizedInput);
        if(djHits.length === 1) return openFriendProfile(djHits[0]);
        if(djHits.length > 1){ friendLookupResults = djHits; renderProfile(); setupEventListeners(); return; }

        if(input.includes('@')){
          const emailHits = await tryMatches('email');
          if(emailHits.length === 1) return openFriendProfile(emailHits[0]);
          if(emailHits.length > 1){ friendLookupResults = emailHits; renderProfile(); setupEventListeners(); return; }
        }
        friendLookupError = `No profile found for â€˜${input}â€™`;
      }catch(err){
        friendLookupError = 'Lookup failed. Please try again.';
      }
      renderProfile();
      setupEventListeners();
    }

    window.viewLiveProfile = async (username)=>{
      if(!username) return;
      if(!firebaseAuth?.currentUser){
        friendLookupError = 'Sign in required to view other profiles.';
        renderProfile(); setupEventListeners(); return;
      }
      const profile = await loadProfileForViewing(username);
      if(profile){
        openFriendProfile(profile);
      } else {
        friendLookupError = `No profile found for â€˜${username}â€™`;
        renderProfile(); setupEventListeners();
      }
    };

    window.submitRating = async ()=>{
      ratingStatusMessage = '';
      ratingStatusTone = 'info';
      if(!currentUser){
        ratingStatusMessage = 'Sign in required to rate this DJ.';
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      if(!viewingProfile){
        ratingStatusMessage = 'Open a profile to rate.';
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      const streamerUid = viewingProfile.uid || viewingProfile.username;
      if(!streamerUid){
        ratingStatusMessage = 'Missing streamer profile.';
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      const raterUid = currentUser.uid || currentUser.username;
      const stars = Number(ratingDraft.stars) || 0;
      if(stars < 1 || stars > 5){
        ratingStatusMessage = 'Select a 1â€“5 star rating.';
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      const comment = (ratingDraft.comment || '').trim();
      if(comment.length > RATING_MAX_COMMENT){
        ratingStatusMessage = `Comment too long. Max ${RATING_MAX_COMMENT} characters.`;
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      const tags = Array.isArray(ratingDraft.tags) ? ratingDraft.tags.filter(tag=> RATING_TAGS.includes(tag)) : [];
      if(tags.length !== (ratingDraft.tags || []).length){
        ratingStatusMessage = 'Remove invalid tags before submitting.';
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      const rateCheck = checkRatingUpdateLimit(streamerUid, raterUid);
      if(!rateCheck.allowed){
        const minutes = Math.ceil((rateCheck.retryAt - Date.now()) / 60000);
        ratingStatusMessage = `Too many updates. Try again in ${minutes} min.`;
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      ratingSubmitting = true;
      renderProfile(); setupEventListeners();
      try{
        const previousRating = await getExistingRating(streamerUid, raterUid);
        const updatedAt = new Date().toISOString();
        const ratingPayload = { stars, tags, comment, updatedAt };
        if(firestore){
          const serverTimestamp = firebase?.firestore?.FieldValue?.serverTimestamp;
          const collection = getProfileCollection();
          if(!collection) throw new Error('Profile collection unavailable');
          await collection.doc(streamerUid).collection('ratings').doc(raterUid)
            .set({ ...ratingPayload, updatedAt: serverTimestamp ? serverTimestamp() : updatedAt }, { merge: true });
          const profileDoc = await collection.doc(streamerUid).get();
          const baseProfile = profileDoc.exists ? normalizeProfileShape(profileDoc.data(), streamerUid) : viewingProfile;
          const aggregates = updateAggregatesWithRating(baseProfile || {}, previousRating?.stars, stars);
          await collection.doc(streamerUid).set(aggregates, { merge: true });
          viewingProfile = viewingProfile && (viewingProfile.username === streamerUid || viewingProfile.uid === streamerUid)
            ? { ...viewingProfile, ...aggregates }
            : viewingProfile;
        } else {
          const ratings = getLocalRatings();
          ratings[streamerUid] = ratings[streamerUid] || {};
          ratings[streamerUid][raterUid] = ratingPayload;
          saveLocalRatings(ratings);
          const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');
          const existingProfile = normalizeProfileShape(profiles[streamerUid] || viewingProfile || { username: streamerUid }, streamerUid);
          const aggregates = updateAggregatesWithRating(existingProfile || {}, previousRating?.stars, stars);
          const mergedProfile = { ...(profiles[streamerUid] || {}), ...existingProfile, ...aggregates };
          profiles[streamerUid] = mergedProfile;
          localStorage.setItem('userProfiles', JSON.stringify(profiles));
          if(viewingProfile && (viewingProfile.username === streamerUid || viewingProfile.uid === streamerUid)){
            viewingProfile = { ...viewingProfile, ...aggregates };
          }
        }
        recordRatingUpdate(streamerUid, raterUid, rateCheck.updates || [], rateCheck.logs || {});
        ratingDraft.hasExisting = true;
        ratingStatusMessage = 'Rating saved!';
        ratingStatusTone = 'success';
        refreshLiveNowUsers();
      }catch(err){
        console.error('rating submit failed', err);
        ratingStatusMessage = 'Rating failed. Please try again.';
        ratingStatusTone = 'error';
      }finally{
        ratingSubmitting = false;
        renderProfile();
        setupEventListeners();
      }
    };

    function setProfileQueryParam(value){
      const params = new URLSearchParams(window.location.search);
      if(value) params.set('profile', value); else params.delete('profile');
      const query = params.toString();
      const newUrl = `${location.pathname}${query ? `?${query}` : ''}${location.hash}`;
      window.history.replaceState({}, '', newUrl);
    }
    function clearViewedProfile(){
      viewingProfile = null;
      friendLookupResults = [];
      friendLookupError = '';
      friendSearchTerm = '';
      ratingStatusMessage = '';
      ratingStatusTone = 'info';
      ratingLoadedFor = '';
      ratingDraft = { stars: 0, tags: [], comment: '', hasExisting: false };
      setProfileQueryParam(null);
    }

    // --------------------- UI: Landing / Auth ------------------------
    function showLandingPage(){
      const camelotOrder = Array.from({ length: 12 }, (_, i) => i + 1);
      const camelotBStops = camelotOrder
        .map((num, index) => {
          const start = index * 30;
          const end = (index + 1) * 30;
          return `${camelotColors[`${num}B`] || '#0ea5e9'} ${start}deg ${end}deg`;
        })
        .join(',');
      const camelotAStops = camelotOrder
        .map((num, index) => {
          const start = index * 30;
          const end = (index + 1) * 30;
          return `${camelotColors[`${num}A`] || '#8b5cf6'} ${start}deg ${end}deg`;
        })
        .join(',');
      const camelotLabels = camelotOrder
        .map((num, index) => `
          <div class="camelot-wheel-label camelot-wheel-label--outer" style="--i:${index}">${num}B</div>
          <div class="camelot-wheel-label camelot-wheel-label--inner" style="--i:${index}">${num}A</div>
        `)
        .join('');
      document.getElementById('app').innerHTML = `
        <div class="min-h-screen py-12 px-6">
          <div class="max-w-6xl mx-auto">
            <div class="text-center mb-16">
              <div class="flex justify-center mb-6">
                <div class="w-32 h-32 bg-gradient-to-br from-pink-500 via-purple-500 to-cyan-500 rounded-full flex items-center justify-center text-6xl vinyl-spin">ðŸŽ§</div>
              </div>
              <h1 class="text-5xl md:text-6xl font-bold text-white graffiti-text mb-4">${BRAND.APP_NAME.toUpperCase()}</h1>
              <p class="text-xl md:text-2xl text-cyan-300 mb-6">Create Epic Mashups & DJ Like a Pro on the Jam Stage!</p>
              <div class="mt-6">
                <button onclick="hideLanding()" class="px-8 py-4 bg-gradient-to-r from-pink-500 via-purple-500 to-cyan-500 rounded-xl font-bold text-white text-xl md:text-2xl bounce-icon shadow-lg">ðŸŽµ START MIXING NOW</button>
              </div>
            </div>
            <div class="bg-black/60 backdrop-blur-xl border border-pink-500/30 rounded-2xl p-6 md:p-8 mb-12">
              <div class="flex flex-col lg:flex-row items-center gap-8">
                <div class="flex-shrink-0">
                  <div class="camelot-wheel-graphic is-mini">
                    <div class="camelot-wheel-ring" style="background: conic-gradient(${camelotBStops});"></div>
                    <div class="camelot-wheel-ring camelot-wheel-ring-a" style="background: conic-gradient(${camelotAStops});"></div>
                    <div class="camelot-wheel-center">Camelot Wheel</div>
                    ${camelotLabels}
                  </div>
                  <p class="text-center text-xs text-cyan-300 mt-4">The Camelot Wheel in Action</p>
                </div>
                <div class="flex-1">
                  <h2 class="text-2xl md:text-3xl font-bold text-white mb-4 graffiti-text">ðŸŽ›ï¸ The Secret: The Camelot Wheel</h2>
                  <p class="text-gray-300 mb-4 text-base md:text-lg">Professional DJs use the Camelot Wheel to create seamless mashups. It's a color-coded system that shows which songs are harmonically compatible.</p>
                  <div class="space-y-3 text-gray-300 text-sm md:text-base">
                    <div class="flex items-start gap-3"><span class="text-2xl">âœ…</span><div><strong class="text-cyan-300">Same Number = Perfect Match!</strong><br/><span class="text-sm">Example: 8B â†’ 8B</span></div></div>
                    <div class="flex items-start gap-3"><span class="text-2xl">âœ…</span><div><strong class="text-cyan-300">A/B Switch = Energy Shift</strong><br/><span class="text-sm">Example: 8B â†’ 8A</span></div></div>
                    <div class="flex items-start gap-3"><span class="text-2xl">âœ…</span><div><strong class="text-cyan-300">Â±1 Number = Smooth Blend</strong><br/><span class="text-sm">Example: 8B â†’ 9B or 7B</span></div></div>
                  </div>
                </div>
              </div>
            </div>

            <div class="text-center">
              <button onclick="hideLanding()" class="px-8 md:px-12 py-4 md:py-5 bg-gradient-to-r from-pink-500 via-purple-500 to-cyan-500 rounded-xl font-bold text-white text-2xl md:text-3xl shadow-2xl">ðŸŽµ LET'S MIX!</button>
            </div>
          </div>
        </div>
      `;
    }
    window.hideLanding = () => { showLoginScreen(); };

    // -------------------- Login / Profile handlers ---------------------
    function showLoginScreen(){
      setAppBootState(APP_BOOT_STATES.signedOut);
      // default auth mode
      setTimeout(()=>{ try{ if(window.setAuthMode) window.setAuthMode('signin'); }catch(e){} }, 50);
      const camelotOrder = Array.from({ length: 12 }, (_, i) => i + 1);
      const camelotBStops = camelotOrder
        .map((num, index) => {
          const start = index * 30;
          const end = (index + 1) * 30;
          return `${camelotColors[`${num}B`] || '#0ea5e9'} ${start}deg ${end}deg`;
        })
        .join(',');
      const camelotAStops = camelotOrder
        .map((num, index) => {
          const start = index * 30;
          const end = (index + 1) * 30;
          return `${camelotColors[`${num}A`] || '#8b5cf6'} ${start}deg ${end}deg`;
        })
        .join(',');
      const camelotLabels = camelotOrder
        .map((num, index) => `
          <div class="camelot-wheel-label camelot-wheel-label--outer" style="--i:${index}">${num}B</div>
          <div class="camelot-wheel-label camelot-wheel-label--inner" style="--i:${index}">${num}A</div>
        `)
        .join('');

      document.getElementById('app').innerHTML = `
        <div class="min-h-screen flex items-center justify-center p-6">
          <div class="w-full max-w-6xl">
            <div class="text-center mb-10">
              <div class="w-24 h-24 bg-gradient-to-br from-pink-500 via-purple-500 to-cyan-500 rounded-full flex items-center justify-center text-5xl mx-auto mb-4 vinyl-spin">ðŸŽ§</div>
              <h1 class="text-4xl font-bold text-white graffiti-text mb-2">${BRAND.APP_NAME.toUpperCase()}</h1>
              <p class="text-cyan-300">Your Personal DJ Profile</p>
            </div>

            <div class="login-grid mx-auto">
              <div class="bg-black/60 backdrop-blur-xl border border-cyan-500/30 rounded-2xl p-8 shadow-2xl h-full flex flex-col">
                <h2 class="text-2xl font-bold text-white mb-6 text-center">Sign In / Create Profile</h2>
                ${!firebaseEnabled ? `<div class="mb-4 p-3 rounded-lg bg-yellow-500/20 border border-yellow-500/50 text-yellow-100 text-sm text-center">Firebase not configured â€” using local profiles.</div>` : ''}

                ${firebaseEnabled ? `
                  <div class="mb-5">
                    <div class="flex gap-2 bg-black/30 p-1 rounded-xl border border-cyan-500/20">
                      <button type="button" id="tabSignIn" onclick="setAuthMode('signin')" class="flex-1 px-3 py-2 rounded-lg font-bold text-white bg-white/10">Already a member</button>
                      <button type="button" id="tabSignUp" onclick="setAuthMode('signup')" class="flex-1 px-3 py-2 rounded-lg font-bold text-white opacity-80">Sign up</button>
                    </div>
                    <p class="text-xs text-gray-300 mt-3 text-center">
                      Cloud sync works after you create an account once. Sign in to access your profile and owned songs.
                    </p>
                  </div>

                  <form onsubmit="handleFirebaseAuth(event)" class="space-y-4" autocomplete="on">
                    <input type="hidden" id="authMode" value="signin" />

                    <div>
                      <label class="block text-sm text-gray-300 mb-2">Email</label>
                      <input id="email" type="email" required placeholder="you@example.com"
                        class="w-full px-4 py-3 bg-black/40 border border-gray-600 rounded-lg text-white" />
                    </div>

                    <div>
                      <label class="block text-sm text-gray-300 mb-2">Password</label>
                      <input id="password" type="password" required minlength="6" placeholder="password"
                        class="w-full px-4 py-3 bg-black/40 border border-gray-600 rounded-lg text-white" />
                    </div>

                    <div id="confirmWrap" style="display:none">
                      <label class="block text-sm text-gray-300 mb-2">Confirm Password</label>
                      <input id="passwordConfirm" type="password" placeholder="confirm password"
                        class="w-full px-4 py-3 bg-black/40 border border-gray-600 rounded-lg text-white" />
                      <p class="text-xs text-gray-400 mt-2">Tip: use at least 6 characters.</p>
                    </div>

                    <div>
                      <button type="submit" id="authSubmit"
                        class="w-full px-4 py-3 bg-gradient-to-r from-pink-500 to-purple-500 rounded-lg font-bold text-white">
                        Sign In
                      </button>
                    </div>

                    <div class="text-center">
                      <button type="button" onclick="forgotPassword()" class="text-xs text-cyan-300 hover:underline">Forgot password?</button>
                    </div>
                    <div id="authError" class="mt-3 text-sm text-red-200 bg-red-900/50 border border-red-500/60 rounded-lg p-3" style="display:none"></div>
                  </form>
                ` : `
                  <form id="localAuthForm" class="space-y-4" autocomplete="off">
                    <div><label class="block text-sm text-gray-300 mb-2">Username</label><input id="username" type="text" required minlength="2" maxlength="24" placeholder="Enter your username" class="w-full px-4 py-3 bg-black/40 border border-gray-600 rounded-lg text-white" /></div>
                    <div><label class="block text-sm text-gray-300 mb-2">DJ Name (optional)</label><input id="djName" type="text" maxlength="32" placeholder="e.g., DJ Spinner" class="w-full px-4 py-3 bg-black/40 border border-gray-600 rounded-lg text-white" /></div>
                    <button type="submit" id="enterMixBtn" class="w-full px-6 py-3 bg-gradient-to-r from-pink-500 via-purple-500 to-cyan-500 rounded-lg font-bold text-white text-lg">ðŸŽµ Enter the Mix</button>
                    <div id="localAuthError" class="mt-3 text-sm text-red-200 bg-red-900/50 border border-red-500/60 rounded-lg p-3" style="display:none"></div>
                  </form>
                `}
                <div class="mt-6 pt-6 border-t border-gray-700">
                  <p class="text-xs text-gray-400 text-center">âš ï¸ Epic Games doesn't share inventory; mark songs you own manually.</p>
                </div>
              </div>

              <div class="camelot-panel backdrop-blur-xl border border-pink-500/30 rounded-2xl p-8 h-full flex flex-col justify-between gap-6">
                <div>
                  <div class="camelot-wheel-graphic">
                    <div class="camelot-wheel-ring" style="background: conic-gradient(${camelotBStops});"></div>
                    <div class="camelot-wheel-ring camelot-wheel-ring-a" style="background: conic-gradient(${camelotAStops});"></div>
                    <div class="camelot-wheel-center">Camelot Wheel</div>
                    ${camelotLabels}
                  </div>
                  <h2 class="text-2xl font-bold text-white mb-2 text-center">Welcome to Festival Jam Mixer</h2>
                  <p class="text-sm text-cyan-200 text-center">Create smoother mashups using Camelot key &amp; BPM</p>
                </div>

                <div class="space-y-3 text-sm text-gray-200">
                  <div class="flex items-start gap-3"><span class="text-lg">âœ¨</span><div><strong class="text-cyan-300">Same Number â†’ Perfect Match</strong><div class="text-xs text-gray-300">8B â†’ 8B</div></div></div>
                  <div class="flex items-start gap-3"><span class="text-lg">âš¡</span><div><strong class="text-cyan-300">A/B Switch â†’ Energy Shift</strong><div class="text-xs text-gray-300">8B â†’ 8A</div></div></div>
                  <div class="flex items-start gap-3"><span class="text-lg">ðŸ”</span><div><strong class="text-cyan-300">Â±1 Number â†’ Smooth Blend</strong><div class="text-xs text-gray-300">8B â†’ 9B / 7B</div></div></div>
                </div>

                <div class="pt-4 border-t border-white/10 text-xs text-gray-300 text-center">
                  Sign in to sync your owned tracks across devices.
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
      const localForm = document.getElementById('localAuthForm');
      if(localForm && !localForm.dataset.bound){
        localForm.dataset.bound = 'true';
        localForm.addEventListener('submit', onEnterMixSubmit);
      }
    }

      // -------------------- Firebase Auth UI helpers ---------------------
    window.setAuthMode = (mode) => {
      const m = (mode === 'signup') ? 'signup' : 'signin';
      const authMode = document.getElementById('authMode');
      if (!authMode) return;
      authMode.value = m;

      const tabIn = document.getElementById('tabSignIn');
      const tabUp = document.getElementById('tabSignUp');
      const confirmWrap = document.getElementById('confirmWrap');
      const submit = document.getElementById('authSubmit');
      const confirmInput = document.getElementById('passwordConfirm');

      if (m === 'signup') {
        if (tabUp) { tabUp.classList.add('bg-white/10'); tabUp.classList.remove('opacity-80'); }
        if (tabIn) { tabIn.classList.remove('bg-white/10'); tabIn.classList.add('opacity-80'); }
        if (confirmWrap) confirmWrap.style.display = 'block';
        if (submit) submit.textContent = 'Create Account';
        if (confirmInput) { confirmInput.required = true; confirmInput.setAttribute('minlength','6'); confirmInput.value = ''; }
      } else {
        if (tabIn) { tabIn.classList.add('bg-white/10'); tabIn.classList.remove('opacity-80'); }
        if (tabUp) { tabUp.classList.remove('bg-white/10'); tabUp.classList.add('opacity-80'); }
        if (confirmWrap) confirmWrap.style.display = 'none';
        if (submit) submit.textContent = 'Sign In';
        if (confirmInput) { confirmInput.required = false; confirmInput.value = ''; }
      }
    };

    function getLocalDeviceId(){
      let localId = localStorage.getItem('localDeviceUserId');
      if(!localId){
        localId = 'local_' + Math.random().toString(36).slice(2,10);
        localStorage.setItem('localDeviceUserId', localId);
      }
      return localId;
    }

    function slugifyLocalUsername(value){
      return (value || '')
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9 _-]+/g,'')
        .replace(/\s+/g,'-')
        .replace(/-+/g,'-')
        .replace(/^[-_]+|[-_]+$/g,'');
    }

    function getSavedUsername(){
      return (localStorage.getItem('currentUser') || localStorage.getItem('activeProfileUid') || '').trim();
    }

    function getActiveProfile(){
      if(currentUser) return currentUser;
      const activeUid = localStorage.getItem('activeProfileUid');
      const firebaseUid = firebaseAuth?.currentUser?.uid || null;
      const cacheUid = firebaseUid || activeUid || null;
      const cachedProfile = cacheUid ? readProfileCache(cacheUid) : (window.profileStore?.readLocalProfileCache?.() || null);
      if(cachedProfile && window.profileStore?.hasMeaningfulProfileData?.(cachedProfile)){
        const localOwned = firebaseUid ? [] : readUserStorageJson('ownedTracks', cachedProfile, []);
        const localSetlist = firebaseUid ? [] : readUserStorageJson('setlist', cachedProfile, []);
        const localGenre = firebaseUid ? {} : readUserStorageJson('genreOverrides', cachedProfile, {});
        const ownedCache = cachedProfile.uid ? readOwnedTracksCache(cachedProfile.uid) : null;
        if(ownedCache?.trackIds?.length){
          cachedProfile.ownedTracks = ownedCache.trackIds;
        }
        if(localOwned.length){
          cachedProfile.ownedTracks = normalizeOwnedList([...(cachedProfile.ownedTracks || []), ...localOwned]);
        }
        if(localSetlist.length){
          cachedProfile.setlist = normalizeSetlistIds([...(cachedProfile.setlist || []), ...localSetlist]);
        }
        if(Object.keys(localGenre || {}).length){
          cachedProfile.genreOverrides = { ...(cachedProfile.genreOverrides || {}), ...localGenre };
        }
        const fallbackUid = cachedProfile.uid || activeUid || getLocalDeviceId();
        return normalizeProfileShape({
          ...cachedProfile,
          uid: fallbackUid,
          username: cachedProfile.username || cachedProfile.djName || 'Guest',
          djName: cachedProfile.djName || cachedProfile.username || 'Guest'
        }, fallbackUid);
      }
      const localProfileRaw = localStorage.getItem('localProfile');
      if(localProfileRaw){
        try{
          const parsed = JSON.parse(localProfileRaw);
          const normalized = normalizeProfileShape(parsed, parsed?.uid || activeUid);
          if(normalized && (!activeUid || normalized.uid === activeUid)) return normalized;
        }catch(err){ console.warn('[auth] localProfile parse failed', err); }
      }
      const savedId = activeUid || getSavedUsername();
      if(!savedId) return null;
      try{
        const profiles = JSON.parse(localStorage.getItem('userProfiles')||'{}');
        if(profiles[savedId]) return normalizeProfileShape(profiles[savedId], savedId);
      }catch(err){ console.warn('[auth] stored profiles parse failed', err); }
      return null;
    }

    async function enterAppWithProfile(profile, { loadEpic = false, loadOverrides = false, skipPersist = false } = {}){
      if(!profile) return;
      await applyProfileToState(profile, { loadEpic, loadOverrides, skipPersist });
    }

    function setLocalAuthError(message){
      const errorBox = document.getElementById('localAuthError');
      if(errorBox){
        errorBox.textContent = message;
        errorBox.style.display = message ? 'block' : 'none';
      }
    }

    async function onEnterMixSubmit(event){
      event.preventDefault();
      console.debug('[auth] Enter Mix clicked');
      const submitBtn = document.getElementById('enterMixBtn');
      const originalLabel = submitBtn?.textContent || 'ðŸŽµ Enter the Mix';
      if(submitBtn){
        submitBtn.disabled = true;
        submitBtn.classList.add('opacity-70');
        submitBtn.textContent = 'Entering...';
      }
      const buttonTimeout = setTimeout(() => {
        if(submitBtn){
          submitBtn.disabled = false;
          submitBtn.classList.remove('opacity-70');
          submitBtn.textContent = originalLabel;
        }
      }, 300);
      setLocalAuthError('');
      try{
        const usernameInput = document.getElementById('username');
        const djNameInput = document.getElementById('djName');
        const username = (usernameInput?.value || '').trim();
        const djNameRaw = (djNameInput?.value || '').trim();
        if(username.length < 2){
          setLocalAuthError('Username must be at least 2 characters.');
          return;
        }
        if(username.length > 24){
          setLocalAuthError('Username must be 24 characters or fewer.');
          return;
        }
        if(!/^[A-Za-z0-9 _-]+$/.test(username)){
          setLocalAuthError('Username can only use letters, numbers, spaces, underscores, or hyphens.');
          return;
        }
        if(djNameRaw.length > 32){
          setLocalAuthError('DJ Name must be 32 characters or fewer.');
          return;
        }
        const slug = slugifyLocalUsername(username);
        if(!slug){
          setLocalAuthError('Choose a username with letters or numbers.');
          return;
        }
        const existingProfile = await loadUserProfile(username);
        const baseProfile = existingProfile || {
          ownedTracks: [],
          setlist: [],
          bandMembers: [],
          genreOverrides: {},
          streamUrl: '',
          isLive: false,
          liveStartedAt: null,
          avgRating: 0,
          ratingCount: 0,
          ratingBreakdown: { 1:0, 2:0, 3:0, 4:0, 5:0 },
          bio: '',
          themeAccent: THEME_ACCENTS[0].id,
          personaId: 'turntablist',
          personaTheme: 'neonPop',
          personaSeed: username,
          isPublic: true,
          allowFriendRequests: true,
          usernameLower: normalizeUsernameLower(username),
          djNameLower: normalizeUsernameLower(djNameRaw || username),
          searchNameLower: normalizeUsernameLower(username),
          searchTokens: buildSearchTokens(username),
          isAdmin: false,
          tour: {}
        };
        const now = Date.now();
        const profile = {
          ...baseProfile,
          uid: baseProfile.uid || `local:${slug}`,
          username,
          djName: djNameRaw || username,
          createdAt: baseProfile.createdAt || now,
          updatedAt: now,
          mode: 'local'
        };
        currentUser = profile;
        await persistProfileRobust(profile, { force: true, reason: 'system' });
        enforcePostLoginDefaults();
        view = DEFAULT_VIEW;
        setAppBootState(APP_BOOT_STATES.ready);
        render();
        setupEventListeners();
        recordBootStep('READY rendered');
        void loadAppData({ showBootScreen: false, allowProfileAutoOpen: false });
      }catch(err){
        console.error('[auth] enter failed', err);
        setLocalAuthError('Couldnâ€™t enter the mix. Check console for details.');
      }finally{
        clearTimeout(buttonTimeout);
        if(submitBtn){
          submitBtn.disabled = false;
          submitBtn.classList.remove('opacity-70');
          submitBtn.textContent = originalLabel;
        }
      }
    }

    window.forgotPassword = async () => {
      if (!firebaseAuth) return alert('Firebase not ready yet.');
      const email = (document.getElementById('email')?.value || '').trim();
      if (!email) return alert('Type your email first, then click "Forgot password?"');
      try {
        await firebaseAuth.sendPasswordResetEmail(email);
        alert('Password reset email sent (check inbox/spam).');
      } catch (e) {
        alert('Could not send reset email: ' + (e.message || e));
      }
    };

    function getOAuthCallbackUrl(provider){
      if(provider === 'epic') return `${window.location.origin}/oauth-callback.html?oauth=epic`;
      return window.location.origin;
    }

    function cacheEpicLink(linkData){
      if(!firebaseAuth?.currentUser) return;
      try{
        const uid = firebaseAuth.currentUser.uid;
        if(currentUser?.uid !== uid) return;
        currentUser.oauth = currentUser.oauth || {};
        if(linkData){
          currentUser.oauth.epic = linkData;
        } else if(currentUser.oauth.epic){
          delete currentUser.oauth.epic;
        }
        persistProfileRobust(currentProfileFromState(), { force: true }).catch(()=>{});
      }catch(e){ /* non-fatal cache failure */ }
    }

    async function fetchEpicLinkStatus(){
      if(!firebaseAuth?.currentUser) return null;
      let idToken;
      try{ idToken = await firebaseAuth.currentUser.getIdToken(); } catch(e){ return null; }
      try{
        const resp = await fetch('/api/oauth/epic/status', {
          headers: { 'Authorization': `Bearer ${idToken}` },
          credentials: 'include'
        });
        if(resp.status === 401){
          currentUser = currentUser || {};
          if(currentUser.oauth?.epic){ delete currentUser.oauth.epic; cacheEpicLink(null); }
          return { linked: false, error: 'Authentication required' };
        }
        if(!resp.ok) return null;
        const data = await resp.json();
        currentUser = currentUser || {};
        currentUser.oauth = currentUser.oauth || {};
        if(data.linked){
          const epicData = {
            linked: true,
            epicAccountId: data.epicAccountId || null,
            displayName: data.displayName || null,
            linkedAt: data.linkedAt || Date.now(),
            lastValidatedAt: data.lastValidatedAt || Date.now()
          };
          currentUser.oauth.epic = epicData;
          cacheEpicLink(epicData);
        } else if(currentUser.oauth.epic){
          delete currentUser.oauth.epic;
          cacheEpicLink(null);
        }
        return data;
      }catch(e){ console.warn('Epic status fetch failed', e); return null; }
    }

    window.startOAuth = (provider) => {
      if(!firebaseAuth?.currentUser){ alert('Sign in first to link accounts.'); return; }
      if(provider === 'epic'){
        const redirect = encodeURIComponent(getOAuthCallbackUrl(provider));
        window.location.href = `/api/oauth/epic/start?redirect_uri=${redirect}`;
        return;
      }
      alert('Unsupported OAuth provider.');
    };

    window.unlinkOAuth = async (provider) => {
      if(provider !== 'epic') return alert('Unsupported OAuth provider.');
      if(!firebaseAuth?.currentUser){ alert('Sign in first to unlink.'); return; }
      try{
        const token = await firebaseAuth.currentUser.getIdToken();
        const resp = await fetch('/api/oauth/epic/unlink', {
          method:'POST',
          headers:{ 'Authorization': `Bearer ${token}` },
          credentials: 'include'
        });
        if(!resp.ok){
          alert('Could not unlink Epic right now.');
          return;
        }
        await fetchEpicLinkStatus();
        await persistCurrentUserProfile();
        alert('Epic account unlinked.');
        renderProfile(); setupEventListeners();
      }catch(err){
        console.warn('Unlink epic failed', err);
        alert('Could not unlink Epic right now.');
      }
    };

    function hasMeaningfulData(profile){
      if(!profile) return false;
      return (profile.ownedTracks && profile.ownedTracks.length) ||
        (profile.setlist && profile.setlist.length) ||
        (profile.genreOverrides && Object.keys(profile.genreOverrides).length) ||
        (profile.bandMembers && profile.bandMembers.length);
    }

    async function promptLocalImport(firebaseUsername){
      const localOwned = JSON.parse(localStorage.getItem('ownedTracks') || '[]');
      const legacyLocalSet = JSON.parse(localStorage.getItem('setlist') || '[]');
      const localSetIds = normalizeSetlistIds(JSON.parse(localStorage.getItem('setlistIds') || '[]'));
      const localSet = localSetIds.length ? localSetIds : normalizeSetlistIds(legacyLocalSet);
      const localGenre = JSON.parse(localStorage.getItem('genreOverrides') || '{}');
      const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');

      const candidateProfiles = Object.entries(profiles)
        .filter(([name, data]) => name && name !== firebaseUsername && hasMeaningfulData(data));
      const deviceDataAvailable = (localOwned && localOwned.length) || (localSet && localSet.length) || (localGenre && Object.keys(localGenre).length);
      if(!candidateProfiles.length && !deviceDataAvailable) return null;

      return await new Promise((resolve)=>{
        const modal = document.createElement('div');
        modal.id = 'importModal';
        modal.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:30000;backdrop-filter:blur(6px);padding:12px;';
        const optionsHtml = candidateProfiles.length ?
          `<label class="block text-sm text-gray-200 mb-2">Import from saved profile</label>
            <select id="importProfileSelect" class="w-full px-3 py-2 rounded-lg bg-black/60 border border-cyan-500/30 text-white mb-3">
              ${candidateProfiles.map(([name])=>`<option value="${name}">${name}</option>`).join('')}
            </select>` : '';
        modal.innerHTML = `
          <div class="w-full max-w-md bg-gradient-to-b from-black/85 to-black/90 border border-cyan-500/30 rounded-2xl p-6 text-white shadow-2xl">
            <h3 class="text-xl font-bold mb-2">Import your local data?</h3>
            <p class="text-sm text-gray-200 mb-4">We found local data on this device. Import into this account?</p>
            ${optionsHtml || ''}
            ${deviceDataAvailable ? '<p class="text-xs text-gray-300 mb-4">Tip: If you used this app on this device before, choose Import to keep your owned songs and setlists.</p>' : ''}
            <div class="flex gap-2 justify-end">
              <button id="importSkip" class="px-4 py-2 rounded-lg bg-gray-700 text-white">Skip</button>
              <button id="importConfirm" class="px-4 py-2 rounded-lg bg-gradient-to-r from-pink-500 to-cyan-500 text-white font-bold">Import</button>
            </div>
          </div>`;
        document.body.appendChild(modal);
        const cleanup = ()=>{ modal.remove(); };
        modal.querySelector('#importSkip').onclick = ()=>{ cleanup(); resolve(null); };
        modal.querySelector('#importConfirm').onclick = ()=>{
          const choice = modal.querySelector('#importProfileSelect')?.value || null;
          cleanup();
          if(choice && profiles[choice]) return resolve(profiles[choice]);
          if(deviceDataAvailable){
            return resolve({
              ownedTracks: localOwned,
              setlist: localSet,
              genreOverrides: localGenre
            });
          }
          resolve(null);
        };
      });
    }

    async function hydrateFromLocalCacheOnly(){
      const cached = window.profileStore?.readLocalProfileCache?.() || {};
      const fallbackUid = cached.uid || getLocalDeviceId();
      const fallbackName = cached.djName || cached.email || 'Guest';
      const ownedCache = readOwnedTracksCache(fallbackUid);
      const localOwned = readUserStorageJson('ownedTracks', cached, []);
      const localSetlist = readUserStorageJson('setlist', cached, []);
      const localGenre = readUserStorageJson('genreOverrides', cached, {});
      const hydrated = normalizeProfileShape({
        ...cached,
        uid: fallbackUid,
        username: cached.username || fallbackName,
        djName: cached.djName || fallbackName,
        ownedTracks: normalizeOwnedList([...(ownedCache?.trackIds || []), ...(cached.ownedTracks || []), ...localOwned]),
        setlist: normalizeSetlistIds([...(cached.setlist || []), ...localSetlist]),
        genreOverrides: { ...(cached.genreOverrides || {}), ...(localGenre || {}) }
      }, fallbackUid);
      if(window.profileStore?.hasMeaningfulProfileData?.(hydrated)) return hydrated;
      return null;
    }

    function getLegacyProfileCandidates({ email } = {}){
      const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');
      const candidateKeys = new Set();
      const storedKey = getSavedUsername();
      if(storedKey) candidateKeys.add(storedKey);
      const emailPrefix = (email || '').split('@')[0];
      if(emailPrefix) candidateKeys.add(emailPrefix);
      const candidates = [];
      candidateKeys.forEach((key)=>{
        if(profiles[key]) candidates.push(normalizeProfileShape(profiles[key], key));
      });
      return candidates;
    }

    function getLegacyProfileForMigration(uid, email){
      if(hasCompletedProfileMigration(uid)){
        return { legacyProfile: {}, usedLegacy: false };
      }
      let legacyProfile = readLegacyLocalProfile();
      const legacyCandidates = getLegacyProfileCandidates({ email });
      legacyCandidates.forEach((candidate)=>{
        legacyProfile = mergeProfileSources({ localProfile: legacyProfile, snapshotProfile: null, remoteProfile: candidate });
      });
      const usedLegacyProfile = window.profileStore?.hasMeaningfulProfileData
        ? window.profileStore.hasMeaningfulProfileData(legacyProfile)
        : hasMeaningfulData(legacyProfile);
      const usedLegacy = usedLegacyProfile || (legacyProfile.ownedTracks && legacyProfile.ownedTracks.length);
      return { legacyProfile, usedLegacy };
    }

    function resolveOwnedTracksFromCacheCandidates(candidates){
      const uniqueCandidates = Array.from(new Set((candidates || []).filter(Boolean)));
      let best = null;
      uniqueCandidates.forEach((candidate)=>{
        const snapshot = readOwnedTracksCache(candidate);
        if(snapshot?.trackIds?.length && (!best || snapshot.trackIds.length > best.trackIds.length)){
          best = snapshot;
        }
      });
      return best?.trackIds || [];
    }

    async function hydrateProfileFromCloudThenMergeLocal(uid, email, { legacyOwnedTracks = [] } = {}){
      updateSyncState({ state: SYNC_STATES.loadingRemote, message: 'Loading cloud profileâ€¦', errorCode: null, errorStep: null });
      profileSyncOutcome = { cloudMissing: false, syncError: false, migrationApplied: false };
      const localCache = readProfileCache(uid) || {};
      recordBootStep('BOOT: local cache loaded');
      const { legacyProfile, usedLegacy } = getLegacyProfileForMigration(uid, email);
      const { ownedTracks: legacyOwnedTracksFromProfile = [], ...legacyProfileFields } = legacyProfile || {};
      const combinedLegacyOwned = normalizeOwnedList([...(legacyOwnedTracksFromProfile || []), ...(legacyOwnedTracks || [])]);
      const cachedOwnedTracks = hasCompletedProfileMigration(uid)
        ? (readOwnedTracksCache(uid)?.trackIds || [])
        : resolveOwnedTracksFromCacheCandidates([
          uid,
          localCache.uid,
          localStorage.getItem('activeProfileUid'),
          getLocalDeviceId()
        ]);
      const localProfile = {
        ...localCache,
        ...(hasCompletedProfileMigration(uid) ? {} : legacyProfileFields),
        uid,
        email: email || localCache.email || '',
        djName: localCache.djName || currentUser?.djName || '',
        ownedTracks: normalizeOwnedList([...(localCache.ownedTracks || []), ...cachedOwnedTracks])
      };
      updateSyncState({ state: SYNC_STATES.merging, message: 'Merging local changesâ€¦' });
      setlist = normalizeSetlistIds(localProfile.setlist || []);
      genreOverrides = localProfile.genreOverrides || {};
      bandMembers = localProfile.bandMembers || [];
      render(); setupEventListeners();
      const ownedSnapshot = await withSyncTimeout(
        initOwnedLibraryForUser(uid, { legacyOwnedTracks: combinedLegacyOwned, initialTrackIds: normalizeOwnedList(localProfile.ownedTracks || []) }),
        { step: 'loadingRemote' }
      );
      if((usedLegacy || combinedLegacyOwned.length) && ownedSnapshot?.trackIds?.length && firebaseEnabled && firestore && navigator.onLine){
        const serverTimestamp = firebase?.firestore?.FieldValue?.serverTimestamp;
        const migratedAt = serverTimestamp ? serverTimestamp() : new Date().toISOString();
        try{
          await withSyncTimeout(
            window.profileStore?.writeOwnedLibraryDoc?.(uid, { trackIds: ownedSnapshot.trackIds, migratedAt }),
            { step: 'savingRemote' }
          );
          profileSyncOutcome.migrationApplied = true;
        }catch(err){
          console.warn('[owned-library] migration write failed', err);
          profileSyncOutcome.syncError = true;
          setSyncError({
            code: err?.code || 'owned_migration_failed',
            step: err?.step || 'savingRemote',
            message: err?.message || 'Sync failed. Retry.'
          });
        }
      }
      let cloudProfile = null;
      try{
        cloudProfile = await withSyncTimeout(window.profileStore.readCloudProfile(uid), { step: 'loadingRemote' });
      }catch(err){
        console.warn('[profile] cloud profile read failed', err);
        profileSyncOutcome.syncError = true;
        setSyncError({
          code: err?.code || 'profile_load_failed',
          step: err?.step || 'loadingRemote',
          message: err?.message || 'Sync failed. Retry.'
        });
      }
      recordBootStep('BOOT: remote doc fetched');
      if(!cloudProfile){
        profileSyncOutcome.cloudMissing = true;
      }
      if(!window.profileStore?.buildSyncPlan){
        throw new Error('SYNC: buildSyncPlan unavailable â€” profileStore failed to initialize');
      }
      const plan = window.profileStore.buildSyncPlan({ cloud: cloudProfile, local: localProfile });
      recordBootStep('BOOT: sync plan built');
      const defaultProfile = {
        uid,
        email: email || '',
        setlist: [],
        genreOverrides: {},
        bandMembers: []
      };
      let merged = { ...defaultProfile, ...(plan.merged || {}) };
      merged.uid = uid;
      merged.email = email || merged.email || '';
      recordBootStep('BOOT: merged');
      if(plan.shouldWriteCloud){
        const serverTimestamp = firebase?.firestore?.FieldValue?.serverTimestamp;
        const migrating = plan.cloudEmpty && plan.localHasData;
        const patch = {
          ...merged,
          migratedFromLocalAt: migrating
            ? (serverTimestamp ? serverTimestamp() : new Date().toISOString())
            : merged.migratedFromLocalAt ?? null
        };
        try{
          await withSyncTimeout(window.profileStore.writeCloudProfile(uid, patch), { step: 'savingRemote' });
        }catch(err){
          console.warn('[profile] cloud profile write failed', err);
          profileSyncOutcome.syncError = true;
          setSyncError({
            code: err?.code || 'profile_save_failed',
            step: err?.step || 'savingRemote',
            message: err?.message || 'Sync failed. Retry.'
          });
        }
      }
      writeProfileCache(uid, merged);
      if(usedLegacy || combinedLegacyOwned.length){
        localStorage.setItem(PROFILE_MIGRATION_KEY, uid);
        ['ownedTracks','setlist','setlistIds','genreOverrides'].forEach((key)=>localStorage.removeItem(key));
        profileSyncOutcome.migrationApplied = true;
      }
      if(syncState.state !== SYNC_STATES.error){
        setSyncedState('Synced âœ…');
      }
      return merged;
    }

    function enterGuestMode(){
      authSettledUser = null;
      authProcessing = false;
      currentUser = null;
      draftProfile = null;
      ownedTracks = [];
      setlist = [];
      bandMembers = [];
      viewingProfile = null;
      genreOverrides = {};
      ownedLibraryState = { phase: 'idle', source: 'none', message: '' };
      ownedStore = null;
      resetUiDefaults();
      updateSyncState({ state: SYNC_STATES.idle, message: '', errorCode: null, errorStep: null });
    }

    function resetBrowseDefaults(){
      showOwnedOnly = false;
      showMixableOnly = false;
      searchTerm = '';
      selectedGenre = 'All';
      selectedSong = null;
      view = DEFAULT_VIEW;
    }
    function resetUiDefaults(){
      resetBrowseDefaults();
      resetMainPagination();
      updateMobileWindowState({ reset: true });
    }

    function enforcePostLoginDefaults(){
      resetBrowseDefaults();
      resetMainPagination();
    }

    async function ensureFirebasePersistence(){
      if(!firebaseAuth) return true;
      try{
        await firebaseAuth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
        return true;
      } catch (err){
        console.warn('Firebase persistence failed', err);
        logEvent('auth_persistence_fail', { message: err?.message, code: err?.code });
        throw err;
      }
    }

    function enterSignedOutState(){
      authSettledUser = null;
      if(userProfileUnsub){
        userProfileUnsub();
        userProfileUnsub = null;
      }
      resetUiDefaults();
      updateSyncState({ state: SYNC_STATES.idle, message: '', errorCode: null, errorStep: null });
      setAppBootState(APP_BOOT_STATES.signedOut);
      showLoginScreen();
    }

    function resolvePostAuthLanding(){
      return DEFAULT_VIEW;
    }

    function resolveInitialAuthState(){
      return new Promise((resolve) => {
        if(!firebaseAuth){
          resolve(null);
          return;
        }
        const unsub = firebaseAuth.onAuthStateChanged((user) => {
          if(unsub) unsub();
          resolve(user || null);
        });
      });
    }

    async function hydrateSignedInProfile({ uid, email, legacyOwnedTracks = [] } = {}){
      recordBootStep('hydration started');
      let hydrationFailed = false;
      try{
        const localProfile = await withTimeout(hydrateFromLocalCacheOnly(), BOOT_CALL_TIMEOUT_MS, 'local cache');
        if(localProfile){
          await applyProfileToState(localProfile, { loadEpic: false, loadOverrides: true, skipPersist: true });
        }
      }catch(err){
        console.warn('[profile] local cache hydrate failed', err);
        hydrationFailed = true;
        setSyncError({ code: err?.code || 'local_cache_failed', step: err?.step || 'localCache', message: 'Local cache failed to load.' });
      }
      try{
        const merged = await withTimeout(
          hydrateProfileFromCloudThenMergeLocal(uid, email, { legacyOwnedTracks }),
          BOOT_CALL_TIMEOUT_MS,
          'cloud profile'
        );
        await applyProfileToState(merged, { loadEpic: true, loadOverrides: true, skipPersist: true });
      }catch(err){
        console.warn('[profile] cloud hydrate failed', err);
        hydrationFailed = true;
        setSyncError({ code: err?.code || 'cloud_hydrate_failed', step: err?.step || 'cloudProfile', message: 'Cloud sync failed.' });
      }finally{
        recordBootStep(hydrationFailed ? 'hydration error' : 'hydration success');
        render();
        setupEventListeners();
      }
    }

    async function migrateLegacyOwnedTracks(uid, legacyIds = []){
      const key = `ffjm:migratedOwned:${uid}`;
      if(localStorage.getItem(key) === 'true') return null;
      const knownIds = Array.from(new Set((legacyIds || []).filter(Boolean)));
      if(!knownIds.length) return null;
      const legacySnapshots = await Promise.all(
        knownIds.map((legacyId) => withSyncTimeout(
          window.profileStore?.readLegacyOwnedLibraryDoc?.(legacyId),
          { step: 'loadingRemote' }
        ))
      );
      const legacyFromSubcollection = await withSyncTimeout(
        window.profileStore?.readLegacyOwnedLibrarySubcollection?.(uid),
        { step: 'loadingRemote' }
      );
      const candidates = [legacyFromSubcollection, ...legacySnapshots].filter(Boolean);
      if(!candidates.length) return null;
      const mergedIds = candidates.reduce((acc, snap) => {
        (snap?.trackIds || []).forEach((id) => acc.add(id));
        return acc;
      }, new Set());
      const mergedList = Array.from(mergedIds);
      if(!mergedList.length) return null;
      const serverTimestamp = firebase?.firestore?.FieldValue?.serverTimestamp;
      const migratedAt = serverTimestamp ? serverTimestamp() : new Date().toISOString();
      await withSyncTimeout(
        window.profileStore?.writeOwnedLibraryDoc?.(uid, { trackIds: mergedList, migratedAt }),
        { step: 'savingRemote' }
      );
      localStorage.setItem(key, 'true');
      return mergedList;
    }

    function setupFirebaseAuthListener() {
      if (!firebaseAuth || firebaseAuthUnsub) return;
      updateSyncState({ state: SYNC_STATES.checkingAuth, message: 'Checking sign-inâ€¦', errorCode: null, errorStep: null });
      firebaseAuthUnsub = firebaseAuth.onAuthStateChanged(async (user) => {
        if(authReadyResolve){
          authReadyResolve(user || null);
          authReadyResolve = null;
        }
        if (!user) {
          recordBootStep('auth resolved: signedOut');
          enterSignedOutState();
          return;
        }
        if(!user.uid){
          console.warn('[auth] missing uid');
          setSyncError({ code: 'missing_uid', step: 'checkingAuth', message: 'Sign in again to restore sync.' });
          await firebaseAuth.signOut();
          enterSignedOutState();
          return;
        }
        recordBootStep(`auth resolved: ${user.uid}`);
        if (authSettledUser === user.uid && appBootState === APP_BOOT_STATES.ready) return;
        authSettledUser = user.uid;
        startBootDeadline();
        recordBootStep('BOOT: auth change');
        enforcePostLoginDefaults();
        updateSyncState({ state: SYNC_STATES.loadingRemote, message: 'Sync: Loadingâ€¦', errorCode: null, errorStep: null });
        const savedUsername = getSavedUsername();
        const emailPrefix = user.email ? user.email.split('@')[0] : '';
        const defaultUsername = savedUsername || user.displayName || emailPrefix || `user_${user.uid.slice(0,6)}`;
        currentUser = normalizeProfileShape({
          uid: user.uid,
          email: user.email || '',
          username: defaultUsername,
          djName: defaultUsername
        }, user.uid);
        view = DEFAULT_VIEW;
        setAppBootState(APP_BOOT_STATES.ready);
        render();
        setupEventListeners();
        recordBootStep('READY rendered');
        void loadAppData({ loadSongs: !songs.length, loadProfile: false, preferCache: false, showBootScreen: false, allowProfileAutoOpen: false });
        const legacyIds = [currentUser?.username, user.email, emailPrefix, user.displayName]
          .filter((value) => value && value !== user.uid);
        void (async () => {
          let migrationOwned = [];
          try{
            migrationOwned = await withTimeout(migrateLegacyOwnedTracks(user.uid, legacyIds), BOOT_CALL_TIMEOUT_MS, 'legacy owned migration') || [];
          }catch(err){
            console.warn('[owned-library] legacy migration failed', err);
          }
          await hydrateSignedInProfile({ uid: user.uid, email: user.email || '', legacyOwnedTracks: migrationOwned });
        })();
        if(syncState.state !== SYNC_STATES.error){
          setSyncedState('Synced âœ…');
        }
        logEvent('auth_success', { uid: user.uid });
      });
    }

    async function handleFirebaseAuth(e){
      e.preventDefault();
      const errorBox = document.getElementById('authError');
      if(!firebaseEnabled || !firebaseAuth){
        if(errorBox){ errorBox.textContent = 'Firebase not configured â€” using local profiles.'; errorBox.style.display = 'block'; }
        logEvent('auth_fail', { reason: 'config_missing' });
        return;
      }
      const mode = document.getElementById('authMode')?.value || 'signin';
      const email = (document.getElementById('email')?.value || '').trim();
      const password = (document.getElementById('password')?.value || '').trim();
      const passwordConfirm = document.getElementById('passwordConfirm')?.value || '';

      if(authInFlight) return;
      if(!email || !password){ if(errorBox){ errorBox.textContent = 'Enter email & password.'; errorBox.style.display = 'block'; } return; }
      if(password.length < 6 && mode === 'signup'){ if(errorBox){ errorBox.textContent = 'Password must be at least 6 characters.'; errorBox.style.display = 'block'; } return; }

      const submitBtn = document.getElementById('authSubmit');
      const disableAuthUi = (disabled) => {
        if(submitBtn){ submitBtn.disabled = disabled; submitBtn.classList.toggle('opacity-70', disabled); }
      };
      const mapErrorCode = (code, message)=>{
        if(code === 'auth/invalid-credential' || code === 'auth/wrong-password') return 'Email/password incorrect';
        if(code === 'auth/user-not-found') return 'No account found â€” click Register';
        if(code === 'auth/network-request-failed') return 'Network blocked/unstable. Try again or disable VPN.';
        if(code === 'auth/too-many-requests') return 'Too many attempts â€” wait a moment';
        return message || 'Sign-in failed';
      };
      authInFlight = true;
      disableAuthUi(true);
      if(errorBox){ errorBox.textContent = ''; errorBox.style.display = 'none'; }
      logEvent('auth_attempt', { mode, email });
      try{
        if(mode === 'signup'){
          if(password !== passwordConfirm){ if(errorBox){ errorBox.textContent = 'Passwords do not match.'; errorBox.style.display = 'block'; } return; }
          await firebaseAuth.createUserWithEmailAndPassword(email,password);
        } else {
          await firebaseAuth.signInWithEmailAndPassword(email,password);
        }

        setupFirebaseAuthListener();

      } catch(err){
        console.error(err);
        const message = mapErrorCode(err?.code || '', err?.message);
        if(errorBox){ errorBox.textContent = message; errorBox.style.display = 'block'; }
        logEvent('auth_fail', { code: err?.code, message: err?.message });
      } finally {
        authInFlight = false;
        disableAuthUi(false);
      }
    }
    window.handleFirebaseAuth = handleFirebaseAuth;


    async function logoutUser(){
      try { await persistCurrentUserProfile(); } catch(err){ console.warn('save before logout failed', err); }
      const store = ensureOwnedLibraryStore();
      const signOut = async () => {
        if(firebaseAuth){
          try{ await firebaseAuth.signOut(); } catch(e){ console.warn('signout',e); }
        }
      };
      try{
        await queueSaveProfile({ reason: 'logout', flush: true });
      }catch(err){
        console.warn('[profile] sync flush before logout failed', err);
        const action = await showSyncFailureModal();
        if(action === 'download'){
          exportOwnedBackupJson();
          return;
        }
        if(action === 'retry'){
          try{
            await queueSaveProfile({ reason: 'logout_retry', flush: true });
          }catch(retryErr){
            console.warn('[profile] retry sync failed', retryErr);
            return;
          }
        } else {
          return;
        }
      }
      if(store){
        const setBusy = (busy) => {
          logoutInProgress = busy;
          render();
          setupEventListeners();
        };
        const needsFlush = store?.hasUnsavedChanges?.() === true;
        if(needsFlush) setBusy(true);
        try{
          if(needsFlush){
            try{
              await store.flush('logout');
            }catch(err){
              console.warn('[owned-library] logout flush failed', err);
              setBusy(false);
              const action = await showOwnedLogoutModal(err);
              if(action === 'download'){
                exportOwnedBackupJson();
                return;
              }
              if(action === 'retry'){
                try{
                  await store.flush('logout_retry');
                }catch(retryErr){
                  console.warn('[owned-library] retry flush failed', retryErr);
                  return;
                }
              } else {
                return;
              }
            }
          }
        } finally {
          if(needsFlush) setBusy(false);
        }
        await signOut();
      } else {
        await signOut();
      }
      authSettledUser = null; authProcessing = false;
      currentUser = null; draftProfile = null; ownedTracks = []; setlist = []; bandMembers = []; viewingProfile = null; genreOverrides = {};
      ownedLibraryState = { phase: 'idle', source: 'none', message: '' };
      ownedStore = null;
      logoutInProgress = false;
      resetUiDefaults();
      localStorage.removeItem('currentUser');
      updateSyncState({ state: SYNC_STATES.idle, message: '', errorCode: null, errorStep: null });
    }

    // -------------------- Songs loading -----------------------
    function applySongsSnapshot(nextSongs, { source = 'network', notice = '' } = {}){
      songs = nextSongs;
      songs.forEach(hydrateKeyInfo);
      songsById = Object.fromEntries(songs.map(s => [s.id, s]));
      refreshRegressionWarnings();
      trackSource = source;
      songsLoaded = true;
      trackLoadNotice = notice;
      trackLoadState = { status: 'idle', loaded: 0, total: 0, message: '' };
    }

    async function loadSongsRobust({ allowOneRetry = true, preferCache = false, onCacheApplied } = {}){
      console.log('Loading tracks...');
      loadSongsStartTime = performance.now();
      firstListRenderLogged = false;
      maxCardsLogged = false;
      maxMobileCardsRendered = 0;
      logEvent('songs_fetch_start', { online: navigator.onLine });
      trackLoadNotice = '';
      const endpoints=[ 'https://api.allorigins.win/raw?url=https://fortnitecontent-website-prod07.ol.epicgames.com/content/api/pages/fortnite-game/spark-tracks', 'https://corsproxy.io/?https://fortnitecontent-website-prod07.ol.epicgames.com/content/api/pages/fortnite-game/spark-tracks' ];
      const canFetch = navigator.onLine;
      trackLoadState = { status: 'loading', loaded: 0, total: 0, message: 'Loading tracksâ€¦' };
      const tryFetch = async () => {
        for(let i=0;i<endpoints.length;i++){
          try{
            const res = await fetch(endpoints[i]);
            if(!res.ok) continue;
            const data = await res.json();
            const entries = Object.entries(data).filter(([k])=>!k.startsWith('_'));
            const nextSongs = [];
            trackLoadState = { status: 'loading', loaded: 0, total: entries.length, message: 'Loading tracksâ€¦' };
            for(let idx=0; idx<entries.length; idx+=1){
              const [id,item] = entries[idx];
              const track = item?.track || {};
              if(!track?.tt) continue;
              const detectedGenre = detectGenre(track.an||'', track.tt);
              const finalGenre = genreOverrides[id] || detectedGenre;
              const rawBpm = Number(track.mt) || 0;
              const camelotData = deriveCamelotForTrack({ ...track, id });
              const camelotApplied = applyCamelotOverride({ ...track, id, title: track.tt, artist: track.an }, camelotData.camelot);
              const bpmApplied = applyBpmOverride({ ...track, id, title: track.tt, artist: track.an }, rawBpm);
              const keyInfo = parseKey(track.mk || camelotData.keyLabel || track.key || '', track.mm || camelotData.mode || track.mode || '');
              const enriched = { id, title: track.tt, artist: track.an || 'Unknown', bpm: bpmApplied.bpm, rawBpm, key: keyInfo.label || camelotData.keyLabel || (track.mk || '?'), rawKey: track.mk || '', rawMode: track.mm || '', mode: camelotData.mode || (track.mm||''), camelot: camelotApplied.camelot, derivedCamelot: camelotData.camelot, duration: Number(track.dn)||0, albumArt: track.au||'', genre: finalGenre, camelotOverridden: camelotApplied.overridden, bpmOverridden: bpmApplied.overridden, keyInfo };
              enriched.flags = computeTrackFlags(enriched);
              if(enriched.bpm>0) nextSongs.push(enriched);
              trackLoadState.loaded = idx + 1;
            }
            nextSongs.sort((a,b)=>a.title.localeCompare(b.title));
            if(nextSongs.length>0){
              applySongsSnapshot(nextSongs, { source: 'network', notice: '' });
              if(regressionWarnings.length) console.warn('Regression warnings', regressionWarnings);
              logEvent('songs_fetch_success', { source: trackSource, count: songs.length });
              return { songs, usedFallback: false };
            }
          }catch(e){
            console.warn('endpoint err',e);
            logEvent('songs_fetch_fail', { message: e?.message, step: 'network' });
          }
        }
        return null;
      };
      if(canFetch){
        const fetched = await tryFetch();
        if(fetched) return fetched;
      }
      if(allowOneRetry && canFetch){
        await new Promise(resolve => setTimeout(resolve, 1000));
        const retryResult = await tryFetch();
        if(retryResult) return retryResult;
      }
      console.warn('endpoints failed, using fallback sample');
      applySongsSnapshot(SAMPLE_TRACKS, { source: 'fallback', notice: canFetch ? 'Track list unavailable â€” showing fallback tracks.' : 'Offline â€” track list unavailable.' });
      logEvent('songs_fetch_fail', { message: 'network+cache miss; using fallback' });
      return { songs, usedFallback: true };
    }

    async function loadSongs(){
      return loadSongsRobust({ allowOneRetry: true });
    }

    function refreshRegressionWarnings(){
      regressionWarnings = knownCorrections.filter(kc=>{
        const track = songs.find(s=>s.id===kc.id);
        return track && track.camelot !== kc.expectedCamelot;
      });
    }

    function resetMainPagination(){
      resetPage(mainPager);
      persistMainPagerState();
    }

    const setCamelotOverride = async (trackId,value)=>{
      if(!isAdmin()) return alert('Admin only');
      camelotOverridesStore.ids[trackId] = value;
      await persistOverrides();
      const track = songs.find(s=>s.id===trackId);
      if(track){ refreshSongOverrides(track); }
      refreshRegressionWarnings();
      renderAuditView();
      renderSongList();
    };
    const setBpmOverride = async (trackId,value)=>{
      if(!isAdmin()) return alert('Admin only');
      bpmOverridesStore.ids[trackId] = Number(value);
      await persistOverrides();
      const track = songs.find(s=>s.id===trackId);
      if(track){ refreshSongOverrides(track); }
      renderAuditView();
      renderSongList();
    };
    const clearOverrides = async (trackId)=>{
      if(!isAdmin()) return alert('Admin only');
      delete camelotOverridesStore.ids[trackId];
      delete bpmOverridesStore.ids[trackId];
      await persistOverrides();
      const track = songs.find(s=>s.id===trackId);
      if(track){ refreshSongOverrides(track); }
      refreshRegressionWarnings();
      renderAuditView();
      renderSongList();
    };

    // ---------------------- Render list & setlist -----------------------
    function formatDuration(sec){ const m=Math.floor(sec/60); const s=sec%60; return `${m}:${s.toString().padStart(2,'0')}`; }
    function updateOwnedCount(){
      const el = document.getElementById('ownedCount');
      if(el) el.textContent = getHeaderTrackCountLabel();
    }

    function scrollSongListToTop(){
      const list = document.getElementById('songList');
      if(!list) return;
      if(list.scrollHeight > list.clientHeight){
        list.scrollTo({ top: 0, behavior: 'smooth' });
      } else {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }

    function scheduleSongListRender(reason='', options = {}){
      const { scrollToTop = false } = options || {};
      songListRenderReason = reason;
      if(songListRenderScheduled) return;
      songListRenderScheduled = true;
      requestAnimationFrame(()=>{
        songListRenderScheduled = false;
        renderSongList();
        if(scrollToTop){
          requestAnimationFrame(scrollSongListToTop);
        }
      });
    }

    function buildSelectedSongCriteria(song){
      if(!song) return null;
      const bpmMin = song.bpm - 4;
      const bpmMax = song.bpm + 4;
      if(keyMatchMode === 'semitone'){
        const info = ensureKeyInfo(song);
        return { mode: 'semitone', bpmMin, bpmMax, info };
      }
      return { mode: 'camelot', bpmMin, bpmMax, compatibleKeys: getCompatibleKeys(song.camelot) };
    }

    function refreshSelectedSongCriteria(){
      selectedSongCriteria = selectedSong ? buildSelectedSongCriteria(selectedSong) : null;
    }

    function isMixableWithCriteria(criteria, candidate){
      if(!criteria || !candidate) return false;
      if(candidate.bpm < criteria.bpmMin || candidate.bpm > criteria.bpmMax) return false;
      if(criteria.mode === 'semitone'){
        const match = scoreSemitoneKeyMatch(criteria.info, ensureKeyInfo(candidate), maxSemitoneRange, includeOppositeMode);
        return match.eligibleSameMode || match.eligibleOppMode;
      }
      return criteria.compatibleKeys.includes(candidate.camelot);
    }

    function updateTrackLoadProgressUI(){
      const el = document.getElementById('trackLoadProgress');
      if(el && trackLoadState.total){
        el.textContent = `Loaded ${trackLoadState.loaded}/${trackLoadState.total}`;
      }
    }

    function updateSongCardOwnedState(songId){
      const card = document.querySelector(`.song-card[data-song-id="${songId}"]`);
      if(!card) return;
      const displayTracks = viewingProfile ? viewingProfile.ownedTracks || [] : ownedTracks;
      const isOwned = displayTracks.includes(songId);
      const star = card.querySelector('[data-owned-star]');
      if(star) star.style.display = isOwned ? 'block' : 'none';
      const button = card.querySelector('[data-song-action="toggle-owned"]');
      if(button){
        if(isGuestUser() && !viewingProfile){
          button.textContent = 'Sign in to mark owned';
          button.className = 'px-3 py-2 bg-gray-700/60 rounded-lg text-sm font-medium transition';
        } else {
          button.textContent = isOwned ? 'âœ“ Owned' : 'Mark Owned';
          button.className = `px-3 py-2 ${isOwned ? 'bg-green-500 hover:bg-green-600' : 'bg-gray-700 hover:bg-gray-600'} rounded-lg text-sm font-medium transition`;
        }
      }
    }

    function updateSongCardSetlistState(songId){
      const card = document.querySelector(`.song-card[data-song-id="${songId}"]`);
      if(!card) return;
      const isInSetlist = setlist.includes(songId);
      const button = card.querySelector('[data-song-action="toggle-setlist"]');
      if(button){
        if(isGuestUser() && !viewingProfile){
          button.textContent = 'Sign in to save setlists';
          button.className = 'addSetBtn px-4 py-2 bg-purple-500/20 rounded-lg text-sm font-medium transition';
        } else {
          button.textContent = isInSetlist ? 'âœ“ In Setlist' : '+ Set';
          button.className = `addSetBtn px-4 py-2 ${isInSetlist ? 'bg-emerald-500/40 hover:bg-emerald-500/50' : 'bg-gradient-to-r from-purple-500 to-pink-500'} rounded-lg text-sm font-medium transition`;
        }
      }
    }

    function setMixableInlineNotice(message){
      mixableInlineNotice = message;
      if(mixableInlineTimer) clearTimeout(mixableInlineTimer);
      mixableInlineTimer = setTimeout(()=>{
        mixableInlineNotice = '';
        const banner = document.getElementById('mixableInlineNotice');
        if(banner) banner.style.display = 'none';
      }, 2200);
      const banner = document.getElementById('mixableInlineNotice');
      if(banner){
        banner.textContent = mixableInlineNotice;
        banner.style.display = mixableInlineNotice ? 'block' : 'none';
      }
    }

    function getStickyCtaConfig(){
      if(view !== 'browse') return { visible: false };
      if(viewingProfile) return { visible: false };
      if(!isMobileViewport()) return { visible: false };
      if(stickyCtaDismissed) return { visible: false };
      if(isSearchFocused) return { visible: false };
      if(isGuestUser()){
        return { visible: true, text: 'Sign in to save Owned + Setlist', action: 'sign-in' };
      }
      const hasOwned = ownedTracks.length > 0;
      const hasSelected = !!selectedSong;
      if(hasOwned && hasSelected){
        stickyCtaDismissed = true;
        localStorage.setItem('jamMixer.stickyCtaDismissed', 'true');
        return { visible: false };
      }
      if(showMixableOnly && !selectedSong){
        return { visible: true, text: 'Select a Song First', action: 'mixable-warning' };
      }
      if(!hasOwned){
        return { visible: true, text: 'Start: Pick Songs You Own', action: 'open-quickstart' };
      }
      return { visible: true, text: 'Next: Choose a Song to Mix', action: 'scroll-to-list' };
    }

    function updateStickyCTA(){
      const config = getStickyCtaConfig();
      const bar = document.getElementById('stickyCtaBar');
      const button = document.getElementById('stickyCtaButton');
      const copy = document.getElementById('stickyCtaCopy');
      const appRoot = document.getElementById('appRoot');
      if(appRoot){
        appRoot.classList.toggle('sticky-cta-active', !!config.visible);
      }
      if(!bar || !button) return;
      if(!config.visible){
        bar.classList.add('hidden');
        return;
      }
      bar.classList.remove('hidden');
      button.textContent = config.text || '';
      button.dataset.stickyAction = config.action || '';
      if(copy){
        copy.textContent = config.action === 'open-quickstart'
          ? 'Tap to pick a starter set in seconds.'
          : config.action === 'scroll-to-list'
            ? 'Jump to the song list and pick a starter track.'
            : 'Mixable matches need a selected song first.';
      }
    }

    function shiftMobileWindow(direction){
      if(!isMobileViewport()) return;
      const delta = direction * MOBILE_PAGE_CHUNK;
      const maxStart = Math.max(0, lastFilteredCount - MOBILE_MAX_CARDS);
      mobileWindowState.start = Math.min(maxStart, Math.max(0, mobileWindowState.start + delta));
      mobileWindowState.count = Math.min(MOBILE_MAX_CARDS, Math.max(MOBILE_PAGE_CHUNK, mobileWindowState.count));
      scheduleSongListRender('mobile-window-shift');
      const list = document.getElementById('songList');
      if(list) list.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    const QUICK_START_PRESETS = {
      casual: {
        title: 'Casual',
        copy: 'Mark a starter set of 15 popular tracks.',
        count: 15
      },
      new: {
        title: 'New Player',
        copy: 'Mark 5 starter tracks so you can mix fast.',
        count: 5
      }
    };
    const QUICK_START_CURATED_TITLES = [
      'Bad Guy',
      'Blinding Lights',
      'Go With The Flow',
      'Seven Nation Army',
      'Believer',
      'Levitating',
      'One Dance',
      'Uptown Funk',
      'Wake Me Up',
      'Counting Stars',
      'Mr. Brightside',
      'Viva La Vida',
      'Heat Waves',
      'Dance Monkey',
      'Starboy',
      'Lose Yourself',
      'Take On Me',
      'Happier',
      'Bad Romance',
      'Blame It On The Boogie'
    ];

    function resolveQuickStartTrackIds(limit){
      const ids = [];
      QUICK_START_CURATED_TITLES.forEach((title)=>{
        const match = songs.find(s=>s.title?.toLowerCase() === title.toLowerCase());
        if(match && !ids.includes(match.id)) ids.push(match.id);
      });
      if(ids.length < limit){
        songs.slice(0, limit).forEach((song)=>{
          if(!ids.includes(song.id)) ids.push(song.id);
        });
      }
      return ids.slice(0, limit);
    }

    function getQuickStartRecommendations(){
      const preferred = resolveQuickStartTrackIds(6);
      return preferred.map(id => songsById[id]).filter(Boolean);
    }

    function openQuickStart(){
      if(isGuestUser()){
        setMixableInlineNotice('Sign in to mark owned tracks.');
        return;
      }
      if(quickStartDone) return;
      quickStartState.open = true;
      quickStartState.step = 0;
      quickStartState.preset = null;
      const modal = document.getElementById('quickStartModal');
      if(modal){
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden','false');
      }
      renderQuickStartStep();
    }

    function closeQuickStart(){
      quickStartState.open = false;
      const modal = document.getElementById('quickStartModal');
      if(modal){
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden','true');
      }
    }

    function maybeAutoOpenQuickStart(){
      if(quickStartDone || quickStartPrompted || quickStartState.open) return;
      if(!currentUser || !justEnteredProfile) return;
      if(ownedTracks.length === 0){
        quickStartPrompted = true;
        openQuickStart();
      }
      justEnteredProfile = false;
    }

    function moveQuickStartStep(delta){
      const next = Math.max(0, Math.min(1, quickStartState.step + delta));
      quickStartState.step = next;
      renderQuickStartStep();
    }

    async function completeQuickStart({ skipped = false } = {}){
      quickStartDone = true;
      localStorage.setItem('jamMixer.quickStartDone', 'true');
      closeQuickStart();
      const store = ensureOwnedLibraryStore();
      if(store){
        await store.flush('finish_marking');
      }
      if(skipped){
        stickyCtaDismissed = false;
        updateStickyCTA();
      }
      updateStickyCTA();
    }

    async function applyQuickStartPreset(preset){
      let nextOwned = [];
      if(preset === 'completionist'){
        const confirmed = confirm('âš ï¸ This will mark every track as owned. This cannot be undone easily. Continue?');
        if(!confirmed) return false;
        nextOwned = songs.map(s=>s.id);
      } else {
        const config = QUICK_START_PRESETS[preset];
        if(!config) return false;
        nextOwned = resolveQuickStartTrackIds(config.count);
      }
      const store = ensureOwnedLibraryStore();
      if(store){
        store.setOwnedList(nextOwned, 'quickstart', { allowEmpty: true });
      } else {
        ownedTracks = normalizeOwnedList(nextOwned);
        persistUserSession(currentProfileFromState(), { reason: 'markAll', skipBackend: true }).catch(()=>{});
      }
      updateOwnedCount();
      updateMobileWindowState({ reset: true });
      scheduleSongListRender('quick-start-owned');
      updateStickyCTA();
      return true;
    }

    function renderQuickStartStep(){
      const body = document.getElementById('quickStartBody');
      const title = document.getElementById('quickStartTitle');
      const subtitle = document.getElementById('quickStartSubtitle');
      if(!body || !title || !subtitle) return;
      if(quickStartState.step === 0){
        title.textContent = 'Quick Start';
        subtitle.textContent = 'Pick your style to mark owned tracks.';
        body.innerHTML = `
          <button class="quickstart-option" data-action="quickStartPreset" data-preset="casual">
            <strong>Casual</strong>
            <span class="text-xs text-gray-300">${QUICK_START_PRESETS.casual.copy}</span>
          </button>
          <button class="quickstart-option" data-action="quickStartPreset" data-preset="new">
            <strong>New Player</strong>
            <span class="text-xs text-gray-300">${QUICK_START_PRESETS.new.copy}</span>
          </button>
          <button class="quickstart-option" data-action="quickStartPreset" data-preset="completionist">
            <strong>Completionist</strong>
            <span class="text-xs text-red-200">Marks ALL tracks owned (big library).</span>
          </button>
        `;
      } else {
        title.textContent = 'Choose a starter track';
        subtitle.textContent = 'Tap one to see instant mixable matches.';
        const picks = getQuickStartRecommendations();
        body.innerHTML = picks.length ? picks.map(track=>`
          <div class="quickstart-track" data-action="quickStartPickTrack" data-song-id="${track.id}">
            <div class="w-10 h-10 rounded-lg flex items-center justify-center text-sm font-bold" style="background:${camelotColors[track.camelot] || '#0ea5e9'}">${track.camelot}</div>
            <div style="flex:1">
              <div class="font-semibold text-white">${track.title}</div>
              <div class="text-xs text-gray-300">${track.artist}</div>
            </div>
            <span class="text-xs text-cyan-200 font-semibold">${track.bpm} BPM</span>
          </div>
        `).join('') : '<div class="text-sm text-gray-300">Tracks are still loading â€” give it a second.</div>';
      }
      const backBtn = document.querySelector('[data-action="quickStartBack"]');
      if(backBtn) backBtn.style.visibility = quickStartState.step === 0 ? 'hidden' : 'visible';
    }

    function renderSongList(){
      listRenderCount += 1;
      const displayTracks = viewingProfile ? viewingProfile.ownedTracks || [] : ownedTracks;
      const isGuest = isGuestUser();
      const isMobile = isMobileViewport();
      if(!isMobile && mobileListObserver){
        mobileListObserver.disconnect();
        mobileListObserver = null;
      }
      const filtered = songs.filter(s=>{
        const isSelected = selectedSong && s.id === selectedSong.id;
        const matchesSearch = !searchTerm || s.title.toLowerCase().includes(searchTerm.toLowerCase()) || s.artist.toLowerCase().includes(searchTerm.toLowerCase());
        const matchesOwned = !showOwnedOnly || displayTracks.includes(s.id);
        const matchesMixable = isSelected || !showMixableOnly || !selectedSong || isMixableWithCriteria(selectedSongCriteria, s);
        const matchesGenre = selectedGenre === 'All' || s.genre === selectedGenre;
        return matchesSearch && matchesOwned && matchesMixable && matchesGenre;
      });

      const scored = filtered.map(song=>{
        if(!selectedSong){
          return { song, comp: null, rank: 0, bpmDiff: null, keyDist: null, sameGenre: false };
        }
        const rankData = priorityRank(selectedSong, song, sortMode);
        return { song, ...rankData };
      });

      if(selectedSong){
        if(keyMatchMode === 'semitone'){
          scored.sort((a,b)=>{
            const aMatch = a.semitoneMatch || {};
            const bMatch = b.semitoneMatch || {};
            const aSame = aMatch.eligibleSameMode ? 1 : 0;
            const bSame = bMatch.eligibleSameMode ? 1 : 0;
            if(aSame !== bSame) return bSame - aSame;
            const aOpp = aMatch.eligibleOppMode ? 1 : 0;
            const bOpp = bMatch.eligibleOppMode ? 1 : 0;
            if(aSame===0 && bSame===0 && aOpp !== bOpp) return bOpp - aOpp;
            const aDist = (aMatch.eligibleSameMode || aMatch.eligibleOppMode) ? aMatch.dist ?? Infinity : Infinity;
            const bDist = (bMatch.eligibleSameMode || bMatch.eligibleOppMode) ? bMatch.dist ?? Infinity : Infinity;
            if(aDist !== bDist) return aDist - bDist;
            const aBpm = a.bpmDiff ?? Infinity;
            const bBpm = b.bpmDiff ?? Infinity;
            if(aBpm !== bBpm) return aBpm - bBpm;
            return a.song.title.localeCompare(b.song.title);
          });
        } else {
          scored.sort((a,b)=>{
            const scoreDiff = (b.rank ?? 0) - (a.rank ?? 0);
            if(scoreDiff !== 0) return scoreDiff;
            return a.song.title.localeCompare(b.song.title);
          });
        }
      } else {
        scored.sort((a,b)=> a.song.title.localeCompare(b.song.title));
      }
      lastFilteredCount = scored.length;

      const songListEl = document.getElementById('songList'); if(!songListEl) return;
      let pageEntries = scored;
      let showingStart = scored.length ? 1 : 0;
      let showingEnd = scored.length;
      let totalPages = 1;
      let mobileControls = '';
      if(isMobile){
        updateMobileWindowState();
        const start = Math.max(0, mobileWindowState.start);
        const count = Math.min(mobileWindowState.count, MOBILE_MAX_CARDS);
        pageEntries = scored.slice(start, start + count);
        showingStart = pageEntries.length ? start + 1 : 0;
        showingEnd = pageEntries.length ? start + pageEntries.length : 0;
        const hasMore = start + count < scored.length;
        const canAutoLoad = hasMore && count < MOBILE_MAX_CARDS;
        const canStep = hasMore && count >= MOBILE_MAX_CARDS;
        const hasPrev = start > 0;
        mobileControls = `
          <div class="mt-3 flex flex-col gap-2">
            <div class="text-xs text-gray-300">Showing ${showingStart}â€“${showingEnd} of ${scored.length} tracks</div>
            ${canAutoLoad ? `<div id="songListSentinel" class="text-xs text-cyan-200">Loading more tracksâ€¦</div>` : ''}
            ${canStep || hasPrev ? `<div class="flex items-center gap-2">
              ${hasPrev ? `<button data-action="mobilePrevWindow" class="px-3 py-2 rounded-lg bg-white/10 border border-white/10 text-sm">Previous</button>` : ''}
              ${canStep ? `<button data-action="mobileNextWindow" class="px-3 py-2 rounded-lg bg-white/10 border border-white/10 text-sm">Next</button>` : ''}
            </div>` : ''}
          </div>`;
        if(pageEntries.length > maxMobileCardsRendered) maxMobileCardsRendered = pageEntries.length;
      } else {
        const pagination = paginate(scored, mainPager.pageIndex, mainPager.pageSize);
        if(pagination.pageIndex !== mainPager.pageIndex) mainPager.pageIndex = pagination.pageIndex;
        persistMainPagerState();
        pageEntries = pagination.pageItems;
        showingStart = pagination.from;
        showingEnd = pagination.to;
        totalPages = pagination.totalPages;
      }

      const priorityNames = { bpm:'Tempo', camelot:'Camelot', genre:'Genre' };
      const priorityDescriptions = {
        bpm: 'Priority: Tempo â€” closest BPM results are boosted within compatible matches.',
        camelot: 'Priority: Camelot â€” harmonic neighbors rise to the top within the best matches.',
        genre: 'Priority: Genre â€” same-genre blends are boosted while keeping top compatibility first.'
      };
      const priorityHeader = selectedSong ? `
        <div class="mb-3 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-1">
          <div class="text-lg font-bold text-white">Top Matches (Priority: ${priorityNames[sortMode] || 'Tempo'})</div>
          <div class="text-xs text-cyan-200 font-semibold">Strength: ${priorityStrength==='low'?'Low':priorityStrength==='high'?'High':'Medium'}</div>
        </div>
        <div class="text-xs text-gray-300 mb-4">${priorityDescriptions[sortMode] || priorityDescriptions.bpm} Top matches are sorted by compatibility first, then the priority boost (showing strongest ~10 results up top).</div>
      ` : '';

      const adminUser = isAdmin();
      const reducedEffects = isLowPowerMode;
      const cardGrid = pageEntries.map(entry=>{
        const song = entry.song;
        const isSelected = selectedSong && song.id === selectedSong.id;
        const isOwned = displayTracks.includes(song.id);
        const isInSetlist = setlist.includes(song.id);
        const comp = entry.comp;
        const pct = comp ? Math.min(100, Math.max(0, Math.round(comp.total))) : null;
        const hasOverride = genreOverrides[song.id];
        const glowClass = reducedEffects ? '' : (pct>=80 ? 'glow-perfect' : pct>=60 ? 'glow-good' : (pct!==null ? 'glow-bad' : ''));
        const priorityLabel = selectedSong ? (()=>{
          if(keyMatchMode === 'semitone'){
            const distVal = entry.semitoneMatch?.dist ?? 'â€”';
            const modeLabel = entry.semitoneMatch?.eligibleSameMode ? 'same mode' : entry.semitoneMatch?.eligibleOppMode ? 'opposite mode' : 'out of range';
            return `ðŸŽ¶ Semitone priority (Î”${distVal}, ${modeLabel})`;
          }
          if(sortMode === 'bpm'){
            const delta = entry.bpmDiff !== null && entry.bpmDiff !== undefined ? Math.round(entry.bpmDiff) : 'â€”';
            return `ðŸ”¥ Closest BPM match (Î”${delta})`;
          }
          if(sortMode === 'camelot'){
            const distVal = entry.keyDist !== null && entry.keyDist !== undefined ? (Number.isInteger(entry.keyDist) ? entry.keyDist : entry.keyDist.toFixed(1)) : 'â€”';
            return `ðŸŽ¼ Harmonic neighbor (distance ${distVal})`;
          }
          if(sortMode === 'genre'){
            return entry.sameGenre ? 'ðŸŽ­ Same genre boost' : 'ðŸŽ­ Genre priority (different genre)';
          }
          return '';
        })() : '';
        const semitoneBadge = (selectedSong && keyMatchMode==='semitone') ? (()=>{
          const match = entry.semitoneMatch;
          if(!match || match.dist===null || match.dist===undefined) return '';
          const deltaLabel = match.signedDelta===null || match.signedDelta===undefined ? `Î”Key: ${match.dist}` : `Î”Key: ${match.signedDelta>=0?'+':''}${match.signedDelta}`;
          const modeLabel = match.eligibleSameMode ? 'Same Mode' : (match.eligibleOppMode ? 'Opp Mode' : 'Not in range');
          return `<span class="px-2 py-1 bg-blue-500/20 border border-blue-400/40 rounded text-xs text-blue-100 font-semibold">${deltaLabel} â€¢ ${modeLabel}</span>`;
        })() : '';
        if(showMixableOnly && selectedSong){ if(!isMixableWithCriteria(selectedSongCriteria, song)) return ''; }
        const ownedDisabled = viewingProfile || (isGuest && !viewingProfile);
        const ownedButtonLabel = (isGuest && !viewingProfile) ? 'Sign in to mark owned' : (isOwned ? 'âœ“ Owned' : 'Mark Owned');
        const ownedButtonClass = (isGuest && !viewingProfile)
          ? 'bg-gray-700/60 cursor-not-allowed'
          : (isOwned ? 'bg-green-500 hover:bg-green-600' : 'bg-gray-700 hover:bg-gray-600');
        const setlistDisabled = viewingProfile || (isGuest && !viewingProfile);
        const setlistButtonLabel = (isGuest && !viewingProfile) ? 'Sign in to save setlists' : (isInSetlist ? 'âœ“ In Setlist' : '+ Set');
        const setlistButtonClass = (isGuest && !viewingProfile)
          ? 'bg-purple-500/20 cursor-not-allowed'
          : (isInSetlist ? 'bg-emerald-500/40 hover:bg-emerald-500/50' : 'bg-gradient-to-r from-purple-500 to-pink-500');
        const selectedStyles = isSelected ? 'selected-card' : '';
        const genrePill = adminUser
          ? `<button data-genre-tag="${song.id}" data-song-id-genre="${song.id}" class="px-2 py-1 ${hasOverride ? 'bg-green-500/30 border-green-500/50' : 'bg-orange-500/30 border-orange-500/50'} border rounded text-xs cursor-pointer hover:border-cyan-400/60" title="Click to edit genre">${song.genre}${hasOverride ? ' âœ“' : ''}</button>`
          : `<span class="px-2 py-1 ${hasOverride ? 'bg-green-500/30 border-green-500/50' : 'bg-orange-500/30 border-orange-500/50'} border rounded text-xs cursor-default">${song.genre}${hasOverride ? ' âœ“' : ''}</span>`;
        return `
          <div class="song-card panel p-4 relative hover:border-cyan-400 transition-all ${selectedStyles}" data-song-id="${song.id}" draggable="true">
            <div class="star-icon absolute top-2 right-2 text-xl" data-owned-star style="display:${isOwned?'block':'none'}">â­</div>
            ${isSelected ? `<button class="selected-badge absolute top-2 left-2 flex items-center gap-1" data-song-action="clear-selection">SELECTED <span class="font-normal text-[10px] opacity-90">(tap to clear)</span></button>` : (selectedSong && isMixable(selectedSong,song) ? `<div class="absolute top-2 left-2 text-xl">ðŸŽ§</div>` : '')}
            <div class="flex gap-4 mb-3">
              ${song.albumArt ? `<img src="${song.albumArt}" class="w-20 h-20 rounded-lg cursor-pointer hover:scale-110 transition-transform" data-song-action="select" data-song-id="${song.id}"/>` : `<div class="w-20 h-20 bg-gradient-to-br from-purple-500 to-pink-500 rounded-lg"></div>`}
              <div class="flex-1 cursor-pointer" data-song-action="select" data-song-id="${song.id}">
                <div class="font-bold text-lg mb-1 text-white">${song.title}</div>
                <div class="text-gray-300 mb-2 text-sm">${song.artist}</div>
                <div class="flex items-center gap-2 text-sm flex-wrap">
                  ${genrePill}
                  <span class="px-3 py-1 rounded-lg font-mono font-bold text-white" style="background:${camelotColors[song.camelot] || '#666'}">${song.camelot}</span>
                  <span class="px-2 py-1 bg-gray-700 rounded text-xs">${song.key}</span>
                  <span class="font-semibold text-cyan-300">${song.bpm} BPM</span>
                  ${semitoneBadge}
                  ${selectedSong && isMixable(selectedSong,song) ? `<span class="px-2 py-1 bg-purple-600/40 border border-purple-400/40 rounded text-xs text-purple-200 font-bold">Â±${Math.abs(song.bpm - selectedSong.bpm)} BPM</span>` : ''}
                  <span class="text-gray-400">${formatDuration(song.duration)}</span>
                </div>
                ${priorityLabel ? `<div class="text-xs text-cyan-200 mt-1">${priorityLabel}</div>` : ''}
              </div>
            </div>
            <div class="flex flex-wrap gap-2 items-center">
              <button data-song-action="select" data-song-id="${song.id}" class="px-3 py-2 rounded-lg text-sm font-semibold border ${isSelected?'border-cyan-400 bg-cyan-500/20 text-cyan-100':'border-white/10 bg-white/5 text-gray-200'}">Select</button>
              <button class="previewBtn px-3 py-2 bg-white/10 hover:bg-white/20 rounded-lg text-sm" data-song-action="preview" data-song-id="${song.id}">Preview</button>
              <button data-song-action="toggle-owned" data-song-id="${song.id}" class="px-3 py-2 ${ownedButtonClass} rounded-lg text-sm font-medium transition" ${ownedDisabled ? 'disabled style="opacity:0.5;cursor:not-allowed;"' : ''}>${ownedButtonLabel}</button>
              <button data-song-action="toggle-setlist" data-song-id="${song.id}" class="addSetBtn px-4 py-2 ${setlistButtonClass} rounded-lg text-sm font-medium transition" ${setlistDisabled ? 'disabled style="opacity:0.5;cursor:not-allowed;"' : ''}>${setlistButtonLabel}</button>
              <button data-song-action="add-sandbox" data-song-id="${song.id}" class="px-3 py-2 bg-blue-600/30 hover:bg-blue-600/50 border border-blue-400/40 rounded-lg text-sm font-medium transition" ${sandboxTracks.find(t=>t.id===song.id) ? 'disabled style="opacity:0.5;cursor:not-allowed;"' : ''}>+ Sandbox</button>
              ${selectedSong ? `<div class="${pct!==null?glowClass:''} ml-2 px-3 py-2 score-badge">${pct!==null?pct+'%':'â€”'}</div>` : ''}
            </div>
          </div>
        `;
      }).join('');

      const loadingSkeleton = Array.from({ length: 10 }).map(()=>`
        <div class="skeleton-card">
          <div class="skeleton-line long"></div>
          <div class="skeleton-line medium"></div>
          <div class="skeleton-line short"></div>
        </div>
      `).join('');
      const loadingBlock = trackLoadState.status === 'loading' && !songs.length
        ? `<div class="space-y-3">
            <div class="inline-banner">Loading tracksâ€¦ <span id="trackLoadProgress">${trackLoadState.total ? `Loaded ${trackLoadState.loaded}/${trackLoadState.total}` : ''}</span></div>
            <div class="song-grid grid gap-4">${loadingSkeleton}</div>
          </div>`
        : '';
      const refreshBanner = trackLoadState.status === 'refreshing'
        ? `<div class="inline-banner">Refreshing tracks in the backgroundâ€¦</div>`
        : '';
      const emptyOwnedCallout = (!viewingProfile && ownedTracks.length === 0 && !quickStartDone)
        ? (isGuest
          ? `<div class="panel p-4 bg-purple-500/10 border border-purple-400/30 text-sm text-purple-100 space-y-2">
              <div class="font-semibold text-white">Sign in to track Owned songs</div>
              <div class="text-xs text-purple-200">Owned tracks and setlists are saved to your profile.</div>
              <button data-action="signInPrompt" class="px-4 py-2 rounded-lg bg-purple-500/20 border border-purple-400/40 text-white font-semibold">Sign In</button>
            </div>`
          : `<div class="panel p-4 bg-cyan-500/10 border border-cyan-400/30 text-sm text-cyan-100 space-y-2">
              <div class="font-semibold text-white">Step 1: Mark songs you own (start small)</div>
              <div class="text-xs text-cyan-200">Quick Start marks a starter set so you can see mixes fast.</div>
              <button data-action="openQuickStart" class="px-4 py-2 rounded-lg bg-cyan-500/20 border border-cyan-400/40 text-white font-semibold">Quick Start</button>
            </div>`)
        : '';
      const matchHint = matchHintMessage ? `<div class="inline-banner">${matchHintMessage}</div>` : '';
      const listContent = loadingBlock || (scored.length
        ? `<div id="mainPaginationTop"></div>${refreshBanner}${trackLoadNotice ? `<div class="inline-banner">${trackLoadNotice}</div>` : ''}${emptyOwnedCallout}${matchHint}<div class="song-grid grid gap-4">${cardGrid}</div>${mobileControls}<div id="mainPaginationBottom"></div>`
        : `<div class="panel p-6 text-center text-gray-300 space-y-3"><div>No songs match your filters yet.</div><button data-action="clearFilters" class="px-4 py-2 rounded-lg bg-white/10 border border-white/20 text-sm text-white">Clear filters</button></div>`);

      songListEl.innerHTML = priorityHeader + listContent;
      if(scored.length && !isMobile){
        const renderPagination = (targetId)=>{
          const targetEl = document.getElementById(targetId);
          renderPaginationBar(targetEl, mainPager, {
            onPageChange: (nextIndex)=>{
              mainPager.pageIndex = Math.max(0, nextIndex);
              persistMainPagerState();
              scheduleSongListRender('page-change', { scrollToTop: true });
            },
            onPageSizeChange: (nextSize)=>{
              setPageSize(mainPager, nextSize);
              persistMainPagerState();
              scheduleSongListRender('page-size', { scrollToTop: true });
            }
          }, { totalItems: scored.length, totalPages, from: showingStart, to: showingEnd });
        };
        renderPagination('mainPaginationTop');
        renderPagination('mainPaginationBottom');
      }
      if(trackLoadState.status === 'loading') updateTrackLoadProgressUI();
      if(!firstListRenderLogged && songsLoaded && loadSongsStartTime){
        const elapsed = Math.round(performance.now() - loadSongsStartTime);
        console.log(`[perf] First list render in ${elapsed}ms (source: ${trackSource})`);
        firstListRenderLogged = true;
      }
      if(isMobile){
        const sentinel = document.getElementById('songListSentinel');
        if(mobileListObserver){
          mobileListObserver.disconnect();
          mobileListObserver = null;
        }
        if(sentinel){
          mobileListObserver = new IntersectionObserver((entries) => {
            if(entries.some(entry=>entry.isIntersecting)){
              if(mobileWindowState.count < MOBILE_MAX_CARDS){
                mobileWindowState.count = Math.min(MOBILE_MAX_CARDS, mobileWindowState.count + MOBILE_PAGE_CHUNK);
                scheduleSongListRender('mobile-load-more');
              }
            }
          }, { rootMargin: '200px' });
          mobileListObserver.observe(sentinel);
        }
        if(songsLoaded && !maxCardsLogged && maxMobileCardsRendered){
          console.log(`[perf] Mobile max cards rendered at once: ${maxMobileCardsRendered}`);
          maxCardsLogged = true;
        }
      }
    }

    function renderSetlist(){
      const setlistEl = document.getElementById('setlistContent'); if(!setlistEl) return;
      if(isGuestUser() && !viewingProfile){
        setlistEl.innerHTML = `<div class="text-center py-12 text-white space-y-4">
          <div class="text-5xl">ðŸ”’</div>
          <p class="text-xl font-semibold">Sign in to save setlists</p>
          <p class="text-sm text-gray-300">Setlists sync to your profile after sign-in.</p>
          <button data-action="signInPrompt" class="px-6 py-3 bg-gradient-to-r from-purple-500 to-pink-500 rounded-lg font-bold">Sign In</button>
        </div>`;
        return;
      }
      if(setlist.length===0){
        setlistEl.innerHTML = `<div class="text-center py-12"><div class="text-6xl mb-4">ðŸŽµ</div><p class="text-xl mb-4 text-white">Your setlist is empty</p><button data-action="switchView" data-view="browse" class="px-6 py-3 bg-gradient-to-r from-purple-500 to-pink-500 rounded-lg font-bold">Browse Tracks</button></div>`;
        return;
      }
      if(!songsById || Object.keys(songsById).length === 0){
        setlistEl.innerHTML = `<div class="text-center py-12 text-white space-y-3">
          <div class="text-4xl">â³</div>
          <p class="text-lg font-semibold">Loading tracksâ€¦</p>
          <p class="text-sm text-gray-300">Setlist will appear in a moment.</p>
        </div>`;
        return;
      }
      const setlistRows = setlist.map((id, i)=>{
        const song = songsById[id];
        if(!song){
          return `<div class="bg-black/40 backdrop-blur-sm border border-red-500/40 rounded-xl p-4 flex items-center gap-4 hover:border-red-400 transition">
            <div class="text-2xl font-bold text-pink-400">${i+1}</div>
            <div class="flex-1">
              <div class="font-bold text-lg text-white">Missing track (unavailable)</div>
              <div class="text-gray-300 text-sm">Track ID: <span class="font-mono text-orange-300">${id}</span></div>
            </div>
            <button data-action="removeSet" data-id="${id}" class="p-2 hover:bg-red-500/20 rounded text-red-400 text-xl">âœ•</button>
          </div>`;
        }
        return `<div class="bg-black/40 backdrop-blur-sm border border-gray-700 rounded-xl p-4 flex items-center gap-4 hover:border-cyan-400 transition">
          <div class="text-2xl font-bold text-pink-400">${i+1}</div>
          ${song.albumArt?`<img src="${song.albumArt}" class="w-16 h-16 rounded-lg"/>`:''}
          <div class="flex-1">
            <div class="font-bold text-lg text-white">${song.title}</div>
            <div class="text-gray-300">${song.artist}</div>
            <div class="text-xs text-orange-300">${song.genre}</div>
          </div>
          <div class="text-xl font-mono font-bold" style="color:${camelotColors[song.camelot]}">${song.camelot}</div>
          <button data-action="removeSet" data-id="${song.id}" class="p-2 hover:bg-red-500/20 rounded text-red-400 text-xl">âœ•</button>
        </div>`;
      }).join('');
      setlistEl.innerHTML = `<div class="space-y-4">${setlistRows}</div>`;
    }

    function renderProfile(){
      const profileEl = document.getElementById('profileView'); if(!profileEl) return;
      if(DEBUG_UI) console.log('[debug][profile] renderProfile');
      bindUiDebugging();
      bindProfileHandlers();
      const viewOnly = !!viewingProfile;
      const isGuest = isGuestUser();
      if(!viewOnly && (!draftProfile || (currentUser?.username && draftProfile.username !== currentUser.username))){
        refreshDraftProfileFromCurrentUser();
      }
      const profileOwner = viewingProfile || currentUser || {};
      const usernameVal = profileOwner?.username || '';
      const signedIn = !!firebaseAuth?.currentUser;
      const fallbackUid = profileOwner?.uid || firebaseAuth?.currentUser?.uid || '';
      const shortUid = fallbackUid ? fallbackUid.slice(0, 8) : '';
      const djVal = profileOwner?.djName || usernameVal || (signedIn && shortUid ? `Signed in (${shortUid})` : 'DJ');
      const handleLabel = usernameVal
        ? `@${escapeHtml(usernameVal)}`
        : (signedIn && shortUid ? `@uid-${escapeHtml(shortUid)}` : '@guest');
      const storageNote = !viewOnly
        ? (isGuest ? 'Stored on this device.' : (isOffline ? 'Offline â€” sync paused' : 'Synced to cloud.'))
        : '';
      const ownedIds = normalizeOwnedList(profileOwner?.ownedTracks || []);
      const songIdSet = new Set((songs || []).map(song => song.id));
      const ownedIntersect = ownedIds.filter(id => songIdSet.has(id));
      const ownedCount = ownedIntersect.length;
      const ownedTotal = songs.length;
      const ownedEmptyState = ownedCount === 0 && !isGuest
        ? '<div class="text-xs text-gray-300">Start marking tracks as Owned in Browse.</div>'
        : '';
      const dangerDisabled = viewOnly ? 'disabled aria-disabled="true" style="opacity:0.5;cursor:not-allowed;"' : '';
      const dangerDisabledNote = viewOnly
        ? '<div class="text-xs text-red-200/80">Danger Zone actions are disabled while viewing a bandmate profile.</div>'
        : '';
      const fallbackBanner = boot.usedFallbackSongs
        ? '<div class="panel border border-amber-400/40 bg-amber-500/10 text-amber-100 text-sm">Track list failed to load â€” using fallback list</div>'
        : '';
      const guestBanner = (!viewOnly && isGuest)
        ? `<div class="panel border border-purple-400/40 bg-purple-500/10 text-purple-100 text-sm flex items-center justify-between gap-3 flex-wrap">
            <span>Guest profile â€” sign in to save owned tracks, setlists, and bandmates.</span>
            <button data-action="signInPrompt" class="px-3 py-2 bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/40 rounded-lg profile-hit-target text-sm">Sign In</button>
          </div>`
        : '';
      const viewBanner = viewOnly
        ? `<div class="panel border border-purple-400/40 bg-purple-500/10 text-purple-100 text-sm flex items-center justify-between gap-3 flex-wrap">
            <span>Viewing: ${escapeHtml(djVal)} (read-only)</span>
            <button data-action="profile.exitViewMode" class="px-3 py-2 bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/40 rounded-lg profile-hit-target text-sm">Back to My Profile</button>
          </div>`
        : '';
      const bandmateList = (viewOnly ? (profileOwner?.bandMembers || []) : (bandMembers || []))
        .filter(Boolean);
      const bandmatePills = (isGuest && !viewOnly)
        ? '<div class="text-sm text-gray-400">Sign in to manage bandmates.</div>'
        : (bandmateList.length
          ? `<div class="flex flex-wrap gap-2">
              ${bandmateList.map(member => {
                const name = escapeHtml(member?.djName || member?.username || 'Bandmate');
                const handle = escapeHtml(member?.username || '');
                const label = handle ? `${name} â€¢ @${handle}` : name;
                return `<button type="button" data-action="profile.viewBandmate" data-username="${escapeHtml(member?.username || member?.uid || '')}" class="px-3 py-2 rounded-full bg-white/10 hover:bg-white/20 border border-white/10 text-sm font-semibold profile-hit-target">${label}</button>`;
              }).join('')}
            </div>`
          : '<div class="text-sm text-gray-400">No bandmates yet.</div>');
      const bandmateForm = (!viewOnly && !isGuest)
        ? `<div class="flex flex-col sm:flex-row gap-2">
            <input id="bandmateInput" placeholder="Add bandmate username" class="flex-1 px-4 py-3 bg-black/40 border border-white/10 rounded-lg text-white" />
            <button type="button" data-action="profile.addBandmate" class="px-4 py-3 bg-gradient-to-r from-purple-500 to-pink-500 rounded-lg font-semibold profile-hit-target">+ Add Bandmate</button>
          </div>`
        : '';
      const syncDebug = buildSyncDebugPayload();
      const syncDebugPanel = showSyncDebugPanel
        ? `<div class="panel space-y-3 border border-cyan-500/30 bg-black/40">
            <div class="flex items-center justify-between flex-wrap gap-2">
              <div>
                <div class="text-lg font-bold text-white">Sync Debug</div>
                <div class="text-xs text-cyan-200">Debug mode enabled (?debug=1)</div>
              </div>
              <div class="flex gap-2">
                <button type="button" data-action="profile.retrySync" class="px-3 py-2 rounded-lg bg-white/10 hover:bg-white/20 border border-white/10 text-xs font-semibold">Retry Sync</button>
                <button type="button" data-action="profile.exportBackup" class="px-3 py-2 rounded-lg bg-white/10 hover:bg-white/20 border border-white/10 text-xs font-semibold">Export Backup JSON</button>
              </div>
            </div>
            <div class="grid sm:grid-cols-2 gap-3 text-xs text-gray-200">
              <div><span class="text-gray-400">Auth:</span> ${syncDebug.signedIn ? 'Signed in' : 'Signed out'}</div>
              <div><span class="text-gray-400">UID:</span> ${escapeHtml(syncDebug.uid || 'â€”')}</div>
              <div><span class="text-gray-400">Provider:</span> ${escapeHtml(syncDebug.provider)}</div>
              <div><span class="text-gray-400">Firestore:</span> ${syncDebug.firebaseReady ? 'Ready' : 'Unavailable'}</div>
              <div><span class="text-gray-400">Online:</span> ${syncDebug.online ? 'Yes' : 'No'}</div>
              <div><span class="text-gray-400">Sync state:</span> ${escapeHtml(syncDebug.syncState)}</div>
              <div><span class="text-gray-400">Pending ops:</span> ${syncDebug.pendingOwnedOps}</div>
              <div><span class="text-gray-400">Last synced:</span> ${formatSyncTimestamp(syncDebug.lastSyncedAt)}</div>
              <div><span class="text-gray-400">Last hash:</span> ${escapeHtml(syncDebug.lastSyncHash || 'â€”')}</div>
              <div><span class="text-gray-400">Last error:</span> ${escapeHtml(syncDebug.lastErrorMessage || syncDebug.errorCode || 'â€”')}</div>
              <div><span class="text-gray-400">Error step:</span> ${escapeHtml(syncDebug.errorStep || 'â€”')}</div>
              <div><span class="text-gray-400">Boot started:</span> ${window.__BOOT__?.startedAt ? new Date(window.__BOOT__.startedAt).toLocaleTimeString() : 'â€”'}</div>
              <div><span class="text-gray-400">Boot last step:</span> ${escapeHtml(window.__BOOT__?.steps?.length ? window.__BOOT__.steps[window.__BOOT__.steps.length - 1].step : 'â€”')}</div>
              <div class="sm:col-span-2"><span class="text-gray-400">Boot last error:</span> ${escapeHtml(window.__BOOT__?.lastError || 'â€”')}</div>
            </div>
            <div class="text-xs text-gray-300 space-y-1">
              ${(window.__BOOT__?.steps || []).slice(-6).map(entry => `<div class="flex items-start justify-between gap-3"><span>${escapeHtml(entry.step)}</span><span class="text-gray-500">${escapeHtml(entry.at)}</span></div>`).join('') || '<div>No boot steps recorded.</div>'}
            </div>
          </div>`
        : '';
      profileEl.innerHTML = `
        <div class="space-y-4 max-w-4xl mx-auto">
          ${fallbackBanner}
          ${guestBanner}
          ${viewBanner}
          <div class="panel space-y-3">
            <div>
              <div class="text-3xl font-bold text-white">${escapeHtml(djVal)}</div>
              <div class="text-sm text-gray-300">${handleLabel}</div>
              ${storageNote ? `<div class="text-xs text-cyan-200 mt-1">${storageNote}</div>` : ''}
            </div>
          </div>
          <div class="panel space-y-4">
            <div class="flex items-start justify-between gap-3">
              <div>
                <div class="text-lg font-bold text-white">Owned Tracks</div>
                <p class="text-sm text-gray-300">Epic doesnâ€™t share ownershipâ€”mark your tracks manually.</p>
              </div>
              <div class="text-3xl font-bold text-white">${isGuest ? `Tracks: ${ownedTotal}` : `Owned: ${ownedCount} <span class="text-base text-gray-300">/ ${ownedTotal}</span>`}</div>
            </div>
            <div class="flex flex-wrap gap-2">
              ${isGuest ? '<button type="button" data-action="signInPrompt" class="px-4 py-2 rounded-lg bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/40 font-semibold profile-hit-target">Sign in to manage Owned</button>' : '<button type="button" data-action="profile.viewOwned" class="px-4 py-2 rounded-lg bg-white/10 hover:bg-white/20 border border-white/10 font-semibold profile-hit-target">View Owned</button>'}
            </div>
            ${ownedEmptyState}
          </div>
          <div class="panel space-y-4">
            <div class="flex items-start justify-between gap-3">
              <div>
                <div class="text-lg font-bold text-white">Library Management</div>
                <p class="text-sm text-gray-300">Quick tools for your collection and profile backups.</p>
              </div>
              <div class="text-2xl font-bold text-white">${ownedCount} <span class="text-base text-gray-400">/ ${ownedTotal} owned</span></div>
            </div>
            <div class="flex flex-wrap gap-2">
              <button type="button" data-action="profile.exportLibrary" class="px-4 py-2 rounded-lg bg-white/10 hover:bg-white/20 border border-white/10 font-semibold profile-hit-target">Export Library</button>
              <button type="button" data-action="profile.importLibrary" class="px-4 py-2 rounded-lg bg-white/10 hover:bg-white/20 border border-white/10 font-semibold profile-hit-target">Import Library</button>
            </div>
          </div>
          <div class="panel space-y-4 border border-red-500/50 bg-red-500/10">
            <div class="flex items-center justify-between flex-wrap gap-2">
              <div>
                <div class="text-lg font-bold text-red-200">Danger Zone</div>
                <p class="text-sm text-red-100/80">This wipes your Owned selection for this account.</p>
              </div>
              <div class="text-xs uppercase tracking-wide text-red-200 font-semibold border border-red-400/60 px-2 py-1 rounded">Proceed with care</div>
            </div>
            <div class="flex flex-wrap gap-2">
              <button id="profileClearOwnedBtn" type="button" data-action="profile.clearOwned" class="px-4 py-2 rounded-lg bg-red-500/30 hover:bg-red-500/40 border border-red-500/60 font-semibold text-red-100 profile-hit-target" ${dangerDisabled}>Clear Owned Tracks</button>
              <button type="button" data-action="profile.resetFilters" class="px-4 py-2 rounded-lg bg-white/10 hover:bg-white/20 border border-white/10 font-semibold profile-hit-target" ${dangerDisabled}>Reset Filters</button>
            </div>
            ${dangerDisabledNote}
          </div>
          <div class="panel space-y-4">
            <div>
              <div class="text-lg font-bold text-white">Bandmates</div>
              <p class="text-sm text-gray-300">Bandmates are read-only; you can view their collections.</p>
            </div>
            ${bandmatePills}
            ${bandmateForm}
            <div id="profileStatus" class="text-sm text-cyan-200"></div>
          </div>
          ${syncDebugPanel}
        </div>`;
      updateTourUI();
    }

    function renderAuditView(){
      const auditEl = document.getElementById('auditView');
      if(!auditEl) return;
      if(!isAdmin()){ auditEl.innerHTML = '<div class="panel">Admin only</div>'; return; }
      const total = songs.length;
      const flaggedCount = songs.filter(s=>s.flags && s.flags.length).length;
      const camelotCount = Object.keys(camelotOverridesStore.ids||{}).length;
      const bpmCount = Object.keys(bpmOverridesStore.ids||{}).length;
      const okCount = total - flaggedCount;
      const filterMatches = (track)=>{
        const term = (auditSearch||'').toLowerCase();
        if(term && !(track.title.toLowerCase().includes(term) || track.artist.toLowerCase().includes(term))) return false;
        if(auditFilters.flaggedOnly && !(track.flags&&track.flags.length)) return false;
        if(auditFilters.overriddenOnly && !(track.camelotOverridden||track.bpmOverridden)) return false;
        if(auditFilters.invalidCamelot && !(track.flags||[]).includes('INVALID_CAMELOT')) return false;
        if(auditFilters.modeMismatch && !(track.flags||[]).includes('MODE_MISMATCH')) return false;
        if(auditFilters.bpmOutlier && !(track.flags||[]).includes('BPM_OUTLIER')) return false;
        return true;
      };
        const filtered = songs.filter(filterMatches);
        const rows = filtered.map(t=>{
          const flags = t.flags && t.flags.length ? t.flags.map(f=>`<span class="px-2 py-1 rounded bg-white/10 border border-white/10 text-xs mr-1">${f}</span>`).join('') : '<span class="text-green-300 text-xs">OK</span>';
          const hasOverride = genreOverrides[t.id];
          const genreButton = `<button data-song-id-genre="${t.id}" class="px-2 py-1 ${hasOverride ? 'bg-green-500/30 border-green-500/50' : 'bg-orange-500/30 border-orange-500/50'} border rounded text-xs cursor-pointer hover:border-cyan-400/60" title="Click to edit genre">${t.genre}${hasOverride ? ' âœ“' : ''}</button>`;
          return `<tr class="border-b border-white/5"><td class="p-2">${t.title}<div class="text-xs text-gray-400">${t.artist}</div></td><td class="p-2">${t.bpm} <div class="text-xs text-gray-400">raw ${t.rawBpm||t.bpm}</div></td><td class="p-2">${t.camelot}<div class="text-xs text-gray-400">derived ${t.derivedCamelot}</div></td><td class="p-2 text-xs text-gray-300">${t.rawKey||'?'} ${t.rawMode||''}</td><td class="p-2">${genreButton}</td><td class="p-2">${flags}</td><td class="p-2 text-xs"><button class="px-2 py-1 bg-purple-500/30 rounded" onclick="openOverrideModal('camelot','${t.id}')">Set Camelot</button><button class="ml-1 px-2 py-1 bg-blue-500/30 rounded" onclick="openOverrideModal('bpm','${t.id}')">Set BPM</button><button class="ml-1 px-2 py-1 bg-red-500/30 rounded" onclick="clearOverrides('${t.id}')">Clear</button></td></tr>`;
        }).join('');

      auditEl.innerHTML = `
        <div class="space-y-4">
          <div class="grid md:grid-cols-5 gap-3">
            <div class="panel p-3"><div class="text-xs text-gray-400">Total tracks</div><div class="text-2xl font-bold">${total}</div></div>
            <div class="panel p-3"><div class="text-xs text-gray-400">OK</div><div class="text-2xl font-bold text-green-300">${okCount}</div></div>
            <div class="panel p-3"><div class="text-xs text-gray-400">Flagged</div><div class="text-2xl font-bold text-amber-300">${flaggedCount}</div></div>
            <div class="panel p-3"><div class="text-xs text-gray-400">Camelot overrides</div><div class="text-2xl font-bold">${camelotCount}</div></div>
            <div class="panel p-3"><div class="text-xs text-gray-400">BPM overrides</div><div class="text-2xl font-bold">${bpmCount}</div></div>
          </div>
          <div class="panel p-3 space-y-3">
            <div class="flex flex-wrap gap-2 items-center">
              <input id="auditSearchInput" value="${auditSearch}" placeholder="Search title or artist" class="flex-1 min-w-[200px] px-3 py-2 bg-black/40 border border-white/10 rounded" />
            </div>
            <div class="flex flex-wrap gap-2 text-xs">
              <button class="px-3 py-1 rounded ${auditFilters.flaggedOnly?'bg-amber-500/40':'bg-white/10'}" onclick="toggleAuditFilter('flaggedOnly')">Show flagged only</button>
              <button class="px-3 py-1 rounded ${auditFilters.overriddenOnly?'bg-amber-500/40':'bg-white/10'}" onclick="toggleAuditFilter('overriddenOnly')">Show overridden only</button>
              <button class="px-3 py-1 rounded ${auditFilters.invalidCamelot?'bg-amber-500/40':'bg-white/10'}" onclick="toggleAuditFilter('invalidCamelot')">Invalid camelot</button>
              <button class="px-3 py-1 rounded ${auditFilters.modeMismatch?'bg-amber-500/40':'bg-white/10'}" onclick="toggleAuditFilter('modeMismatch')">Mode mismatch</button>
              <button class="px-3 py-1 rounded ${auditFilters.bpmOutlier?'bg-amber-500/40':'bg-white/10'}" onclick="toggleAuditFilter('bpmOutlier')">BPM outliers</button>
            </div>
          </div>
          <div class="panel overflow-auto">
            <table class="w-full text-sm">
              <thead class="text-left text-gray-300">
                <tr><th class="p-2">Title</th><th class="p-2">BPM</th><th class="p-2">Camelot</th><th class="p-2">Raw key/mode</th><th class="p-2">Genre</th><th class="p-2">Flags</th><th class="p-2">Actions</th></tr>
              </thead>
              <tbody>${rows}</tbody>
            </table>
          </div>
          <div class="panel text-xs text-gray-300">
            <div class="font-semibold text-white mb-1">Debug</div>
            <div>Firebase enabled: ${firebaseEnabled}</div>
            <div>User key: ${computeUserKey()}</div>
            <div>Songs loaded: ${songs.length}</div>
            <div>Overrides loaded: ${camelotCount} camelot / ${bpmCount} bpm</div>
          </div>
        </div>
      `;
      bindGenreEditors(auditEl);
    }

function renderCommunityStat(id, label, icon, value, caption=''){
  return `<div class="flex items-center justify-between px-3 py-2 rounded-lg border border-white/10 bg-white/5">
    <div class="flex items-center gap-2">
      <span>${icon}</span>
      <div class="flex flex-col leading-tight">
        <span class="text-[10px] uppercase tracking-wide text-gray-300">${label}</span>
        <span class="text-sm font-bold text-white" data-community-stat="${id}">${formatStatValue(value)}</span>
      </div>
    </div>
    ${caption ? `<span class="text-[11px] text-cyan-100/80">${caption}</span>` : ''}
  </div>`;
}

function renderBootScreen(message){
  const text = message || 'Loading Festival Jam Tracksâ€¦';
  document.getElementById('app').innerHTML = `
    <div class="min-h-screen flex items-center justify-center bg-black text-white">
      <div class="text-center space-y-4">
        <div class="w-16 h-16 mx-auto rounded-full border-4 border-cyan-400/40 border-t-cyan-300 animate-spin"></div>
        <div class="text-lg font-semibold">Loadingâ€¦</div>
        <div class="text-sm text-cyan-200">${text}</div>
      </div>
    </div>
  `;
}

function resolveExplicitView(value){
  if(!value) return null;
  const normalized = String(value).trim().toLowerCase();
  if(['browse', 'browser', 'profile', 'setlist', 'audit'].includes(normalized)) return normalized === 'browser' ? 'browse' : normalized;
  return null;
}

function renderBootstrapGate(message){
  const text = message || 'Loading your accountâ€¦';
  document.getElementById('app').innerHTML = `
    <div class="min-h-screen flex items-center justify-center bg-black text-white">
      <div class="text-center space-y-4">
        <div class="w-16 h-16 mx-auto rounded-full border-4 border-cyan-400/40 border-t-cyan-300 animate-spin"></div>
        <div class="text-lg font-semibold">Loadingâ€¦</div>
        <div class="text-sm text-cyan-200">${text}</div>
      </div>
    </div>
`;
}

let bootDeadlineTimer = null;
function startBootDeadline(){
  if(bootDeadlineTimer) clearTimeout(bootDeadlineTimer);
  boot.startedAt = Date.now();
  window.__BOOT__ = { steps: boot.logs.slice(), lastError: boot.lastError, startedAt: boot.startedAt };
  bootDeadlineTimer = setTimeout(() => {
    if([APP_BOOT_STATES.signedOut, APP_BOOT_STATES.ready, APP_BOOT_STATES.fatal].includes(appBootState)) return;
    const lastStep = window.__BOOT__?.steps?.length ? window.__BOOT__.steps[window.__BOOT__.steps.length - 1].step : 'Unknown';
    const error = new Error(`Boot timed out (last step: ${lastStep})`);
    showFatalBootError(error);
  }, BOOT_DEADLINE_MS);
}

function clearBootDeadline(){
  if(bootDeadlineTimer){
    clearTimeout(bootDeadlineTimer);
    bootDeadlineTimer = null;
  }
}

function trimBootErrorMessage(message, maxLength = 180){
  if(!message) return '';
  const normalized = String(message);
  if(normalized.length <= maxLength) return normalized;
  return `${normalized.slice(0, maxLength).trim()}â€¦`;
}
function buildBootDebugPayload(){
  const steps = window.__BOOT__?.steps || boot.logs || [];
  return JSON.stringify({
    startedAt: window.__BOOT__?.startedAt || boot.startedAt,
    lastError: window.__BOOT__?.lastError || boot.lastError || null,
    steps
  }, null, 2);
}
function copyBootDebug(){
  const payload = buildBootDebugPayload();
  if(navigator.clipboard?.writeText){
    navigator.clipboard.writeText(payload)
      .then(()=>{ alert('Boot debug copied.'); })
      .catch(()=>{ alert('Copy failed.'); });
    return;
  }
  const textarea = document.createElement('textarea');
  textarea.value = payload;
  textarea.style.position = 'fixed';
  textarea.style.opacity = '0';
  document.body.appendChild(textarea);
  textarea.focus();
  textarea.select();
  try{
    document.execCommand('copy');
    alert('Boot debug copied.');
  }catch(e){
    alert('Copy failed.');
  }finally{
    textarea.remove();
  }
}
function renderBootstrapFatal(errorMessage){
  const message = errorMessage || 'Something went wrong while preparing the app.';
  const trimmed = trimBootErrorMessage(message);
  const bootSteps = window.__BOOT__?.steps || boot.logs || [];
  const logRows = bootSteps.slice(-5).map((entry)=>(
    `<div class="flex items-start justify-between gap-3 text-xs text-cyan-100/90">
      <span>${entry.step}</span>
      <span class="text-gray-400">${entry.at}</span>
    </div>`
  )).join('') || '<div class="text-xs text-gray-400">No boot steps recorded.</div>';
  const lastStep = bootSteps?.length ? bootSteps[bootSteps.length - 1].step : 'Unknown';
  const lastError = (window.__BOOT__?.lastError || boot.lastError) ? trimBootErrorMessage(window.__BOOT__?.lastError || boot.lastError) : trimmed;
  document.getElementById('app').innerHTML = `
    <div class="min-h-screen flex items-center justify-center bg-black text-white">
      <div class="max-w-md text-center space-y-4 bg-black/60 border border-red-500/40 rounded-2xl p-6">
        <div class="text-xl font-bold text-red-200">Something went wrong while loading your profile.</div>
        <div class="text-sm text-gray-200">${trimmed}</div>
        <div class="flex items-center justify-center gap-3">
          <button onclick="location.reload()" class="px-4 py-2 rounded-lg bg-gradient-to-r from-pink-500 to-cyan-500 text-white font-bold">Retry</button>
          <button onclick="copyBootDebug()" class="px-4 py-2 rounded-lg bg-white/10 border border-white/20 text-white">Copy Debug</button>
        </div>
        <div class="text-left text-sm text-gray-200 border border-white/10 rounded-xl p-4 space-y-3 bg-black/70">
          <div class="text-xs uppercase tracking-wide text-gray-400">Last step</div>
          <div class="text-sm font-semibold text-cyan-100">${lastStep}</div>
          <div class="text-xs uppercase tracking-wide text-gray-400">Last error</div>
          <div class="text-sm text-red-200">${lastError}</div>
          <div class="text-xs uppercase tracking-wide text-gray-400">Recent boot steps</div>
          <div class="space-y-2">${logRows}</div>
        </div>
      </div>
    </div>
  `;
}

function setAppBootState(state, { error } = {}){
  appBootState = state;
  bootState = state;
  bootstrapFatalError = error || null;
  if(state === APP_BOOT_STATES.fatal){
    clearBootDeadline();
    if(bootstrapFatalError){
      recordBootError(bootstrapFatalError);
    }
    recordBootStep('BOOT: fatal');
    renderBootstrapFatal(bootstrapFatalError?.message || String(bootstrapFatalError || 'Startup failed'));
    return;
  }
  if(state === APP_BOOT_STATES.ready || state === APP_BOOT_STATES.signedOut){
    clearBootDeadline();
  }
  if(state === APP_BOOT_STATES.bootLoading || state === APP_BOOT_STATES.signedInLoading){
    renderBootstrapGate();
  }
}

function maybeShowRecoveryBanner(){
  const reasons = [];
  if(boot.usedFallbackSongs) reasons.push('Tracks restored from cache/fallback.');
  if(boot.usedSnapshotProfile) reasons.push('Library restored from snapshot.');
  if(writeFenceBlockedSave) reasons.push('Save paused to protect your library. Click Restore if needed.');
  recoveryBannerState = {
    visible: reasons.length > 0,
    message: reasons.length ? `Recovery mode active: ${reasons.join(' ')}` : ''
  };
}

async function restoreLastKnownGoodProfile(){
  const key = getProfileStorageKey();
  const snapshot = JSON.parse(localStorage.getItem(`${PROFILE_SNAPSHOT_PREFIX}${key}`) || 'null');
  if(!snapshot){
    alert('No recovery snapshot found yet.');
    return;
  }
  boot.usedSnapshotProfile = true;
  await applyProfileToState(snapshot, { loadOverrides: true, skipPersist: true });
  await persistProfileRobust(snapshot, { force: true });
  render();
  setupEventListeners();
  syncAllHeaderCountsAndButtons();
  maybeShowRecoveryBanner();
  maybeAutoStartTour();
}

async function retryTracksNow(){
  const result = await loadSongsRobust({ allowOneRetry: false });
  songs = result.songs || songs;
  boot.usedFallbackSongs = result.usedFallback;
  render();
  setupEventListeners();
  syncAllHeaderCountsAndButtons();
  maybeShowRecoveryBanner();
}

function syncAllHeaderCountsAndButtons(){
  updateOwnedCount();
  updateSetlistCountUI();
  updateStickyCTA();
}

async function loadAppData({ loadSongs = true, loadProfile = true, preferCache = false, legacyOwnedTracks = [], showBootScreen = true, allowProfileAutoOpen = true } = {}){
  try{
    boot.phase = 'init';
    boot.profileLoaded = false;
    boot.songsLoaded = false;
    boot.usedFallbackSongs = false;
    boot.usedSnapshotProfile = false;
    boot.errors = [];
    if(showBootScreen){
      renderBootScreen('Loading Festival Jam Tracksâ€¦');
    }

    if(loadProfile){
      boot.phase = 'loadingProfile';
      const profile = (firebaseEnabled && firebaseAuth?.currentUser)
        ? await hydrateProfileFromCloudThenMergeLocal(firebaseAuth.currentUser.uid, firebaseAuth.currentUser.email, { legacyOwnedTracks })
        : await hydrateProfileRobust();
      resetUiDefaults();
      await applyProfileToState(profile, { loadEpic: true, loadOverrides: true, skipPersist: true });
      if(allowProfileAutoOpen){
        await maybeLoadSharedProfile();
      }
      boot.profileLoaded = true;
    } else {
      boot.profileLoaded = false;
    }

    if(loadSongs){
      boot.phase = 'loadingSongs';
      const songResult = await loadSongsRobust({
        allowOneRetry: true,
        preferCache,
        onCacheApplied: () => {
          boot.songsLoaded = true;
          render();
          setupEventListeners();
          syncAllHeaderCountsAndButtons();
        }
      });
      songs = songResult.songs;
      boot.usedFallbackSongs = songResult.usedFallback;
      boot.songsLoaded = true;
    } else {
      boot.songsLoaded = songs.length > 0;
    }

    await loadRemoteConfig();

    if(boot.profileLoaded){
      boot.initialOwnedCount = getOwnedCountInSongs(ownedTracks);
    } else {
      boot.initialOwnedCount = 0;
    }

    boot.phase = boot.usedFallbackSongs ? 'degraded' : 'ready';
    recordBootStep('data loaded');

    render();
    setupEventListeners();
    syncAllHeaderCountsAndButtons();
    maybeShowRecoveryBanner();
  }catch(err){
    console.error('[boot] fatal error', err);
    setAppBootState(APP_BOOT_STATES.fatal, { error: err });
    throw err;
  }
}

function render(){
  if(appBootState !== APP_BOOT_STATES.ready){
    return;
  }
  logEvent('ui_render', { view });
  if(view === 'audit' && !isAdmin()){
    alert('Admin only');
    view = 'browse';
  }
  currentUser = getActiveProfile() || currentUser;
  if(!isAdmin() && adminMenuOpen){
    adminMenuOpen = false;
  }
  syncAdminGlobals();
  const displayTracks = viewingProfile ? viewingProfile.ownedTracks || [] : ownedTracks;
  const ownedCount = getOwnedCountInSongs(displayTracks);
  const isGuest = isGuestUser();
  const ownedLibraryStatusMessage = resolveOwnedLibraryStatusMessage();
  const ownedLibraryPhase = ownedLibraryState?.phase || 'idle';
  const ownedLibraryBadgeClass = ownedLibraryPhase === 'restoring' || ownedLibraryPhase === 'saving' || ownedLibraryPhase === 'syncing' || ownedLibraryPhase === 'error'
    ? 'inline-flex items-center gap-1 px-2 py-1 rounded-full text-[10px] font-semibold bg-white/10 border border-white/20 text-cyan-100'
    : 'text-[11px] text-cyan-100/90';
  const ownedLibraryBadge = ownedLibraryStatusMessage
    ? `<span class="${ownedLibraryBadgeClass}">${ownedLibraryStatusMessage}</span>`
    : '';
  const networkBadge = `<span data-network-badge class="${isOffline ? 'inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold bg-red-600/30 border border-red-400/60 text-red-100' : 'inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold bg-emerald-600/30 border border-emerald-400/60 text-emerald-100'}">${isOffline ? 'Offline' : 'Online'}</span>`;
  const trackSourceLabel = trackSource === 'cache' ? 'Cached tracks' : trackSource === 'fallback' ? 'Sample tracks' : 'Live tracks';
  const trackSourceBadge = `<span class="inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold bg-white/10 border border-white/20 text-cyan-100">ðŸŽµ ${trackSourceLabel}</span>`;
  const ownedSyncPhase = ownedLibraryState?.phase || 'idle';
  const ownedSyncError = ownedSyncPhase === 'error';
  const ownedSyncSaving = ownedSyncPhase === 'saving';
  const ownedSyncLabel = isOffline
    ? 'Offline â€” sync paused'
    : ownedSyncSaving
      ? 'Savingâ€¦'
      : ownedSyncError
        ? 'Error'
        : 'Synced';
  const cloudSyncBadge = (firebaseEnabled && firebaseAuth?.currentUser)
    ? `<button onclick="${ownedSyncError ? 'retryCloudSync()' : 'void 0'}" class="inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold ${isOffline || ownedSyncError ? 'bg-amber-500/20 border border-amber-300/60 text-amber-100' : ownedSyncSaving ? 'bg-sky-500/20 border border-sky-400/50 text-sky-100' : 'bg-emerald-500/20 border border-emerald-400/50 text-emerald-100'}" ${ownedSyncError ? '' : 'disabled'}>â˜ï¸ ${ownedSyncLabel}${ownedSyncError ? ' Â· Retry' : ''}</button>`
    : `<span class="inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold bg-slate-500/20 border border-slate-300/40 text-slate-100">ðŸ“¦ Local Only</span>`;
  const adminBadge = isAdmin() ? `<span class="ml-2 px-2 py-1 text-xs rounded border border-cyan-400/40 text-cyan-100 bg-white/5">ðŸ›¡ Admin</span>` : '';
  const syncInProgress = [SYNC_STATES.checkingAuth, SYNC_STATES.loadingRemote, SYNC_STATES.merging, SYNC_STATES.savingRemote].includes(syncState.state);
  const syncBanner = syncState.state === SYNC_STATES.error
    ? `<div class="inline-banner mt-2">âš ï¸ ${syncState.message || 'Sync failed.'} <button class="px-2 py-1 ml-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded" onclick="retryCloudSync()">Retry</button> <button class="px-2 py-1 ml-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded" onclick="exportOwnedBackupJson()">Export Backup JSON</button></div>`
    : (syncInProgress
      ? `<div class="inline-banner mt-2">ðŸ”„ ${syncState.message || 'Syncing your profileâ€¦'}</div>`
      : '');
  const ownedLibraryBanner = ownedLibraryState?.phase === 'error'
    ? `<div class="inline-banner mt-2">âš ï¸ ${ownedLibraryState.message || 'Owned library sync failed.'} <button class="px-2 py-1 ml-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded" onclick="retryCloudSync()">Retry</button> <button class="px-2 py-1 ml-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded" onclick="exportOwnedBackupJson()">Export Backup JSON</button></div>`
    : '';
  const recoveryBanner = recoveryBannerState?.visible
    ? `<div class="inline-banner mt-2">ðŸ›Ÿ ${recoveryBannerState.message || 'Recovery mode active.'} <button class="px-2 py-1 ml-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded" onclick="retryTracksNow()">Retry Tracks</button> <button class="px-2 py-1 ml-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded" onclick="restoreLastKnownGoodProfile()">Restore Library</button></div>`
    : '';
  const communityStatsRow = FEATURE_SIGNIN_STATS
    ? `
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2 mt-2 text-xs">
      ${renderCommunityStat('totalDjs','TOTAL DJS','ðŸŽ›ï¸', communityStats.totalDjs)}
    </div>`
    : '';
  const regressionBanner = (isAdmin() && regressionWarnings.length) ? `<div class="mt-2 p-3 rounded-lg border border-amber-400/40 bg-amber-500/10 text-amber-100 text-sm">Regression alerts: ${regressionWarnings.map(r=>`${r.id}â†’${r.expectedCamelot}`).join(', ')}</div>` : '';
  const selectedPanel = `
    <div class="panel ${selectedSong ? 'selected-panel' : ''} space-y-3 dim-when-sticky">
      <div class="flex items-center justify-between">
        <div class="font-bold text-white">Selection</div>
        <span class="text-xs text-cyan-100">${selectedSong ? 'Pinned track' : 'No track selected'}</span>
      </div>
      <div class="flex items-start gap-3">
        <div class="w-12 h-12 rounded-lg flex items-center justify-center text-lg font-bold" style="background:${selectedSong ? (camelotColors[selectedSong.camelot] || '#0ea5e9') : 'rgba(255,255,255,0.08)'};color:#fff;">${selectedSong ? selectedSong.camelot : 'â€”'}</div>
        <div class="flex-1">
          <div class="font-bold text-white">${selectedSong ? selectedSong.title : 'Select a track to pin it'}</div>
          <div class="text-sm text-gray-300">${selectedSong ? selectedSong.artist : 'Songs stay visible while you filter.'}</div>
          <div class="text-xs text-cyan-100 font-semibold mt-1">${selectedSong ? `BPM: ${selectedSong.bpm} â€¢ Camelot: ${selectedSong.camelot}` : 'Click any card or Select to choose.'}</div>
        </div>
      </div>
      <div class="flex flex-wrap gap-2">
        <button id="panelClearSelectionBtn" onclick="clearSelection()" class="px-3 py-2 bg-white/10 hover:bg-white/20 border border-cyan-400/60 rounded-lg font-semibold text-cyan-100" ${selectedSong ? '' : 'disabled style="opacity:0.55;cursor:not-allowed;"'}>Clear Selection</button>
        <button id="panelClearSearchBtn" onclick="clearSearch()" class="px-3 py-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded-lg font-semibold text-white" ${searchTerm ? '' : 'disabled style="opacity:0.55;cursor:not-allowed;"'}>Clear Search</button>
        <button id="panelDisableMixableBtn" onclick="disableMixable()" class="px-3 py-2 rounded-lg font-semibold border ${showMixableOnly?'border-cyan-300 bg-cyan-500/20 text-cyan-100':'border-white/20 bg-white/5 text-gray-300'}" ${showMixableOnly ? '' : 'disabled style="opacity:0.55;cursor:not-allowed;"'}>${showMixableOnly ? 'Disable Mixable' : 'Mixable Off'}</button>
      </div>
    </div>`;
  const adminLabel = currentUser?.isAdmin ? ' â€¢ ADMIN' : '';
  const signedInUid = firebaseAuth?.currentUser?.uid || currentUser?.uid || '';
  const signedInShortUid = signedInUid ? signedInUid.slice(0, 8) : '';
  const signedInDisplay = currentUser?.djName || currentUser?.username || (signedInShortUid ? `Signed in (${signedInShortUid})` : 'Signed in');
  const signedLabel = viewingProfile
    ? `Viewing ${viewingProfile.djName || viewingProfile.username || 'Profile'}${adminLabel}`
    : `${isGuest ? 'Guest Mode' : `Signed in as ${signedInDisplay}`}${adminLabel}`;
  const isSignedIn = firebaseEnabled ? !!firebaseAuth?.currentUser : !!currentUser;
  const authButtonLabel = isSignedIn && firebaseEnabled
    ? (logoutInProgress ? 'Savingâ€¦' : 'Logout')
    : 'Sign In';
  const authButtonAction = isSignedIn && firebaseEnabled
    ? (logoutInProgress ? 'void 0' : 'logoutUser()')
    : 'showLoginScreen()';
  const authButtonDisabled = isSignedIn && firebaseEnabled && logoutInProgress;
  const showAuthButton = firebaseEnabled ? true : !isSignedIn;
  const stickyCtaActive = getStickyCtaConfig().visible;
  const setlistLabel = isGuest ? 'Setlist (Sign in)' : 'Setlist';
  const profileLabel = isGuest ? 'Profile (Sign in)' : 'Profile';
  document.getElementById('app').innerHTML = `
    <div class="min-h-screen ${stickyCtaActive ? 'sticky-cta-active' : ''}" id="appRoot">
      <header class="bg-black/70 backdrop-blur-xl border-b border-cyan-500/30 sticky top-0 z-50 shadow-lg safe-header">
        <div class="max-w-[1400px] mx-auto px-4 py-4">
          <div class="flex items-center justify-between gap-4 flex-wrap">
            <div class="flex items-center gap-3">
              <div class="w-12 h-12 bg-gradient-to-br from-pink-500 via-purple-500 to-cyan-500 rounded-lg flex items-center justify-center text-2xl vinyl-spin">ðŸŽµ</div>
              <div>
                <h1 class="text-2xl font-bold text-white graffiti-text">${BRAND.APP_NAME.toUpperCase()}</h1>
                <div class="text-xs text-cyan-200 font-semibold">Festival Jam Mixer 1.2</div>
              </div>
            </div>
            <div class="flex items-center flex-wrap justify-end header-actions">
              <button class="mobile-only px-3 py-2 bg-white/10 border border-white/20 rounded-lg text-xs text-white" data-action="toggleHeaderMore">More</button>
              ${viewingProfile?`<button onclick="exitProfileViewMode()" class="px-3 py-2 bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/40 rounded-lg text-purple-100 text-sm">Back to my profile</button>`:''}
              ${(!viewingProfile && isAdmin())?`<div class="relative"><button id="adminToolsBtn" aria-haspopup="true" aria-expanded="${adminMenuOpen}" class="px-3 py-2 bg-cyan-500/20 hover:bg-cyan-500/30 border border-cyan-400/50 rounded-lg text-cyan-100 text-sm flex items-center gap-2" style="pointer-events:auto;cursor:pointer;">ðŸ› ï¸ Admin Tools</button>${adminMenuOpen?`<div id="adminToolsMenu" role="menu" class="admin-tools-menu absolute right-0 mt-2 w-56 bg-black/90 border border-cyan-400/30 rounded-lg shadow-xl ring-1 ring-cyan-400/30 p-2 space-y-2" style="z-index:6000;pointer-events:auto;">
                  <button id="adminMenuHelpEditor" role="menuitem" class="w-full text-left px-3 py-2 rounded-md bg-white/5 hover:bg-cyan-500/20 border border-white/10 text-sm">Help Editor</button>
                  <button id="adminMenuWhatsNewEditor" role="menuitem" class="w-full text-left px-3 py-2 rounded-md bg-white/5 hover:bg-cyan-500/20 border border-white/10 text-sm">Whatâ€™s New Editor</button>
                  <button id="adminMenuAudit" role="menuitem" class="w-full text-left px-3 py-2 rounded-md bg-white/5 hover:bg-cyan-500/20 border border-white/10 text-sm">Data Audit (Key/BPM)</button>
                </div>`:''}</div>`:''}
              <button onclick="openProfileView()" class="px-3 py-2 bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/50 rounded-lg text-purple-200 text-sm">Profile</button>
              <button onclick="openHelp()" class="px-3 py-2 bg-white/6 hover:bg-white/12 border border-cyan-500/20 rounded-lg text-cyan-200 text-sm">â“ Help</button>
              ${showAuthButton ? `<button onclick="${authButtonAction}" class="px-3 py-2 bg-red-500/20 hover:bg-red-500/30 border border-red-500/50 rounded-lg text-red-300 text-sm" ${authButtonDisabled ? 'disabled style="opacity:0.6;cursor:not-allowed;"' : ''}>${authButtonLabel}</button>` : ''}
            </div>
          </div>
          <div class="header-secondary ${headerMoreOpen ? 'is-open' : ''}">
            <div class="flex items-center flex-wrap gap-2">
              <p id="ownedCount" class="text-xs text-cyan-300 font-semibold">${getHeaderTrackCountLabel()}</p>
              ${ownedLibraryBadge}
              ${networkBadge}
              ${trackSourceBadge}
              ${cloudSyncBadge}
              <div class="text-sm text-gray-200">${signedLabel}${adminBadge}</div>
            </div>
            ${communityStatsRow}
          </div>
        </div>
      </header>

      <main class="max-w-[1400px] mx-auto px-4 py-6 space-y-4" style="padding-bottom: calc(6rem + var(--safe-bottom));">
        <div class="flex items-center justify-between gap-3 flex-wrap">
            <div class="flex gap-2 flex-wrap">
            <button id="browserBtn" data-action="switchView" data-view="browse" class="px-4 py-2 rounded-lg font-medium transition ${view==='browse'?'bg-gradient-to-r from-purple-500 to-pink-500':'bg-white/10 hover:bg-white/20'}">Browse</button>
            <div class="flex items-center gap-1">
              <button id="setlistBtn" data-action="switchView" data-view="setlist" class="px-4 py-2 rounded-lg font-medium transition ${view==='setlist'?'bg-gradient-to-r from-purple-500 to-pink-500':'bg-white/10 hover:bg-white/20'}">${setlistLabel} (<span id="setlistCount">${setlist.length}</span>)</button>
              <button type="button" class="helpIconBtn" onclick="openHelpModal({ source: 'setlist_icon', target: 'setlist' })" aria-label="Open help: Setlist" title="How Setlist works">?</button>
            </div>
            <button id="profileBtn" data-action="switchView" data-view="profile" class="px-4 py-2 rounded-lg font-medium transition ${view==='profile'?'bg-gradient-to-r from-indigo-500 to-blue-500':'bg-white/10 hover:bg-white/20'}">${profileLabel}</button>
          </div>
          ${view==='browse'?`<div class="text-sm text-cyan-200 font-semibold">Selected: ${selectedSong ? selectedSong.title : 'None'}</div>`:''}
        </div>
        <div class="flex items-center gap-2 flex-wrap text-sm text-cyan-100">
          ${networkBadge}
          ${trackSourceBadge}
          ${cloudSyncBadge}
          <span class="text-xs text-gray-300">${isOffline ? 'Offline â€” sync paused' : 'Cloud Sync active.'}</span>
        </div>

        ${syncBanner}
        ${ownedLibraryBanner}
        ${recoveryBanner}
        ${regressionBanner}
        <div id="browserView" style="display:${view==='browse'?'block':'none'}">
          <div class="grid lg:grid-cols-[350px,1fr] gap-4 items-start">
            <div class="space-y-4">
              <div class="panel space-y-2 dim-when-sticky">
                <div class="flex items-center justify-between">
                  <div class="font-bold text-white">Controls</div>
                  <span class="text-xs text-gray-300">${viewingProfile ? 'Shared profile (view only)' : (isGuest ? 'Guest mode' : 'Your library')}</span>
                </div>
                <div class="relative">
                  <input type="text" id="searchInput" value="${searchTerm || ''}" placeholder="ðŸ” Search songs" class="w-full px-4 py-3 pr-12 bg-black/40 backdrop-blur-sm border border-cyan-500/30 rounded-xl text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500"/>
                  <button id="clearSearchBtn" class="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-white transition text-xl" style="display:none;">âœ•</button>
                </div>
                <div id="searchStatus" class="text-xs text-cyan-200" style="display:none;">Filteringâ€¦</div>
                <div class="grid grid-cols-2 gap-2">
                  <button id="mixableFilterBtn" class="w-full min-h-[44px] px-3 py-2 rounded-lg font-medium transition ${showMixableOnly?'bg-gradient-to-r from-blue-500 to-cyan-500':'bg-white/10 hover:bg-white/20'}">${showMixableOnly? 'ðŸŽ§ Mixable Only' : 'Show Mixable'}</button>
                  <button id="ownedFilterBtn" class="w-full min-h-[44px] px-3 py-2 rounded-lg font-medium transition ${showOwnedOnly?'bg-gradient-to-r from-green-500 to-emerald-500':'bg-white/10 hover:bg-white/20'}" ${isGuest && !viewingProfile ? 'disabled style="opacity:0.55;cursor:not-allowed;" title="Sign in to filter by owned"' : ''}>${isGuest && !viewingProfile ? 'Sign in for Owned' : (showOwnedOnly ? 'âœ“ Owned Only' : 'Show All')}</button>
                </div>
                <div class="grid grid-cols-2 gap-2">
                  <button id="controlClearSelectionBtn" onclick="clearSelection()" class="w-full min-h-[44px] px-3 py-2 bg-white/10 hover:bg-white/20 border border-cyan-400/60 rounded-lg font-semibold text-cyan-100 col-span-2" ${selectedSong ? '' : 'disabled style="opacity:0.55;cursor:not-allowed;"'}>Clear Selection</button>
                </div>
                <div id="mixableInlineNotice" class="inline-banner" style="display:${mixableInlineNotice ? 'block' : 'none'};">${mixableInlineNotice}</div>
                <div class="bg-black/40 border border-white/10 rounded-lg p-3 space-y-3">
                  <div class="flex items-center justify-between flex-wrap gap-2">
                    <div class="text-sm font-semibold text-white">Key Mode</div>
                    <span class="text-[11px] text-gray-400">Harmonic preference</span>
                  </div>
                  <div class="grid sm:grid-cols-2 gap-3">
                    <label class="flex flex-col gap-1 text-xs text-gray-300">
                      <span class="font-semibold text-white">Key Matching</span>
                      <select id="keyMatchModeSelect" class="px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-sm text-white">
                        <option value="camelot">Camelot (DJ Wheel)</option>
                        <option value="semitone">Key (Same Mode Â±0â€“6)</option>
                      </select>
                    </label>
                    <label class="flex flex-col gap-1 text-xs text-gray-300">
                      <span class="font-semibold text-white">Â± Range</span>
                      <input id="semitoneRangeInput" type="range" min="1" max="6" step="1" value="${maxSemitoneRange}" class="accent-cyan-400" />
                      <div id="semitoneRangeValue" class="text-[11px] text-cyan-200 font-semibold">Â±${maxSemitoneRange} semitones</div>
                    </label>
                  </div>
                  <div class="flex items-center justify-between gap-2 flex-wrap text-sm text-gray-200">
                    <div>
                      <div class="font-semibold text-white">Include Opposite Mode</div>
                      <div class="text-[11px] text-gray-400">Opposite mode ranks after all same-mode matches</div>
                    </div>
                    <label class="inline-flex items-center gap-2 text-xs">
                      <input id="includeOppositeModeToggle" type="checkbox" class="w-5 h-5 accent-cyan-400" ${includeOppositeMode ? 'checked' : ''} />
                      <span>Include</span>
                    </label>
                  </div>
                  <p class="text-[11px] text-gray-400">Semitone mode prioritizes the most natural-sounding blends; Camelot is better for DJ-style key transitions.</p>
                </div>
              </div>
              <div class="panel space-y-3 dim-when-sticky">
                <div class="flex items-center justify-between">
                  <div class="font-bold text-white">Mix Logic</div>
                  <span class="text-xs text-gray-300">Priority selector</span>
                </div>
                <div class="flex flex-wrap gap-2">
                  <button onclick="setSortMode('bpm')" class="px-3 py-2 rounded-lg text-sm font-semibold border ${sortMode==='bpm'?'border-cyan-400 bg-cyan-500/20 text-cyan-100':'border-white/10 bg-white/5 text-gray-200'}">Tempo (BPM)</button>
                  <button onclick="setSortMode('camelot')" class="px-3 py-2 rounded-lg text-sm font-semibold border ${sortMode==='camelot'?'border-pink-400 bg-pink-500/20 text-pink-100':'border-white/10 bg-white/5 text-gray-200'}">Camelot</button>
                  <button onclick="setSortMode('genre')" class="px-3 py-2 rounded-lg text-sm font-semibold border ${sortMode==='genre'?'border-emerald-400 bg-emerald-500/20 text-emerald-100':'border-white/10 bg-white/5 text-gray-200'}">Genre</button>
                </div>
                <div class="flex items-center gap-2">
                  <div class="text-xs text-gray-300 font-semibold">Priority Strength</div>
                  <div class="flex items-center gap-2 flex-1">
                    <span class="text-[11px] text-gray-500">Low</span>
                    <input type="range" min="0" max="2" step="1" value="${priorityStrength==='low'?0:priorityStrength==='high'?2:1}" class="flex-1 accent-cyan-400" oninput="setPriorityStrength(this.value)" aria-label="Priority Strength" />
                    <span class="text-[11px] text-gray-500">High</span>
                  </div>
                  <div class="text-[11px] px-2 py-1 rounded bg-white/10 border border-white/10 text-cyan-200 font-semibold">${priorityStrength==='low'?'Low':priorityStrength==='high'?'High':'Medium'}</div>
                </div>
              </div>

              ${selectedPanel}

              <div class="panel space-y-2 dim-when-sticky">
                <div class="flex items-center justify-between">
                  <div class="font-bold text-white">Sandbox (Drag tracks here)</div>
                  <div class="flex items-center gap-2 text-xs text-gray-300">
                    <span>Limit 4</span>
                    <button onclick="clearSandbox()" class="px-2 py-1 bg-white/10 hover:bg-white/20 rounded border border-white/10">Clear</button>
                  </div>
                </div>
                <div id="sandbox" class="sandbox-drop bg-black/40"></div>
                <div id="sandboxInfo" class="small-muted"></div>
              </div>
            </div>

            <div class="space-y-4">
              <div class="flex items-center justify-between flex-wrap gap-3">
                <div class="text-xl font-bold text-white">Song Browser</div>
                <div class="text-sm text-cyan-200 font-semibold">Selected: ${selectedSong ? selectedSong.title : 'None'}</div>
              </div>
              <div id="songList" class="space-y-4"></div>
            </div>
          </div>
        </div>

        <div id="setlistView" style="display:${view==='setlist'?'block':'none'}">
          <div id="setlistContent"></div>
        </div>
        <div id="profileView" style="display:${view==='profile'?'block':'none'}"></div>
        <div id="auditView" style="display:${view==='audit'?'block':'none'}"></div>
      </main>
      <div id="stickyCtaBar" class="sticky-cta-bar hidden" aria-live="polite">
        <button id="stickyCtaButton" class="sticky-cta-button" data-action="stickyCta" type="button"></button>
        <div id="stickyCtaCopy" class="sticky-cta-copy"></div>
      </div>
    </div>
  `;
  if(view==='browse'){ renderSongList(); sandboxInit(); renderSandbox(); } else if(view==='setlist'){ renderSetlist(); } else if(view==='audit'){ renderAuditView(); } else { renderProfile(); }
  syncCommunityStatsUI();
  bindTourEvents();
  updateTourUI();
  updateStickyCTA();
  maybeAutoOpenQuickStart();
}


    // ------------------ Genre context menu ------------------------
    function showGenreMenu(songId,event){
      if(!currentUser?.isAdmin) { alert('ðŸ”’ Admin only.'); return; }
      const existing = document.getElementById('genreContextMenu'); if(existing) existing.remove();
      const menu=document.createElement('div'); menu.id='genreContextMenu'; menu.className='context-menu';
      const anchor = getEventElement(event) || event.currentTarget;
      if(!anchor?.getBoundingClientRect) return;
      const rect = anchor.getBoundingClientRect();
      let left=rect.left, top=rect.bottom+5;
      if(left+220>window.innerWidth) left=rect.right-220;
      if(top+300>window.innerHeight) top=rect.top-305;
      menu.style.left = left+'px'; menu.style.top = top+'px';
      const genres = Object.keys(genreMap).concat(['Other']);
      menu.innerHTML = `<div style="padding:8px 12px;color:#00d9ff;font-weight:bold;border-bottom:1px solid rgba(0,217,255,0.3);margin-bottom:6px;">Select Genre:</div>`;
      genres.forEach(g=>{
        const btn=document.createElement('button'); btn.textContent=g; btn.style.display='block'; btn.style.width='100%'; btn.style.padding='8px 12px'; btn.style.background='transparent'; btn.style.border='none'; btn.style.textAlign='left'; btn.style.color='#e6f7ff'; btn.style.cursor='pointer';
        btn.addEventListener('click',async()=>{ await setGenreOverride(songId,g); menu.remove(); });
        menu.appendChild(btn);
      });
      document.body.appendChild(menu);
      setTimeout(()=>{
        const closeMenu = (e)=>{
          const target = getEventElement(e);
          if(!target || !menu.contains(target)){
            menu.remove();
            document.removeEventListener('click', closeMenu);
          }
        };
        document.addEventListener('click', closeMenu);
      },100);
    }

    function bindGenreEditors(scope=document){
      if(!isAdmin()) return;
      scope.querySelectorAll('[data-song-id-genre]').forEach(btn=>{
        const handler = (e)=>{ e.preventDefault(); e.stopPropagation(); const songId = btn.getAttribute('data-song-id-genre'); showGenreMenu(songId, e); };
        btn.onclick = handler;
        btn.oncontextmenu = handler;
      });
    }

    const setGenreOverride = async (songId,newGenre) => {
      if(!isAdmin()) return alert('Admin only');
      if(!currentUser && firebaseAuth?.currentUser){
        const tempProfile = normalizeProfileShape({
          username: firebaseAuth.currentUser.email?.split('@')[0] || firebaseAuth.currentUser.uid || 'admin',
          djName: firebaseAuth.currentUser.displayName || firebaseAuth.currentUser.email || 'Admin',
          ownedTracks,
          genreOverrides,
          isAdmin: false
        }, firebaseAuth.currentUser.uid || firebaseAuth.currentUser.email);
        const appliedProfile = applyAdminFlag(tempProfile);
        await persistAdminFlagIfNeeded(tempProfile, appliedProfile);
        currentUser = appliedProfile;
        refreshDraftProfileFromCurrentUser();
      }
      if(!currentUser) return alert('Sign in required for admin edits');
      genreOverrides[songId] = newGenre;
      const song = songs.find(s=>s.id===songId);
      if(song){
        song.genre = newGenre;
        refreshSongOverrides(song);
      }
      scheduleProfileCacheSync();
      refreshRegressionWarnings();
      renderAuditView();
      renderSongList();
      const genreTag = document.querySelector(`[data-genre-tag="${songId}"]`);
      if(genreTag){ genreTag.textContent = newGenre + ' âœ“'; genreTag.classList.add('animate-pulse'); setTimeout(()=>genreTag.classList.remove('animate-pulse'),1000); }
    };

    function toggleAuditFilter(key){ auditFilters[key] = !auditFilters[key]; renderAuditView(); }
    function closeOverrideModal(){ const m=document.getElementById('overrideModal'); if(m) m.remove(); }
    const openOverrideModal = (type, trackId)=>{
      if(!isAdmin()) return alert('Admin only');
      const track = songs.find(s=>s.id===trackId); if(!track) return;
      closeOverrideModal();
      const modal=document.createElement('div'); modal.id='overrideModal'; modal.className='fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50';
      const options = Array.from({length:12},(_,i)=>`${i+1}A`).concat(Array.from({length:12},(_,i)=>`${i+1}B`));
      const camelotSelect = `<select id="camelotSelect" class="w-full px-3 py-2 bg-black/60 border border-white/20 rounded">${options.map(o=>`<option value="${o}" ${track.camelot===o?'selected':''}>${o}</option>`).join('')}</select>`;
      const bpmInput = `<input id="bpmInput" type="number" value="${Math.round(track.bpm)}" class="w-full px-3 py-2 bg-black/60 border border-white/20 rounded"/>`;
      const actionCall = type==='camelot' ? `setCamelotOverride('${trackId}', document.getElementById('camelotSelect').value)` : `setBpmOverride('${trackId}', document.getElementById('bpmInput').value)`;
      modal.innerHTML = `<div class="panel max-w-md w-full">
        <div class="flex items-center justify-between mb-3"><div class="font-bold">Set ${type==='camelot'?'Camelot':'BPM'} for ${track.title}</div><button onclick="closeOverrideModal()">âœ•</button></div>
        <div class="space-y-3">
          ${type==='camelot'?camelotSelect:bpmInput}
          <div class="flex gap-2 justify-end">
            <button class="px-3 py-2 bg-white/10 rounded" onclick="closeOverrideModal()">Cancel</button>
            <button class="px-3 py-2 bg-blue-500/60 rounded" onclick="${actionCall}; closeOverrideModal();">Save</button>
          </div>
        </div>
      </div>`;
      document.body.appendChild(modal);
    };

    function syncAdminGlobals(){
      const adminActive = isAdmin();
      const adminFunctions = { toggleAdminTools, openOverrideModal, clearOverrides, setCamelotOverride, setBpmOverride, setGenreOverride, openAdminHelpEditor, openAdminWhatsNewEditor };
      Object.entries(adminFunctions).forEach(([name, fn])=>{
        if(adminActive){ window[name] = fn; }
        else {
          try { delete window[name]; } catch(_) { window[name] = undefined; }
        }
      });
    }

    // ------------------ Event listeners and interactions --------------
    let appDelegatesBound = false;
    function bindAppDelegates(){
      if(appDelegatesBound) return;
      const app = document.getElementById('app');
      if(!app) return;
      app.addEventListener('click', safeOn('click', (e)=>{
        if(closestFromEvent(e, '#mixableFilterBtn', { within: app })){ toggleMixableFilter(); return; }
        if(closestFromEvent(e, '#ownedFilterBtn', { within: app })){ toggleOwnedFilter(); return; }
        if(closestFromEvent(e, '#clearSearchBtn', { within: app }) || closestFromEvent(e, '#panelClearSearchBtn', { within: app })){ clearSearch(); return; }
        if(closestFromEvent(e, '[data-action="clearFilters"]', { within: app })){ clearFilters(); return; }
        if(closestFromEvent(e, '[data-action="signInPrompt"]', { within: app })){ showLoginScreen(); return; }
        if(closestFromEvent(e, '[data-action="openQuickStart"]', { within: app })){ openQuickStart(); return; }
        if(closestFromEvent(e, '[data-action="closeQuickStart"]', { within: app })){ closeQuickStart(); return; }
        if(closestFromEvent(e, '[data-action="quickStartSkip"]', { within: app })){ void completeQuickStart({ skipped: true }); return; }
        if(closestFromEvent(e, '[data-action="quickStartBack"]', { within: app })){ moveQuickStartStep(-1); return; }
        const presetBtn = closestFromEvent(e, '[data-action="quickStartPreset"]', { within: app });
        if(presetBtn){
          const preset = presetBtn.dataset.preset;
          void applyQuickStartPreset(preset).then((applied)=>{
            if(applied){
              quickStartState.preset = preset;
              moveQuickStartStep(1);
            }
          });
          return;
        }
        const pickBtn = closestFromEvent(e, '[data-action="quickStartPickTrack"]', { within: app });
        if(pickBtn){
          const songId = pickBtn.dataset.songId || pickBtn.getAttribute('data-song-id');
          if(songId){
            selectedSong = songsById[songId] || songs.find(s=>s.id===songId) || null;
            refreshSelectedSongCriteria();
            showMixableOnly = true;
            matchHintMessage = 'These are your best matches.';
            render();
            setupEventListeners();
            const list = document.getElementById('songList');
            if(list) list.scrollIntoView({ behavior: 'smooth', block: 'start' });
            setTimeout(()=>{ matchHintMessage = ''; scheduleSongListRender('match-hint-clear'); }, 2600);
            void completeQuickStart();
          }
          return;
        }
        if(closestFromEvent(e, '[data-action="mobileNextWindow"]', { within: app })){ shiftMobileWindow(1); return; }
        if(closestFromEvent(e, '[data-action="mobilePrevWindow"]', { within: app })){ shiftMobileWindow(-1); return; }
        const headerMoreBtn = closestFromEvent(e, '[data-action="toggleHeaderMore"]', { within: app });
        if(headerMoreBtn){ headerMoreOpen = !headerMoreOpen; render(); setupEventListeners(); return; }
        const stickyBtn = closestFromEvent(e, '[data-action="stickyCta"]', { within: app });
        if(stickyBtn){
          const action = stickyBtn.dataset.stickyAction || '';
          if(action === 'open-quickstart'){ openQuickStart(); return; }
          if(action === 'scroll-to-list'){
            const list = document.getElementById('songList');
            if(list){
              list.classList.add('song-list-highlight');
              list.scrollIntoView({ behavior: 'smooth', block: 'start' });
              setTimeout(()=>list.classList.remove('song-list-highlight'), 1500);
            }
            return;
          }
          if(action === 'mixable-warning'){
            setMixableInlineNotice('Select a song before enabling Mixable Only.');
            return;
          }
          if(action === 'sign-in'){
            showLoginScreen();
            return;
          }
        }
        const genreBtn = closestFromEvent(e, '[data-genre-tag]', { within: app });
        if(genreBtn && isAdmin()){
          showGenreMenu(genreBtn.dataset.genreTag || genreBtn.getAttribute('data-genre-tag'), e);
          return;
        }
        const songAction = closestFromEvent(e, '[data-song-action]', { within: app });
        if(songAction){
          const action = songAction.dataset.songAction;
          const songId = songAction.dataset.songId || songAction.getAttribute('data-song-id');
          if(action === 'select' && songId){ selectSong(songId); return; }
          if(action === 'clear-selection'){ clearSelection(e); return; }
          if(action === 'toggle-owned' && songId){ toggleOwned(songId); return; }
          if(action === 'toggle-setlist' && songId){ addToSetlist(songId); return; }
          if(action === 'add-sandbox' && songId){ addToSandbox(songId); return; }
          if(action === 'preview' && songId){ onPreviewClick(songId); return; }
        }
      }, { action: 'app-click' }));
      app.addEventListener('input', safeOn('input', (e)=>{
        const target = getEventElement(e);
        if(!target) return;
        if(target.id === 'searchInput'){
          searchTerm = target.value;
          const clearSearchBtn = document.getElementById('clearSearchBtn');
          if(clearSearchBtn) clearSearchBtn.style.display = searchTerm ? 'block' : 'none';
          const panelClear = document.getElementById('panelClearSearchBtn');
          if(panelClear){ panelClear.disabled = !searchTerm; panelClear.style.opacity = searchTerm ? '1' : '0.55'; panelClear.style.cursor = searchTerm ? 'pointer' : 'not-allowed'; }
          const searchStatus = document.getElementById('searchStatus');
          if(searchStatus){ searchStatus.textContent = 'Filteringâ€¦'; searchStatus.style.display = 'block'; }
          if(searchDebounceTimer) clearTimeout(searchDebounceTimer);
          searchDebouncePending = true;
          searchDebounceTimer = setTimeout(()=>{
            resetMainPagination();
            updateMobileWindowState({ reset: true });
            scheduleSongListRender('search');
            searchDebouncePending = false;
            if(searchStatus){ searchStatus.style.display = 'none'; }
          }, 170);
        }
        if(target.id === 'auditSearchInput'){ auditSearch = target.value; renderAuditView(); }
        if(target.id === 'bandmateInput' && !viewingProfile){
          if(target.value.trim()){
            const status = document.getElementById('profileStatus');
            if(status) status.textContent = '';
          }
        }
        if(target.id === 'semitoneRangeInput'){ setMaxSemitoneRange(target.value); }
      }, { action: 'app-input' }));
      app.addEventListener('change', safeOn('change', (e)=>{
        const target = getEventElement(e);
        if(!target) return;
        if(target.id === 'keyMatchModeSelect'){ setKeyMatchMode(target.value); }
        if(target.id === 'includeOppositeModeToggle'){ toggleIncludeOppositeMode(target.checked); }
      }, { action: 'app-change' }));
      app.addEventListener('focusin', safeOn('focusin', (e)=>{
        const target = getEventElement(e);
        if(target?.id === 'searchInput'){
          isSearchFocused = true;
          updateStickyCTA();
        }
      }, { action: 'app-focusin' }));
      app.addEventListener('focusout', safeOn('focusout', (e)=>{
        const target = getEventElement(e);
        if(target?.id === 'searchInput'){
          isSearchFocused = false;
          updateStickyCTA();
        }
      }, { action: 'app-focusout' }));
      app.addEventListener('keydown', safeOn('keydown', (e)=>{
        const target = getEventElement(e);
        if(!target) return;
        if(target.id === 'bandmateInput' && e.key === 'Enter'){ e.preventDefault(); addBandMember(); }
        if(e.key === 'Escape' && !stickyCtaDismissed){
          stickyCtaDismissed = true;
          localStorage.setItem('jamMixer.stickyCtaDismissed', 'true');
          updateStickyCTA();
        }
      }, { action: 'app-keydown' }));
      app.addEventListener('contextmenu', safeOn('contextmenu', (e)=>{
        const target = closestFromEvent(e, '[data-song-id-genre]', { within: app });
        if(target && isAdmin()){
          e.preventDefault();
          showGenreMenu(target.dataset.songIdGenre || target.getAttribute('data-song-id-genre'), e);
        }
      }, { action: 'app-contextmenu' }));
      appDelegatesBound = true;
    }

    function bindQuickStartDelegates(){
      if(quickStartDelegatesBound) return;
      const modal = document.getElementById('quickStartModal');
      if(!modal) return;
      document.addEventListener('click', safeOn('click', (e)=>{
        const target = getEventElement(e);
        if(!target) return;
        if(target === modal){ closeQuickStart(); return; }
        if(closestFromEvent(e, '[data-action="closeQuickStart"]', { within: modal })){ closeQuickStart(); return; }
        if(closestFromEvent(e, '[data-action="quickStartSkip"]', { within: modal })){ void completeQuickStart({ skipped: true }); return; }
        if(closestFromEvent(e, '[data-action="quickStartBack"]', { within: modal })){ moveQuickStartStep(-1); return; }
        const presetBtn = closestFromEvent(e, '[data-action="quickStartPreset"]', { within: modal });
        if(presetBtn){
          const preset = presetBtn.dataset.preset;
          void applyQuickStartPreset(preset).then((applied)=>{
            if(applied){
              quickStartState.preset = preset;
              moveQuickStartStep(1);
            }
          });
          return;
        }
        const pickBtn = closestFromEvent(e, '[data-action="quickStartPickTrack"]', { within: modal });
        if(pickBtn){
          const songId = pickBtn.dataset.songId || pickBtn.getAttribute('data-song-id');
          if(songId){
            selectedSong = songsById[songId] || songs.find(s=>s.id===songId) || null;
            refreshSelectedSongCriteria();
            showMixableOnly = true;
            matchHintMessage = 'These are your best matches.';
            render();
            setupEventListeners();
            const list = document.getElementById('songList');
            if(list) list.scrollIntoView({ behavior: 'smooth', block: 'start' });
            setTimeout(()=>{ matchHintMessage = ''; scheduleSongListRender('match-hint-clear'); }, 2600);
            void completeQuickStart();
          }
        }
      }, { action: 'quick-start-modal-click' }));
      quickStartDelegatesBound = true;
    }

    function setupEventListeners(){
      bindUiDebugging();
      bindAppDelegates();
      bindQuickStartDelegates();
      bindProfileHandlers();
      updateProfileErrorBanner();
      runDelegationSelfTest();
      const searchInput = document.getElementById('searchInput');
      if(searchInput){
        const clearSearchBtn = document.getElementById('clearSearchBtn');
        if(clearSearchBtn){ clearSearchBtn.style.display = searchTerm ? 'block' : 'none'; }
      }
      const keyModeSelect = document.getElementById('keyMatchModeSelect'); if(keyModeSelect){ keyModeSelect.value = keyMatchMode; }
      const semitoneRangeInput = document.getElementById('semitoneRangeInput'); if(semitoneRangeInput){ semitoneRangeInput.value = maxSemitoneRange; }
      const includeOppToggle = document.getElementById('includeOppositeModeToggle'); if(includeOppToggle){ includeOppToggle.checked = includeOppositeMode; }
      if(isAdmin()){
        const adminBtn = document.getElementById('adminToolsBtn');
        if(adminBtn){
          adminBtn.onclick = (e)=>{ e.stopPropagation(); console.debug('[admin] Admin Tools clicked'); window.toggleAdminTools(); };
          console.debug('[admin] Admin Tools button bound');
        } else {
          console.debug('[admin] Admin Tools button missing after render');
        }
        const adminMenu = document.getElementById('adminToolsMenu');
        if(adminMenu){
          adminMenu.style.pointerEvents = 'auto';
          const helpBtn = document.getElementById('adminMenuHelpEditor');
          if(helpBtn) helpBtn.onclick = (e)=>{ e.stopPropagation(); openAdminHelpEditor(); toggleAdminTools(false); };
          const whatsNewBtn = document.getElementById('adminMenuWhatsNewEditor');
          if(whatsNewBtn) whatsNewBtn.onclick = (e)=>{ e.stopPropagation(); openAdminWhatsNewEditor(); toggleAdminTools(false); };
          const auditBtn = document.getElementById('adminMenuAudit');
          if(auditBtn) auditBtn.onclick = (e)=>{ e.stopPropagation(); openAuditFromMenu(); };
        }
      }
      setupLiveNowCarousel();
      updateRatingStarsUI();
      updateRatingTagsUI();
    }

    function setupLiveNowCarousel(){
      const carousel = document.getElementById('liveNowCarousel');
      if(!carousel || carousel.dataset.bound) return;
      carousel.dataset.bound = 'true';
      let isDown = false;
      let startX = 0;
      let scrollLeft = 0;
      carousel.addEventListener('mousedown', (e)=>{
        isDown = true;
        carousel.classList.add('dragging');
        startX = e.pageX - carousel.offsetLeft;
        scrollLeft = carousel.scrollLeft;
      });
      carousel.addEventListener('mouseleave', ()=>{
        isDown = false;
        carousel.classList.remove('dragging');
      });
      carousel.addEventListener('mouseup', ()=>{
        isDown = false;
        carousel.classList.remove('dragging');
      });
      carousel.addEventListener('mousemove', (e)=>{
        if(!isDown) return;
        e.preventDefault();
        const x = e.pageX - carousel.offsetLeft;
        const walk = (x - startX) * 1.2;
        carousel.scrollLeft = scrollLeft - walk;
      });
      carousel.addEventListener('wheel', (e)=>{
        if(Math.abs(e.deltaY) > Math.abs(e.deltaX)){
          carousel.scrollLeft += e.deltaY;
          e.preventDefault();
        }
      }, { passive: false });
    }

    let dataActionDelegatesBound = false;
    function isActionDisabled(el){
      if(!el) return true;
      return el.hasAttribute('disabled') || el.getAttribute('aria-disabled') === 'true';
    }

    function shouldHandleKeyActivation(el){
      if(!el) return false;
      const tag = el.tagName ? el.tagName.toLowerCase() : '';
      const role = el.getAttribute ? el.getAttribute('role') : '';
      return tag === 'button' || role === 'button';
    }

    function handleProfileAction(action, el, event){
      if(!action) return;
      if(isActionDisabled(el)) return;
      const dataset = el.dataset || {};
      debugProfileLog('profile action', { action, dataset });
      if(action === 'profile.exitViewMode'){
        exitProfileViewMode();
        return;
      }
      if(action === 'profile.openHelpModal'){
        openHelpModal({ source: dataset.source || 'profile', target: dataset.target || 'profile' });
        return;
      }
      if(action === 'profile.viewOwned'){
        viewOwnedFromProfile();
        return;
      }
      if(action === 'profile.addBandmate'){
        addBandMember();
        return;
      }
      if(action === 'profile.viewBandmate'){
        const username = dataset.username || '';
        if(username) viewBandMember(username);
        return;
      }
      if(action === 'profile.clearOwned'){
        clearAllOwned();
        return;
      }
      if(action === 'profile.resetFilters'){
        clearFilters();
        return;
      }
      if(action === 'profile.exportLibrary'){
        alert('Library exports are handled automatically via local cache/cloud sync.');
        return;
      }
      if(action === 'profile.importLibrary'){
        alert('Library imports are handled automatically when you sign in.');
        return;
      }
      if(action === 'profile.retrySync'){
        retryCloudSync();
        return;
      }
      if(action === 'profile.exportBackup'){
        exportOwnedBackupJson();
        return;
      }
    }

    function handleDataAction(el, event){
      if(!el) return;
      const action = el.dataset?.action;
      if(!action) return;
      if(action.startsWith('profile.')){
        event?.preventDefault();
        handleProfileAction(action, el, event);
        return;
      }
      if(action === 'addSet'){
        const id = el.dataset?.id;
        if(!id) return;
        event?.preventDefault();
        addToSetlist(id);
        return;
      }
      if(action === 'removeSet'){
        const id = el.dataset?.id;
        if(!id) return;
        event?.preventDefault();
        removeFromSetlist(id);
        return;
      }
      if(action === 'switchView'){
        const viewName = el.dataset?.view;
        if(!viewName) return;
        event?.preventDefault();
        switchView(viewName);
      }
    }

    document.addEventListener('click', safeOn('click', (e) => {
      const el = closestFromEvent(e, '[data-action]');
      if (!el) return;
      if(isActionDisabled(el)) return;
      handleDataAction(el, e);
    }, { action: 'data-action-click' }));

    document.addEventListener('keydown', safeOn('keydown', (e) => {
      if(e.key !== 'Enter' && e.key !== ' ') return;
      const el = closestFromEvent(e, '[data-action]');
      if (!el) return;
      if(!shouldHandleKeyActivation(el) || isActionDisabled(el)) return;
      e.preventDefault();
      handleDataAction(el, e);
    }, { action: 'data-action-keydown' }));
    dataActionDelegatesBound = true;

    window.setPriorityStrength = (val) => {
      const map = { '0':'low', '1':'medium', '2':'high', low:'low', medium:'medium', high:'high' };
      priorityStrength = map[val] || 'medium';
      persistKeyMatchSettings();
      render();
      setupEventListeners();
    };

    function persistKeyMatchSettings(){
      localStorage.setItem('jamMixer.keyMatchMode', keyMatchMode);
      localStorage.setItem('jamMixer.maxSemitoneRange', String(maxSemitoneRange));
      localStorage.setItem('jamMixer.includeOppositeMode', includeOppositeMode ? 'true' : 'false');
      localStorage.setItem('jamMixer.priorityStrength', priorityStrength);
      syncPreferencesIntoProfile();
      if(!profileUiState.isSaving) schedulePreferencePersist();
    }
    window.setKeyMatchMode = (mode) => {
      keyMatchMode = mode === 'semitone' ? 'semitone' : 'camelot';
      persistKeyMatchSettings();
      resetMainPagination();
      refreshSelectedSongCriteria();
      render();
      setupEventListeners();
    };
    window.setMaxSemitoneRange = (val) => {
      const num = Math.min(6, Math.max(1, Number(val) || 6));
      maxSemitoneRange = num;
      persistKeyMatchSettings();
      const rangeDisplay = document.getElementById('semitoneRangeValue');
      if(rangeDisplay){ rangeDisplay.textContent = `Â±${num} semitones`; }
      refreshSelectedSongCriteria();
      scheduleSongListRender('semitone-range');
    };
    window.toggleIncludeOppositeMode = (checked) => {
      includeOppositeMode = !!checked;
      persistKeyMatchSettings();
      refreshSelectedSongCriteria();
      scheduleSongListRender('include-opposite');
    };

    window.setSortMode = (mode) => {
      sortMode = mode;
      resetMainPagination();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    };

    window.selectSong = (id) => {
      selectedSong = songs.find(s=>s.id===id);
      resetMainPagination();
      refreshSelectedSongCriteria();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    };

    window.clearSelection = (event) => {
      if(event){ event.preventDefault(); event.stopPropagation(); }
      selectedSong = null;
      showMixableOnly = false;
      refreshSelectedSongCriteria();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    };

    window.disableMixable = () => {
      if(!showMixableOnly) return;
      showMixableOnly = false;
      render();
      setupEventListeners();
    };

    window.clearSearch = () => {
      searchTerm = '';
      if(searchDebounceTimer){ clearTimeout(searchDebounceTimer); searchDebounceTimer = null; }
      searchDebouncePending = false;
      const searchInput = document.getElementById('searchInput');
      const clearSearchBtn = document.getElementById('clearSearchBtn');
      if(searchInput) searchInput.value = '';
      if(clearSearchBtn) clearSearchBtn.style.display = 'none';
      const searchStatus = document.getElementById('searchStatus');
      if(searchStatus) searchStatus.style.display = 'none';
      const panelClearBtn = document.getElementById('panelClearSearchBtn');
      if(panelClearBtn){ panelClearBtn.disabled = true; panelClearBtn.style.opacity = '0.55'; panelClearBtn.style.cursor = 'not-allowed'; }
      resetMainPagination();
      updateMobileWindowState({ reset: true });
      scheduleSongListRender('clear-search');
    };

    window.clearFilters = () => {
      searchTerm = '';
      showOwnedOnly = false;
      showMixableOnly = false;
      selectedGenre = 'All';
      resetMainPagination();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    };

    window.openProfileView = () => {
      view = 'profile';
      render();
      setupEventListeners();
      renderProfile();
    };

    function viewOwnedFromProfile(){
      if(isGuestUser() && !viewingProfile){
        setMixableInlineNotice('Sign in to filter by owned tracks.');
        return;
      }
      showOwnedOnly = true;
      searchTerm = '';
      const searchInput = document.getElementById('searchInput');
      const clearSearchBtn = document.getElementById('clearSearchBtn');
      const searchStatus = document.getElementById('searchStatus');
      if(searchInput) searchInput.value = '';
      if(clearSearchBtn) clearSearchBtn.style.display = 'none';
      if(searchStatus) searchStatus.style.display = 'none';
      view = 'browse';
      resetMainPagination();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    }

    window.toggleOwned = async (id) => {
      if(viewingProfile){ alert("You can't edit other people's collections!"); return; }
      if(isGuestUser()){
        setMixableInlineNotice('Sign in to mark owned tracks.');
        return;
      }
      if(firebaseEnabled && firebaseAuth?.currentUser){
        updateSyncState({ state: SYNC_STATES.savingRemote, message: 'Savingâ€¦', errorCode: null, errorStep: null });
        queueSaveProfile({ reason: 'owned_toggle' }).catch(()=>{});
      }
      const store = ensureOwnedLibraryStore();
      if(store){
        store.toggleOwned(id);
      } else {
        const nextOwned = ownedTracks.includes(id) ? ownedTracks.filter(t=>t!==id) : [...ownedTracks, id];
        ownedTracks = normalizeOwnedList(nextOwned);
        persistUserSession(currentProfileFromState(), { reason: 'toggleOwned', skipBackend: true }).catch(()=>{});
      }
      updateOwnedCount();
      updateSongCardOwnedState(id);
      updateStickyCTA();
      if(showOwnedOnly){
        updateMobileWindowState({ reset: true });
        scheduleSongListRender('owned-filter-change');
      }
    };

    window.exitProfileViewMode = () => {
      clearViewedProfile();
      refreshDraftProfileFromCurrentUser();
      render();
      setupEventListeners();
    };

    function updateSetlistCountUI(){
      const el = document.getElementById('setlistCount');
      if(el) el.textContent = setlist.length;
    }

    window.addToSetlist = (id) => {
      if(!id) return;
      if(isGuestUser() && !viewingProfile){
        setMixableInlineNotice('Sign in to save setlists.');
        return;
      }
      const exists = setlist.includes(id);
      if(exists){
        setlist = setlist.filter(x => x !== id);
      } else {
        setlist.push(id);
      }
      scheduleProfileCacheSync();
      updateSetlistCountUI();
      updateSongCardSetlistState(id);
      if(view === 'setlist') renderSetlist();
    };

    window.removeFromSetlist = (id) => {
      setlist = setlist.filter(x => x !== id);
      scheduleProfileCacheSync();
      updateSetlistCountUI();
      updateSongCardSetlistState(id);
      renderSetlist();
    };

    window.switchView = (newView) => {
      if(newView === 'audit' && !isAdmin()){
        alert('Admin only');
        newView = 'browse';
      }
      adminMenuOpen = false;
      logEvent('view_switch', { from: view, to: newView });
      view = newView;
      if(view === 'browse'){ updateMobileWindowState({ reset: true }); }
      const browserView = document.getElementById('browserView');
      const setlistView = document.getElementById('setlistView');
      const profileView = document.getElementById('profileView');
      const auditViewEl = document.getElementById('auditView');
      if(browserView) browserView.style.display = view==='browse' ? 'block' : 'none';
      if(setlistView) setlistView.style.display = view==='setlist' ? 'block' : 'none';
      if(profileView) profileView.style.display = view==='profile' ? 'block' : 'none';
      if(auditViewEl) auditViewEl.style.display = view==='audit' ? 'block' : 'none';
      const browserBtn = document.getElementById('browserBtn'); const setlistBtn = document.getElementById('setlistBtn'); const profileBtn = document.getElementById('profileBtn'); const auditBtn = document.getElementById('auditBtn');
      if(browserBtn) browserBtn.className = `px-4 py-2 rounded-lg font-medium transition ${view==='browse'?'bg-gradient-to-r from-purple-500 to-pink-500':'bg-white/10 hover:bg-white/20'}`;
      if(setlistBtn) setlistBtn.className = `px-4 py-2 rounded-lg font-medium transition ${view==='setlist'?'bg-gradient-to-r from-purple-500 to-pink-500':'bg-white/10 hover:bg-white/20'}`;
      if(profileBtn) profileBtn.className = `px-4 py-2 rounded-lg font-medium transition ${view==='profile'?'bg-gradient-to-r from-indigo-500 to-blue-500':'bg-white/10 hover:bg-white/20'}`;
      if(auditBtn) auditBtn.className = `px-4 py-2 rounded-lg font-medium transition ${view==='audit'?'bg-gradient-to-r from-amber-500 to-yellow-500':'bg-white/10 hover:bg-white/20'}`;
      if(view==='browse'){ renderSongList(); setupEventListeners(); sandboxInit(); renderSandbox(); }
      else if(view==='setlist'){ renderSetlist(); setupEventListeners(); }
      else if(view==='audit'){ renderAuditView(); setupEventListeners(); }
      else { renderProfile(); setupEventListeners(); }
      updateTourUI();
    };

    window.toggleMixableFilter = () => {
      if(!selectedSong){
        setMixableInlineNotice('Select a song first to see mixable matches.');
        return;
      }
      showMixableOnly = !showMixableOnly;
      resetMainPagination();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    };

    window.toggleOwnedFilter = () => {
      if(isGuestUser() && !viewingProfile){
        setMixableInlineNotice('Sign in to filter by owned tracks.');
        return;
      }
      showOwnedOnly = !showOwnedOnly;
      resetMainPagination();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    };

    window.clearAllOwned = async () => {
      if(viewingProfile) return;
      if(isGuestUser()){
        clearSelection();
        clearFilters();
        return;
      }
      const count = ownedTracks.length;
      const label = count === 1 ? 'track' : 'tracks';
      const stepOne = confirm(`âš ï¸ You are about to clear ${count} owned ${label}.\n\nThis wipes your Owned selection for this account.`);
      if(!stepOne) return;
      const typed = prompt('Type CLEAR or CLEAR OWNED to confirm:', '');
      const normalized = (typed || '').trim().toUpperCase();
      if(normalized !== 'CLEAR' && normalized !== 'CLEAR OWNED'){
        alert('Confirmation did not match. No changes were made.');
        return;
      }
      const store = ensureOwnedLibraryStore();
      userInitiatedClear = true;
      try{
        if(store){
          store.clearAllOwned();
          await store.flush('explicit_clear', { allowEmpty: true });
        } else {
          ownedTracks = [];
        }
        await saveUserProfile({ reason: 'clearAll', force: true });
      } finally {
        userInitiatedClear = false;
      }
      updateOwnedCount();
      updateMobileWindowState({ reset: true });
      scheduleSongListRender('clear-all-owned');
      updateStickyCTA();
      alert(`ðŸ—‘ï¸ Cleared ${count} owned songs.`);
    };

    async function addBandMember(){
      if(viewingProfile) return;
      const status = document.getElementById('profileStatus');
      const input = document.getElementById('bandmateInput');
      const raw = (input?.value || '').trim();
      const normalized = raw.replace(/^@/, '');
      if(!normalized){
        if(status) status.textContent = 'Enter a bandmate username.';
        return;
      }
      const lower = normalizeUsernameLower(normalized);
      const currentName = normalizeUsernameLower(currentUser?.username || '');
      if(currentName && lower === currentName){
        if(status) status.textContent = 'You are already in your own band.';
        return;
      }
      const existing = (bandMembers || []).some(member => normalizeUsernameLower(member?.username || '') === lower);
      if(existing){
        if(status) status.textContent = 'Bandmate already added.';
        return;
      }
      let profile = null;
      try{
        profile = await loadUserProfile(normalized);
      }catch(err){
        profile = null;
      }
      const entry = profile
        ? { username: profile.username || normalized, djName: profile.djName || profile.username || normalized, uid: profile.uid || '' }
        : { username: normalized, djName: normalized, uid: '' };
      bandMembers = [...(bandMembers || []), entry];
      if(currentUser) currentUser.bandMembers = bandMembers;
      if(draftProfile) draftProfile.bandMembers = bandMembers;
      scheduleProfileCacheSync();
      if(input) input.value = '';
      if(status) status.textContent = 'Bandmate added.';
      renderProfile();
      setupEventListeners();
    }

    async function viewBandMember(username){
      if(!username) return;
      const status = document.getElementById('profileStatus');
      try{
        const profile = await loadProfileForViewing(username);
        if(profile){
          openFriendProfile(profile);
          return;
        }
      }catch(err){
        console.warn('[bandmates] view failed', err);
      }
      if(status) status.textContent = 'Bandmate profile not available.';
    }

    // --------------------- Preview & two-track (simple) ---------------
    function onPreviewClick(id){
      const b = songs.find(s => s.id === id); if(!selectedSong){ selectedSong = b; render(); setupEventListeners(); alert('Main track selected. Click Preview on another track to compare.'); return; }
      previewSong = b; displayTwoTrackPreview(selectedSong, previewSong);
    }
    function displayTwoTrackPreview(A,B){
      const comp = mashupCompatibility(A,B); const pct = Math.round(comp.total);
      alert(`${A.title} â†’ ${B.title}\nCompatibility: ${pct}%\nBPM diff: ${Math.abs(A.bpm-B.bpm)}\n${bpmShiftSuggestion(A.bpm,B.bpm)}`);
    }

    // -------------------- Sandbox functions --------------------------
    function sandboxInit(){ const el=document.getElementById('sandbox'); if(!el) return; if(!el.dataset.bound){ el.dataset.bound='1'; el.addEventListener('dragover', (e)=>e.preventDefault()); el.addEventListener('drop', (e)=>{ e.preventDefault(); const id=e.dataTransfer.getData('text/plain'); const track = songs.find(s=>s.id===id); if(!track) return; if(sandboxTracks.find(t=>t.id===id)) return; if(sandboxTracks.length>=4){ alert('Sandbox limit: 4 tracks'); return; } sandboxTracks.push(track); renderSandbox(); }); } if(!sandboxTracks.length && sandboxIds.length){ sandboxTracks = sandboxIds.map(id=> songs.find(s=>s.id===id)).filter(Boolean).slice(0,4); } renderSandbox(); }
    function persistSandbox(){ sandboxIds = sandboxTracks.map(t=>t.id); localStorage.setItem(getNamespacedKey('sandboxTrackIds'), JSON.stringify(sandboxIds)); }
    function addToSandbox(id){ const track=songs.find(s=>s.id===id); if(!track) return; if(sandboxTracks.find(t=>t.id===id)){ alert('Track already in sandbox'); return; } if(sandboxTracks.length>=4){ alert('Sandbox limit: 4 tracks'); return; } sandboxTracks.push(track); renderSandbox(); renderSongList(); }
    function renderSandbox(){ const el=document.getElementById('sandbox'); if(!el) return; el.innerHTML = sandboxTracks.map((t,i)=>`<div class="flex items-center gap-3 panel p-2 mb-2"><div class="w-10 h-10 rounded" style="background:${camelotColors[t.camelot]||'#666'};display:flex;align-items:center;justify-content:center">${t.camelot}</div><div style="flex:1"><div class="font-semibold">${t.title}</div><div class="small-muted text-xs">${t.artist} â€¢ ${t.genre} â€¢ ${t.bpm} BPM â€¢ ${t.key}</div></div><button class="ml-2 px-2 py-1 bg-red-600/40" onclick="removeSandbox('${t.id}')">âœ•</button></div>`).join('') || `<div class="small-muted p-2">Drop tracks here</div>`; persistSandbox(); const info=document.getElementById('sandboxInfo'); if(sandboxTracks.length===0){ if(info) info.textContent=''; return; } const bpms=sandboxTracks.map(s=>s.bpm); const keys=sandboxTracks.map(s=>s.camelot); const bpmRange=`${Math.min(...bpms)}â€“${Math.max(...bpms)}`; const bpmDiffs=bpms.length>1?Math.max(...bpms)-Math.min(...bpms):0; const genreBlend=getGenreBlendScore(sandboxTracks); if(info) info.innerHTML=`BPM range: ${bpmRange} (Î” ${bpmDiffs}) â€¢ Key set: ${[...new Set(keys)].join(', ')} â€¢ Genre-blend: ${Math.round(genreBlend*100)}%`; }
    function removeSandbox(id){ sandboxTracks=sandboxTracks.filter(s=>s.id!==id); renderSandbox(); }
    function clearSandbox(){ sandboxTracks=[]; sandboxIds=[]; renderSandbox(); }
    function getGenreBlendScore(list){ if(!list.length) return 0; const counts={}; list.forEach(s=>counts[s.genre]=(counts[s.genre]||0)+1); const max=Math.max(...Object.values(counts)); return max/list.length; }

    // NOTE:
    // Import / Export was intentionally removed.
    // Profiles persist automatically via Firebase or localStorage.
    // Do not reintroduce manual JSON import/export without a migration plan.

    // -------------------- Help/What's New config ---------------------
    const HELP_SECTION_FEATURES = {
      setlist: 'hasSetlist',
      owned: 'hasOwnedToggle',
      owned_filter: 'hasOwnedToggle'
    };
    const HELP_SECTION_IDS = {
      mixer_basics: 'help-mixer',
      owned: 'ownedHelp',
      owned_filter: 'ownedFilterHelp',
      search: 'help-search',
      setlist: 'help-setlist',
      camelot_bpm: 'help-camelot-bpm',
      mixable: 'help-mixable',
      bandmates: 'help-bandmates'
    };
    const HELP_FAQ_FEATURES = {
      owned_count_wrong: 'hasOwnedToggle'
    };

    function getWhatsNewItems(){
      if(Array.isArray(whatsNewState?.items)) return whatsNewState.items;
      if(Array.isArray(whatsNewState)) return whatsNewState;
      if(Array.isArray(window.DEFAULT_WHATS_NEW?.items)) return window.DEFAULT_WHATS_NEW.items;
      return [];
    }

    function buildListElement(items, listTag = 'ol'){
      const list = document.createElement(listTag);
      items.forEach((line) => {
        const li = document.createElement('li');
        li.textContent = line;
        list.appendChild(li);
      });
      return list;
    }

    function buildHelpSectionElement(section, { listTag = 'ol', includeFeatures = true, includeIds = true } = {}){
      const wrapper = document.createElement('div');
      wrapper.className = 'helpSection';
      if(includeIds && section?.id){
        const sectionId = HELP_SECTION_IDS[section.id] || `help-${section.id}`;
        wrapper.id = sectionId;
      }
      const featureKey = HELP_SECTION_FEATURES[section?.id];
      if(includeFeatures && featureKey){
        wrapper.dataset.helpFeature = featureKey;
      }
      const title = document.createElement('h3');
      title.textContent = section?.title || '';
      wrapper.appendChild(title);

      const content = document.createElement('div');
      if(includeFeatures && featureKey){
        content.dataset.helpContent = '';
      }
      const bullets = Array.isArray(section?.bullets)
        ? section.bullets
        : Array.isArray(section?.body)
          ? section.body
          : [];
      if(bullets.length){
        content.appendChild(buildListElement(bullets, listTag));
      }
      const steps = Array.isArray(section?.steps) ? section.steps : [];
      if(steps.length){
        const stepsLabel = document.createElement('p');
        stepsLabel.className = 'small-muted';
        stepsLabel.textContent = 'Steps';
        content.appendChild(stepsLabel);
        content.appendChild(buildListElement(steps, 'ol'));
      }
      wrapper.appendChild(content);

      if(includeFeatures && featureKey){
        const coming = document.createElement('p');
        coming.className = 'helpComing';
        coming.dataset.helpComing = '';
        coming.textContent = 'Coming soon.';
        wrapper.appendChild(coming);
      }
      return wrapper;
    }

    function renderHelpContentInto({ helpData, quickStartEl, basicSectionsEl, faqListEl, advancedSectionsEl, includeFeatures = true, includeIds = true } = {}){
      if(!helpData) return;
      const quickStart = Array.isArray(helpData?.basic?.quickStart) ? helpData.basic.quickStart : [];
      if(quickStartEl){
        quickStartEl.innerHTML = '';
        const isListEl = ['OL','UL'].includes(quickStartEl.tagName);
        if(isListEl){
          quickStart.forEach((line) => {
            const li = document.createElement('li');
            li.textContent = line;
            quickStartEl.appendChild(li);
          });
        } else {
          quickStartEl.appendChild(buildListElement(quickStart, 'ol'));
        }
      }
      if(basicSectionsEl){
        basicSectionsEl.innerHTML = '';
        const sections = Array.isArray(helpData?.basic?.sections) ? helpData.basic.sections : [];
        sections.forEach(section => {
          basicSectionsEl.appendChild(buildHelpSectionElement(section, { listTag: 'ol', includeFeatures, includeIds }));
        });
      }
      if(faqListEl){
        faqListEl.innerHTML = '';
        const faqs = Array.isArray(helpData?.basic?.faq) ? helpData.basic.faq : [];
        faqs.forEach((faq) => {
          const detail = document.createElement('details');
          detail.className = 'helpFaq';
          detail.dataset.questionId = faq.id || '';
          const featureKey = HELP_FAQ_FEATURES[faq.id];
          if(includeFeatures && featureKey){
            detail.dataset.helpFeature = featureKey;
            detail.dataset.helpFeatureMode = 'item';
          }
          const summary = document.createElement('summary');
          summary.textContent = faq.q || '';
          detail.appendChild(summary);
          const answers = Array.isArray(faq.a) ? faq.a : [];
          answers.forEach((line) => {
            const p = document.createElement('p');
            p.textContent = line;
            detail.appendChild(p);
          });
          faqListEl.appendChild(detail);
        });
      }
      if(advancedSectionsEl){
        advancedSectionsEl.innerHTML = '';
        const sections = Array.isArray(helpData?.advanced?.sections) ? helpData.advanced.sections : [];
        sections.forEach(section => {
          advancedSectionsEl.appendChild(buildHelpSectionElement(section, { listTag: 'ul', includeFeatures: false, includeIds }));
        });
      }
    }

    function renderHelpContent(){
      const helpData = helpContentState || window.DEFAULT_HELP_CONTENT;
      renderHelpContentInto({
        helpData,
        quickStartEl: document.getElementById('helpQuickStartList'),
        basicSectionsEl: document.getElementById('helpBasicSections'),
        faqListEl: document.getElementById('helpFaqList'),
        advancedSectionsEl: document.getElementById('helpAdvancedSections'),
        includeFeatures: true
      });
      bindHelpFaqTracking();
      applyHelpFlags(getHelpFlags());
    }

    function renderHelpPreview(targetEl, helpData){
      if(!targetEl) return;
      targetEl.innerHTML = '';
      const basicWrapper = document.createElement('div');
      const basicTitle = document.createElement('h4');
      basicTitle.textContent = 'Basic';
      basicWrapper.appendChild(basicTitle);
      const quickTitle = document.createElement('div');
      quickTitle.className = 'text-xs text-cyan-200 font-semibold';
      quickTitle.textContent = 'Quick Start';
      basicWrapper.appendChild(quickTitle);
      const quickList = document.createElement('div');
      basicWrapper.appendChild(quickList);
      const sectionsContainer = document.createElement('div');
      const faqContainer = document.createElement('div');
      renderHelpContentInto({
        helpData,
        quickStartEl: quickList,
        basicSectionsEl: sectionsContainer,
        faqListEl: faqContainer,
        advancedSectionsEl: null,
        includeFeatures: false,
        includeIds: false
      });
      basicWrapper.appendChild(sectionsContainer);
      if(faqContainer.children.length){
        const faqTitle = document.createElement('div');
        faqTitle.className = 'text-xs text-cyan-200 font-semibold mt-2';
        faqTitle.textContent = 'FAQ';
        basicWrapper.appendChild(faqTitle);
        basicWrapper.appendChild(faqContainer);
      }
      targetEl.appendChild(basicWrapper);

      const advancedWrapper = document.createElement('div');
      advancedWrapper.className = 'mt-3';
      const advancedTitle = document.createElement('h4');
      advancedTitle.textContent = 'Advanced';
      advancedWrapper.appendChild(advancedTitle);
      const advancedContainer = document.createElement('div');
      renderHelpContentInto({
        helpData,
        quickStartEl: null,
        basicSectionsEl: null,
        faqListEl: null,
        advancedSectionsEl: advancedContainer,
        includeFeatures: false,
        includeIds: false
      });
      advancedWrapper.appendChild(advancedContainer);
      targetEl.appendChild(advancedWrapper);
    }

    function cloneConfig(data){
      return data ? JSON.parse(JSON.stringify(data)) : null;
    }

    function splitLines(value){
      return (value || '')
        .split('\\n')
        .map(line => line.trim())
        .filter(Boolean);
    }

    function escapeHtml(value){
      return String(value ?? '')
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/\"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }

    function parseCommaList(value){
      return (value || '')
        .split(',')
        .map(item => item.trim())
        .filter(Boolean);
    }

    function moveItem(list, fromIndex, toIndex){
      if(!Array.isArray(list)) return;
      if(fromIndex < 0 || fromIndex >= list.length) return;
      if(toIndex < 0 || toIndex >= list.length) return;
      const [item] = list.splice(fromIndex, 1);
      list.splice(toIndex, 0, item);
    }

    async function loadRemoteConfig(){
      if(configLoadPromise) return configLoadPromise;
      if(!window.configService){
        renderHelpContent();
        return null;
      }
      configLoadPromise = Promise.all([
        window.configService.getHelpContent({ firestore, defaults: window.DEFAULT_HELP_CONTENT }),
        window.configService.getWhatsNew({ firestore, defaults: window.DEFAULT_WHATS_NEW })
      ]).then(([helpData, whatsNewData]) => {
        if(helpData) helpContentState = helpData;
        if(whatsNewData) whatsNewState = whatsNewData;
        renderHelpContent();
      }).catch((err) => {
        console.warn('[config] load failed', err);
        renderHelpContent();
      });
      return configLoadPromise;
    }

    // --------------------- Help modal functions -----------------------
    let helpEditorState = null;
    let whatsNewEditorState = null;
    function normalizeHelpTarget(value){
      return value === 'setlist' || value === 'live' ? value : 'none';
    }
    function normalizeHelpSource(value){
      return value === 'menu' || value === 'setlist_icon' || value === 'live_icon' ? value : 'other';
    }
    function buildHelpOpenedPayload(source, target){
      const payload = { source, target };
      const appVersion = getAppVersion();
      if(appVersion) payload.appVersion = appVersion;
      return payload;
    }
    const MAX_WHATS_NEW_ITEMS = 8;
    function resolveFeatureFlagValue(value, fallback){
      return typeof value === 'boolean' ? value : fallback;
    }
    function resolveFeatureFlags(){
      const baseFlags = window.FEATURE_FLAGS || {};
      return {
        setlist: resolveFeatureFlagValue(baseFlags.setlist, !!document.getElementById('setlistBtn')),
        liveProfile: resolveFeatureFlagValue(baseFlags.liveProfile, true),
        ownedToggle: resolveFeatureFlagValue(baseFlags.ownedToggle, !!document.getElementById('ownedFilterBtn')),
        statsTiles: resolveFeatureFlagValue(baseFlags.statsTiles, !!document.querySelector('[data-community-stat]'))
      };
    }
    function getHelpFlags(){
      const features = resolveFeatureFlags();
      return {
        hasSetlist: features.setlist,
        hasLiveProfile: features.liveProfile,
        hasOwnedToggle: features.ownedToggle,
        hasStatsTiles: features.statsTiles
      };
    }

    function applyHelpFlags(flags){
      document.querySelectorAll('[data-help-feature]').forEach((el) => {
        const key = el.dataset.helpFeature;
        const enabled = !!flags[key];
        if(el.dataset.helpFeatureMode === 'item'){
          el.style.display = enabled ? '' : 'none';
          return;
        }
        const content = el.querySelector('[data-help-content]');
        const coming = el.querySelector('[data-help-coming]');
        if(content) content.style.display = enabled ? '' : 'none';
        if(coming) coming.style.display = enabled ? 'none' : 'block';
      });
    }

    function renderWhatsNew(features){
      const list = document.getElementById('whatsNewList');
      if(!list) return;
      const items = getWhatsNewItems();
      const activeFeatures = features || resolveFeatureFlags();
      const filtered = items.filter((item) => {
        const requires = Array.isArray(item?.requires) ? item.requires : [];
        if(requires.length === 0) return true;
        return requires.every(flag => activeFeatures[flag]);
      }).slice(0, MAX_WHATS_NEW_ITEMS);
      list.innerHTML = filtered.map((item) => {
        const dateLabel = item?.date ? ` <span class="small-muted">(${item.date})</span>` : '';
        return `<li>âœ… ${item.text}${dateLabel}</li>`;
      }).join('');
      const empty = document.getElementById('whatsNewEmpty');
      if(empty) empty.style.display = filtered.length ? 'none' : 'block';
    }

    function syncHelpVersion(){
      const helpVersion = document.getElementById('helpVersion');
      if(!helpVersion) return;
      const lastUpdated = window.HELP_LAST_UPDATED;
      helpVersion.textContent = lastUpdated ? `Help updated: ${lastUpdated}` : '';
    }

    function syncHelpTabsA11y(){
      const tabs = document.querySelectorAll('.helpTabBtn');
      tabs.forEach(btn => {
        const isActive = btn.dataset.tab === helpTab;
        btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
        btn.tabIndex = isActive ? 0 : -1;
        btn.classList.toggle('active', isActive);
      });
    }

    function setHelpTab(tab){
      const helpContent = document.getElementById('helpContent');
      if(!helpContent) return;
      const panes = document.querySelectorAll('[data-help-pane]');
      helpScroll[helpTab] = helpContent.scrollTop;
      const previousTab = helpTab;
      helpTab = tab === 'advanced' ? 'advanced' : 'basic';
      panes.forEach(pane => {
        const isActive = pane.dataset.helpPane === helpTab;
        pane.style.display = isActive ? 'block' : 'none';
      });
      helpContent.scrollTop = helpScroll[helpTab] || 0;
      syncHelpTabsA11y();
      if(helpOpenedAt && (!helpTabTracked || previousTab !== helpTab)){
        track('help_tab_viewed', { tab: helpTab, target: helpOpenTarget });
        helpTabTracked = true;
      }
    }

    function bindHelpTabs(){
      const tabs = document.querySelectorAll('.helpTabBtn');
      tabs.forEach(btn => {
        const tab = btn.dataset.tab;
        btn.addEventListener('click', () => setHelpTab(tab));
        btn.addEventListener('keydown', (e) => {
          if(e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar'){
            e.preventDefault();
            setHelpTab(tab);
          }
        });
      });
      syncHelpTabsA11y();
    }

    function bindHelpFaqTracking(){
      document.querySelectorAll('.helpFaq').forEach((faq) => {
        if(faq.dataset.bound === 'true') return;
        faq.dataset.bound = 'true';
        faq.addEventListener('toggle', () => {
          const questionId = faq.dataset.questionId;
          if(!questionId) return;
          track('help_faq_toggled', {
            questionId,
            state: faq.open ? 'open' : 'closed'
          });
        });
      });
    }

    function openHelpModal(options = {}){
      const modal = document.getElementById('helpModal');
      if(!modal) return;
      const target = normalizeHelpTarget(options?.target);
      const source = normalizeHelpSource(options?.source);
      helpOpenTarget = target;
      helpOpenSource = source;
      helpOpenedAt = Date.now();
      helpTabTracked = false;
      track('help_opened', buildHelpOpenedPayload(source, target));
      const features = resolveFeatureFlags();
      renderWhatsNew(features);
      syncHelpVersion();
      applyHelpFlags(getHelpFlags());
      helpTab = 'basic';
      helpScroll = { basic: 0, advanced: 0 };
      setHelpTab('basic');
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden','false');
      const activeTab = document.querySelector('.helpTabBtn.active');
      if(activeTab){ activeTab.focus(); } else { modal.focus(); }
      const targetId = target === 'setlist' ? 'help-setlist' : target === 'live' ? 'help-live' : null;
      if(targetId){
        setTimeout(() => {
          const targetEl = document.getElementById(targetId);
          if(targetEl){
            targetEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 0);
      }
    }
    function openHelp(){
      openHelpModal({ source: 'menu', target: 'none' });
    }
    function closeHelp(){
      const modal = document.getElementById('helpModal');
      if(!modal) return;
      if(helpOpenedAt){
        const timeOpenMs = Math.max(0, Date.now() - helpOpenedAt);
        track('help_closed', { timeOpenMs, target: helpOpenTarget });
      }
      helpOpenedAt = null;
      helpOpenTarget = 'none';
      helpOpenSource = 'other';
      helpTabTracked = false;
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden','true');
    }

    function closeAdminEditorModal(id){
      const modal = document.getElementById(id);
      if(modal) modal.remove();
    }

    function getEditorUpdatedBy(){
      return firebaseAuth?.currentUser?.email || currentUser?.username || firebaseAuth?.currentUser?.uid || 'admin';
    }

    function renderAdminHelpEditor(){
      const modal = document.getElementById('adminHelpEditorModal');
      if(!modal || !helpEditorState) return;
      const form = modal.querySelector('[data-editor-form]');
      const preview = modal.querySelector('[data-editor-preview]');
      if(!form) return;
      const basic = helpEditorState.basic || { quickStart: [], sections: [], faq: [] };
      const advanced = helpEditorState.advanced || { sections: [] };
      const quickStartRows = (basic.quickStart || []).map((line, index) => `
        <div class="admin-editor-row">
          <input class="admin-editor-input" data-field="quickStart" data-index="${index}" value="${escapeHtml(line)}" />
          <div class="admin-editor-inline-actions">
            <button class="admin-editor-btn" data-action="move-up" data-target="quickStart" data-index="${index}">â†‘</button>
            <button class="admin-editor-btn" data-action="move-down" data-target="quickStart" data-index="${index}">â†“</button>
            <button class="admin-editor-btn" data-action="remove-item" data-target="quickStart" data-index="${index}">Remove</button>
          </div>
        </div>
      `).join('') || '<div class="text-xs text-gray-400">No quick start steps yet.</div>';

      const basicSectionRows = (basic.sections || []).map((section, index) => `
        <div class="mt-2 p-2 border border-white/10 rounded-lg space-y-2">
          <div class="text-xs text-cyan-200 font-semibold">Section ${index + 1}</div>
          <input class="admin-editor-input" data-field="basic-section-id" data-index="${index}" value="${escapeHtml(section.id || '')}" placeholder="id (mixer_basics, owned, setlist...)" />
          <input class="admin-editor-input" data-field="basic-section-title" data-index="${index}" value="${escapeHtml(section.title || '')}" placeholder="Title" />
          <textarea class="admin-editor-textarea" data-field="basic-section-bullets" data-index="${index}" placeholder="One line per bullet">${escapeHtml(((section.bullets || section.body) || []).join('\\n'))}</textarea>
          <textarea class="admin-editor-textarea" data-field="basic-section-steps" data-index="${index}" placeholder="Optional steps (one per line)">${escapeHtml((section.steps || []).join('\\n'))}</textarea>
          <div class="admin-editor-inline-actions">
            <button class="admin-editor-btn" data-action="move-up" data-target="basicSections" data-index="${index}">â†‘</button>
            <button class="admin-editor-btn" data-action="move-down" data-target="basicSections" data-index="${index}">â†“</button>
            <button class="admin-editor-btn" data-action="remove-item" data-target="basicSections" data-index="${index}">Remove</button>
          </div>
        </div>
      `).join('') || '<div class="text-xs text-gray-400">No basic sections yet.</div>';

      const faqRows = (basic.faq || []).map((faq, index) => `
        <div class="mt-2 p-2 border border-white/10 rounded-lg space-y-2">
          <div class="text-xs text-cyan-200 font-semibold">FAQ ${index + 1}</div>
          <input class="admin-editor-input" data-field="faq-id" data-index="${index}" value="${escapeHtml(faq.id || '')}" placeholder="id (owned_count_wrong...)" />
          <input class="admin-editor-input" data-field="faq-q" data-index="${index}" value="${escapeHtml(faq.q || '')}" placeholder="Question" />
          <textarea class="admin-editor-textarea" data-field="faq-a" data-index="${index}" placeholder="Answer lines">${escapeHtml((faq.a || []).join('\\n'))}</textarea>
          <div class="admin-editor-inline-actions">
            <button class="admin-editor-btn" data-action="move-up" data-target="faq" data-index="${index}">â†‘</button>
            <button class="admin-editor-btn" data-action="move-down" data-target="faq" data-index="${index}">â†“</button>
            <button class="admin-editor-btn" data-action="remove-item" data-target="faq" data-index="${index}">Remove</button>
          </div>
        </div>
      `).join('') || '<div class="text-xs text-gray-400">No FAQ entries yet.</div>';

      const advancedSectionRows = (advanced.sections || []).map((section, index) => `
        <div class="mt-2 p-2 border border-white/10 rounded-lg space-y-2">
          <div class="text-xs text-cyan-200 font-semibold">Advanced ${index + 1}</div>
          <input class="admin-editor-input" data-field="advanced-section-id" data-index="${index}" value="${escapeHtml(section.id || '')}" placeholder="id (sorting...)" />
          <input class="admin-editor-input" data-field="advanced-section-title" data-index="${index}" value="${escapeHtml(section.title || '')}" placeholder="Title" />
          <textarea class="admin-editor-textarea" data-field="advanced-section-bullets" data-index="${index}" placeholder="One line per bullet">${escapeHtml(((section.bullets || section.body) || []).join('\\n'))}</textarea>
          <textarea class="admin-editor-textarea" data-field="advanced-section-steps" data-index="${index}" placeholder="Optional steps (one per line)">${escapeHtml((section.steps || []).join('\\n'))}</textarea>
          <div class="admin-editor-inline-actions">
            <button class="admin-editor-btn" data-action="move-up" data-target="advancedSections" data-index="${index}">â†‘</button>
            <button class="admin-editor-btn" data-action="move-down" data-target="advancedSections" data-index="${index}">â†“</button>
            <button class="admin-editor-btn" data-action="remove-item" data-target="advancedSections" data-index="${index}">Remove</button>
          </div>
        </div>
      `).join('') || '<div class="text-xs text-gray-400">No advanced sections yet.</div>';

      form.innerHTML = `
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">Version</div>
          <input class="admin-editor-input" data-field="help-version" value="${escapeHtml(helpEditorState.version ?? 1)}" />
        </div>
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">Quick Start Steps</div>
          ${quickStartRows}
          <button class="admin-editor-btn mt-2" data-action="add-item" data-target="quickStart">+ Add Step</button>
        </div>
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">Basic Sections</div>
          ${basicSectionRows}
          <button class="admin-editor-btn mt-2" data-action="add-item" data-target="basicSections">+ Add Section</button>
        </div>
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">FAQ</div>
          ${faqRows}
          <button class="admin-editor-btn mt-2" data-action="add-item" data-target="faq">+ Add FAQ</button>
        </div>
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">Advanced Sections</div>
          ${advancedSectionRows}
          <button class="admin-editor-btn mt-2" data-action="add-item" data-target="advancedSections">+ Add Advanced Section</button>
        </div>
      `;

      if(preview){
        renderHelpPreview(preview, helpEditorState);
      }
    }

    async function saveHelpEditor(){
      if(!window.configService) return alert('Config service unavailable');
      const status = document.querySelector('#adminHelpEditorModal [data-editor-status]');
      if(status) status.textContent = 'Saving...';
      try{
        const payload = window.configService.validateHelpDoc(helpEditorState);
        if(!payload) throw new Error('Validation failed. Fill all required fields.');
        const saved = await window.configService.saveHelpContent({
          firestore,
          data: payload,
          updatedBy: getEditorUpdatedBy()
        });
        helpContentState = saved;
        helpEditorState = cloneConfig(saved);
        renderHelpContent();
        renderAdminHelpEditor();
        if(status) status.textContent = 'Saved âœ…';
      }catch(err){
        console.warn('[admin] help save failed', err);
        if(status) status.textContent = `Save failed: ${err.message || err}`;
        alert(`Help save failed: ${err.message || err}`);
      }
    }

    function openAdminHelpEditor(){
      if(!isAdmin()) return alert('Admin only');
      closeAdminEditorModal('adminHelpEditorModal');
      helpEditorState = cloneConfig(helpContentState || window.DEFAULT_HELP_CONTENT);
      if(!helpEditorState){
        helpEditorState = { version: 1, basic: { quickStart: [], sections: [], faq: [] }, advanced: { sections: [] } };
      }
      helpEditorState.basic = helpEditorState.basic || { quickStart: [], sections: [], faq: [] };
      helpEditorState.basic.quickStart = helpEditorState.basic.quickStart || [];
      helpEditorState.basic.sections = helpEditorState.basic.sections || [];
      helpEditorState.basic.faq = helpEditorState.basic.faq || [];
      helpEditorState.advanced = helpEditorState.advanced || { sections: [] };
      helpEditorState.advanced.sections = helpEditorState.advanced.sections || [];
      const modal = document.createElement('div');
      modal.id = 'adminHelpEditorModal';
      modal.className = 'admin-editor-modal';
      modal.innerHTML = `
        <div class="admin-editor-card">
          <div class="admin-editor-header">
            <div>
              <div class="text-lg font-bold text-white">Help Editor</div>
              <div class="text-xs text-cyan-200">Edit basic + advanced help content. One line per bullet or step.</div>
            </div>
            <button class="admin-editor-btn" data-action="close-editor">Close</button>
          </div>
          <div class="admin-editor-body">
            <div class="admin-editor-columns">
              <div data-editor-form></div>
              <div>
                <div class="text-sm font-semibold text-cyan-100 mb-2">Preview</div>
                <div class="admin-editor-preview" data-editor-preview></div>
              </div>
            </div>
            <div class="flex items-center justify-between gap-3 flex-wrap">
              <div class="text-xs text-cyan-200" data-editor-status></div>
              <div class="admin-editor-actions">
                <button class="admin-editor-btn" data-action="reset-help">Reset to defaults</button>
                <button class="admin-editor-btn" data-action="save-help">Save & Publish</button>
              </div>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      renderAdminHelpEditor();
      modal.addEventListener('click', safeOn('click', (e) => {
        const btn = closestFromEvent(e, '[data-action]', { within: modal });
        if(!btn) return;
        const action = btn.dataset?.action;
        if(!action) return;
        if(action === 'close-editor'){ closeAdminEditorModal('adminHelpEditorModal'); return; }
        if(action === 'save-help'){ saveHelpEditor(); return; }
        if(action === 'reset-help'){
          helpEditorState = cloneConfig(window.DEFAULT_HELP_CONTENT);
          renderAdminHelpEditor();
          return;
        }
        const target = btn.dataset?.target;
        const index = Number(btn.dataset?.index);
        if(!target) return;
        if(action === 'add-item'){
          if(target === 'quickStart') helpEditorState.basic.quickStart.push('New step');
          if(target === 'basicSections') helpEditorState.basic.sections.push({ id: 'new_section', title: 'New Section', bullets: ['New bullet'], steps: [] });
          if(target === 'faq') helpEditorState.basic.faq.push({ id: 'new_faq', q: 'New question?', a: ['New answer.'] });
          if(target === 'advancedSections') helpEditorState.advanced.sections.push({ id: 'new_advanced', title: 'New Advanced Section', bullets: ['New bullet'], steps: [] });
          renderAdminHelpEditor();
          return;
        }
        if(action === 'remove-item'){
          if(Number.isNaN(index)) return;
          if(target === 'quickStart') helpEditorState.basic.quickStart.splice(index, 1);
          if(target === 'basicSections') helpEditorState.basic.sections.splice(index, 1);
          if(target === 'faq') helpEditorState.basic.faq.splice(index, 1);
          if(target === 'advancedSections') helpEditorState.advanced.sections.splice(index, 1);
          renderAdminHelpEditor();
          return;
        }
        if(action === 'move-up' || action === 'move-down'){
          if(Number.isNaN(index)) return;
          const delta = action === 'move-up' ? -1 : 1;
          if(target === 'quickStart') moveItem(helpEditorState.basic.quickStart, index, index + delta);
          if(target === 'basicSections') moveItem(helpEditorState.basic.sections, index, index + delta);
          if(target === 'faq') moveItem(helpEditorState.basic.faq, index, index + delta);
          if(target === 'advancedSections') moveItem(helpEditorState.advanced.sections, index, index + delta);
          renderAdminHelpEditor();
        }
      }, { action: 'admin-help-click' }));
      modal.addEventListener('input', safeOn('input', (e) => {
        const target = getEventElement(e);
        const field = target?.dataset?.field;
        if(!field) return;
        const index = Number(target.dataset?.index);
        const value = target.value;
        if(field === 'help-version'){ helpEditorState.version = Number(value) || 1; }
        if(field === 'quickStart'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.quickStart[index] = value;
        }
        if(field === 'basic-section-id'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.sections[index].id = value;
        }
        if(field === 'basic-section-title'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.sections[index].title = value;
        }
        if(field === 'basic-section-bullets'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.sections[index].bullets = splitLines(value);
        }
        if(field === 'basic-section-steps'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.sections[index].steps = splitLines(value);
        }
        if(field === 'faq-id'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.faq[index].id = value;
        }
        if(field === 'faq-q'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.faq[index].q = value;
        }
        if(field === 'faq-a'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.faq[index].a = splitLines(value);
        }
        if(field === 'advanced-section-id'){
          if(Number.isNaN(index)) return;
          helpEditorState.advanced.sections[index].id = value;
        }
        if(field === 'advanced-section-title'){
          if(Number.isNaN(index)) return;
          helpEditorState.advanced.sections[index].title = value;
        }
        if(field === 'advanced-section-bullets'){
          if(Number.isNaN(index)) return;
          helpEditorState.advanced.sections[index].bullets = splitLines(value);
        }
        if(field === 'advanced-section-steps'){
          if(Number.isNaN(index)) return;
          helpEditorState.advanced.sections[index].steps = splitLines(value);
        }
        const preview = modal.querySelector('[data-editor-preview]');
        if(preview) renderHelpPreview(preview, helpEditorState);
      }, { action: 'admin-help-input' }));
    }

    function renderWhatsNewPreview(container, items){
      if(!container) return;
      container.innerHTML = items.map(item => `<div class="text-sm mb-2">âœ… ${escapeHtml(item.text || '')}</div>`).join('') || '<div class="text-xs text-gray-400">No preview items.</div>';
    }

    function renderWhatsNewEditor(){
      const modal = document.getElementById('adminWhatsNewEditorModal');
      if(!modal || !whatsNewEditorState) return;
      const form = modal.querySelector('[data-editor-form]');
      const preview = modal.querySelector('[data-editor-preview]');
      if(!form) return;
      const items = whatsNewEditorState.items || [];
      const itemRows = items.map((item, index) => `
        <div class="mt-2 p-2 border border-white/10 rounded-lg space-y-2">
          <div class="text-xs text-cyan-200 font-semibold">Item ${index + 1}</div>
          <input class="admin-editor-input" data-field="whatsnew-id" data-index="${index}" value="${escapeHtml(item.id || '')}" placeholder="id" />
          <input class="admin-editor-input" data-field="whatsnew-text" data-index="${index}" value="${escapeHtml(item.text || '')}" placeholder="Text" />
          <input class="admin-editor-input" data-field="whatsnew-requires" data-index="${index}" value="${escapeHtml((item.requires || []).join(', '))}" placeholder="requires (comma-separated flags)" />
          <div class="admin-editor-inline-actions">
            <button class="admin-editor-btn" data-action="move-up" data-target="whatsNew" data-index="${index}">â†‘</button>
            <button class="admin-editor-btn" data-action="move-down" data-target="whatsNew" data-index="${index}">â†“</button>
            <button class="admin-editor-btn" data-action="remove-item" data-target="whatsNew" data-index="${index}">Remove</button>
          </div>
        </div>
      `).join('') || '<div class="text-xs text-gray-400">No Whatâ€™s New items yet.</div>';

      form.innerHTML = `
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">Version</div>
          <input class="admin-editor-input" data-field="whatsnew-version" value="${escapeHtml(whatsNewEditorState.version ?? 1)}" />
        </div>
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">Items</div>
          ${itemRows}
          <button class="admin-editor-btn mt-2" data-action="add-item" data-target="whatsNew">+ Add Item</button>
        </div>
      `;
      renderWhatsNewPreview(preview, items);
    }

    async function saveWhatsNewEditor(){
      if(!window.configService) return alert('Config service unavailable');
      const status = document.querySelector('#adminWhatsNewEditorModal [data-editor-status]');
      if(status) status.textContent = 'Saving...';
      try{
        const payload = window.configService.validateWhatsNewDoc(whatsNewEditorState);
        if(!payload) throw new Error('Validation failed. Add at least one item.');
        const saved = await window.configService.saveWhatsNew({
          firestore,
          data: payload,
          updatedBy: getEditorUpdatedBy()
        });
        whatsNewState = saved;
        whatsNewEditorState = cloneConfig(saved);
        renderWhatsNew();
        renderWhatsNewEditor();
        if(status) status.textContent = 'Saved âœ…';
      }catch(err){
        console.warn('[admin] whats new save failed', err);
        if(status) status.textContent = `Save failed: ${err.message || err}`;
        alert(`What's New save failed: ${err.message || err}`);
      }
    }

    function openAdminWhatsNewEditor(){
      if(!isAdmin()) return alert('Admin only');
      closeAdminEditorModal('adminWhatsNewEditorModal');
      whatsNewEditorState = cloneConfig(whatsNewState || window.DEFAULT_WHATS_NEW);
      if(!whatsNewEditorState){
        whatsNewEditorState = { version: 1, items: [] };
      }
      whatsNewEditorState.items = whatsNewEditorState.items || [];
      const modal = document.createElement('div');
      modal.id = 'adminWhatsNewEditorModal';
      modal.className = 'admin-editor-modal';
      modal.innerHTML = `
        <div class="admin-editor-card">
          <div class="admin-editor-header">
            <div>
              <div class="text-lg font-bold text-white">Whatâ€™s New Editor</div>
              <div class="text-xs text-cyan-200">Edit release bullets shown in Help.</div>
            </div>
            <button class="admin-editor-btn" data-action="close-editor">Close</button>
          </div>
          <div class="admin-editor-body">
            <div class="admin-editor-columns">
              <div data-editor-form></div>
              <div>
                <div class="text-sm font-semibold text-cyan-100 mb-2">Preview</div>
                <div class="admin-editor-preview" data-editor-preview></div>
              </div>
            </div>
            <div class="flex items-center justify-between gap-3 flex-wrap">
              <div class="text-xs text-cyan-200" data-editor-status></div>
              <div class="admin-editor-actions">
                <button class="admin-editor-btn" data-action="reset-whatsnew">Reset to defaults</button>
                <button class="admin-editor-btn" data-action="save-whatsnew">Save & Publish</button>
              </div>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      renderWhatsNewEditor();
      modal.addEventListener('click', safeOn('click', (e) => {
        const btn = closestFromEvent(e, '[data-action]', { within: modal });
        if(!btn) return;
        const action = btn.dataset?.action;
        if(!action) return;
        if(action === 'close-editor'){ closeAdminEditorModal('adminWhatsNewEditorModal'); return; }
        if(action === 'save-whatsnew'){ saveWhatsNewEditor(); return; }
        if(action === 'reset-whatsnew'){
          whatsNewEditorState = cloneConfig(window.DEFAULT_WHATS_NEW);
          renderWhatsNewEditor();
          return;
        }
        const target = btn.dataset?.target;
        const index = Number(btn.dataset?.index);
        if(!target) return;
        if(action === 'add-item' && target === 'whatsNew'){
          whatsNewEditorState.items.push({ id: 'new_item', text: 'New update', requires: [] });
          renderWhatsNewEditor();
          return;
        }
        if(action === 'remove-item' && target === 'whatsNew'){
          if(Number.isNaN(index)) return;
          whatsNewEditorState.items.splice(index, 1);
          renderWhatsNewEditor();
          return;
        }
        if((action === 'move-up' || action === 'move-down') && target === 'whatsNew'){
          if(Number.isNaN(index)) return;
          const delta = action === 'move-up' ? -1 : 1;
          moveItem(whatsNewEditorState.items, index, index + delta);
          renderWhatsNewEditor();
        }
      }, { action: 'admin-whatsnew-click' }));
      modal.addEventListener('input', safeOn('input', (e) => {
        const target = getEventElement(e);
        const field = target?.dataset?.field;
        if(!field) return;
        const index = Number(target.dataset?.index);
        const value = target.value;
        if(field === 'whatsnew-version'){ whatsNewEditorState.version = Number(value) || 1; }
        if(field === 'whatsnew-id'){
          if(Number.isNaN(index)) return;
          whatsNewEditorState.items[index].id = value;
        }
        if(field === 'whatsnew-text'){
          if(Number.isNaN(index)) return;
          whatsNewEditorState.items[index].text = value;
        }
        if(field === 'whatsnew-requires'){
          if(Number.isNaN(index)) return;
          whatsNewEditorState.items[index].requires = parseCommaList(value);
        }
        renderWhatsNewPreview(modal.querySelector('[data-editor-preview]'), whatsNewEditorState.items);
      }, { action: 'admin-whatsnew-input' }));
    }

    async function maybeLoadSharedProfile(){
      if(!profileParam){ viewingProfile = null; return; }
      friendSearchTerm = profileParam;
      if(!firebaseAuth?.currentUser){ friendLookupError = 'Sign in required to view other profiles.'; return; }
      if(currentUser && (currentUser.username === profileParam || currentUser.uid === profileParam)){
        viewingProfile = null; setProfileQueryParam(null); return;
      }
      const matches = await fetchProfilesByField('usernameLower', normalizeUsernameLower(profileParam));
      const profile = matches[0] || await loadProfileForViewing(profileParam);
      if(profile){
        viewingProfile = normalizeProfileShape(profile, profile.username || profile.uid);
        setProfileQueryParam(viewingProfile.username || viewingProfile.uid || '');
        view = 'profile';
      } else {
        friendLookupError = `No profile found for â€˜${profileParam}â€™`;
      }
    }

    const helpModal = document.getElementById('helpModal');
    if(helpModal){
      helpModal.addEventListener('click',(e)=>{
        const target = getEventElement(e);
        if(target === helpModal) closeHelp();
      });
      bindHelpTabs();
      bindHelpFaqTracking();
      renderHelpContent();
    }
    bindTourEvents();
    window.addEventListener('resize', ()=>{ if(tourState.isOpen) updateTourUI(); });
    window.addEventListener('scroll', ()=>{ if(tourState.isOpen) updateTourUI(); }, true);
    document.addEventListener('keydown', safeOn('keydown', (e)=>{
      if(tourState.isOpen){
        if(e.key === 'Escape'){
          skipTour();
          return;
        }
        trapTourFocus(e);
        return;
      }
      if(e.key === 'Escape'){ closeHelp(); }
    }, { action: 'global-keydown' }));

    // ----------------------- Init / Auth check ------------------------
    loadOverridesFromStorage();
    handleNetworkStatusChange();
    document.addEventListener('visibilitychange', () => {
      if(document.visibilityState === 'hidden'){
        if(currentUser){
          persistProfileRobust(currentProfileFromState(), { reason: 'system' }).catch(()=>{});
        }
        flushOwnedLibraryPendingWrite().catch(()=>{});
      }
    });
    window.addEventListener('beforeunload', () => {
      if(currentUser){
        persistProfileRobust(currentProfileFromState(), { reason: 'system' }).catch(()=>{});
      }
    });
    window.addEventListener('pagehide', () => {
      flushOwnedLibraryPendingWrite().catch(()=>{});
    });
    window.addEventListener('online', ()=>{ handleNetworkStatusChange(); if(!songs.length) retryTracksNow(); });
    window.addEventListener('offline', handleNetworkStatusChange);
    if('serviceWorker' in navigator){
      window.addEventListener('load', ()=>{
        navigator.serviceWorker.getRegistrations()
          .then((registrations) => registrations.forEach((registration) => registration.unregister()))
          .catch(err=>console.warn('SW cleanup failed', err));
      });
    }
    initCommunityMetrics();
    let bootstrapInvoked = false;
    function bootstrapApp(){
      if(bootstrapInvoked) return;
      bootstrapInvoked = true;
      boot.logs = window.__BOOT__?.steps ? window.__BOOT__.steps.slice() : [];
      boot.errors = [];
      boot.lastError = window.__BOOT__?.lastError || null;
      startBootDeadline();
      recordBootStep('bootstrap started');
      setAppBootState(APP_BOOT_STATES.bootLoading);
      renderBootstrapGate('Checking sign-inâ€¦');
      (async () => {
        try{
          if (firebaseEnabled && firebaseAuth) {
            await withTimeout(ensureFirebasePersistence(), BOOT_CALL_TIMEOUT_MS, 'auth persistence');
            recordBootStep('persistence set');
            const initialUser = await withTimeout(resolveInitialAuthState(), BOOT_CALL_TIMEOUT_MS, 'auth state');
            recordBootStep(`auth resolved: ${initialUser?.uid || 'signedOut'}`);
            setupFirebaseAuthListener();
            if(!initialUser){
              enterSignedOutState();
              return;
            }
            if(!initialUser.uid){
              console.warn('[auth] missing uid');
              setSyncError({ code: 'missing_uid', step: 'checkingAuth', message: 'Sign in again to restore sync.' });
              await firebaseAuth.signOut();
              enterSignedOutState();
              return;
            }
            authSettledUser = initialUser.uid;
            enforcePostLoginDefaults();
            updateSyncState({ state: SYNC_STATES.loadingRemote, message: 'Sync: Loadingâ€¦', errorCode: null, errorStep: null });
            const savedUsername = getSavedUsername();
            const emailPrefix = initialUser.email ? initialUser.email.split('@')[0] : '';
            const defaultUsername = savedUsername || initialUser.displayName || emailPrefix || `user_${initialUser.uid.slice(0,6)}`;
            currentUser = normalizeProfileShape({
              uid: initialUser.uid,
              email: initialUser.email || '',
              username: defaultUsername,
              djName: defaultUsername
            }, initialUser.uid);
            view = DEFAULT_VIEW;
            setAppBootState(APP_BOOT_STATES.ready);
            render();
            setupEventListeners();
            recordBootStep('READY rendered');
            void loadAppData({ loadSongs: !songs.length, loadProfile: false, preferCache: false, showBootScreen: false, allowProfileAutoOpen: false });
            const legacyIds = [currentUser?.username, initialUser.email, emailPrefix, initialUser.displayName]
              .filter((value) => value && value !== initialUser.uid);
            void (async () => {
              let migrationOwned = [];
              try{
                migrationOwned = await withTimeout(migrateLegacyOwnedTracks(initialUser.uid, legacyIds), BOOT_CALL_TIMEOUT_MS, 'legacy owned migration') || [];
              }catch(err){
                console.warn('[owned-library] legacy migration failed', err);
              }
              await hydrateSignedInProfile({ uid: initialUser.uid, email: initialUser.email || '', legacyOwnedTracks: migrationOwned });
            })();
            return;
          }
          const savedUsername = getSavedUsername();
          const profile = savedUsername ? await loadUserProfile(savedUsername) : null;
          if(profile){
            recordBootStep(`auth resolved: ${profile.uid || profile.username || 'local'}`);
            currentUser = profile;
            enforcePostLoginDefaults();
            view = DEFAULT_VIEW;
            setAppBootState(APP_BOOT_STATES.ready);
            render();
            setupEventListeners();
            recordBootStep('READY rendered');
            void loadAppData({ loadSongs: true, loadProfile: true, preferCache: false, showBootScreen: false, allowProfileAutoOpen: false });
            return;
          }
          recordBootStep('auth resolved: signedOut');
          enterSignedOutState();
        }catch(err){
          showFatalBootError(err);
        }
      })();
    }

    updatePerformanceMode();
    reducedMotionQuery?.addEventListener?.('change', updatePerformanceMode);
    navigator?.connection?.addEventListener?.('change', updatePerformanceMode);
    if(mobileViewportQuery?.addEventListener){
      mobileViewportQuery.addEventListener('change', () => {
        updateMobileWindowState({ reset: true });
        scheduleSongListRender('viewport-change');
        updateStickyCTA();
      });
    } else {
      window.addEventListener('resize', () => {
        updateMobileWindowState({ reset: true });
        scheduleSongListRender('viewport-resize');
        updateStickyCTA();
      }, { passive: true });
    }

    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', bootstrapApp, { once: true });
    } else {
      bootstrapApp();
    }

    // ------------------ Drag/drop support ---------------------------
    document.addEventListener('dragstart', safeOn('dragstart', (e)=>{
      const card = closestFromEvent(e, '.song-card');
      if(card){
        const songId = card.getAttribute('data-song-id');
        if(songId) e.dataTransfer.setData('text/plain', songId);
      }
    }, { action: 'drag-song-card' }));
    // ---------------- Expose some helpers for debugging ----------------
    window.openHelp = openHelp; window.openHelpModal = openHelpModal; window.closeHelp = closeHelp; window.render = render; window.loadSongs = loadSongs; window.renderSongList = renderSongList; window.renderSetlist = renderSetlist; window.viewFriendProfile = viewFriendProfile; window.startTour = startTour; window.refreshLiveNowUsers = refreshLiveNowUsers;
    window.__perfState = {
      get listRenderCount(){ return listRenderCount; },
      get maxMobileCards(){ return maxMobileCardsRendered; }
    };
  </script>
</body>
</html>
