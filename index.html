<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <meta name="theme-color" content="#0f1020" />
  <title>Fortnite Jam Mixer â€“ Cross-Browser Edition</title>
  <meta name="description" content="Fortnite Jam Mixer helps you build harmonious Fortnite Festival mashups with Camelot, BPM, and setlist tools." />
  <link rel="manifest" href="/manifest.webmanifest" />
  <script>document.documentElement.classList.add('tw-offline');</script>
  <link rel="stylesheet" href="/offline.css" />
  <script src="https://cdn.tailwindcss.com" onload="document.documentElement.classList.remove('tw-offline');" onerror="console.warn('Tailwind CDN unavailable; using offline fallback.');"></script>

  <!-- Firebase config injected from Vercel (serverless /api/firebase-config) -->
  <script src="/api/firebase-config"></script>

  <!-- Optional Firebase SDKs (compat). Enable only if you use Firebase. -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="/constants/appMeta.js"></script>
  <script src="/services/configService.js"></script>
  <script type="module" src="/services/profileStore.js"></script>

  <style>
    /* ---------------- Theme & Layout ---------------- */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html,body { height: 100%; }
    body {
      background: linear-gradient(135deg, #0f1020 0%, #14122a 40%, #071130 100%);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #e9f7ff;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      padding-bottom: env(safe-area-inset-bottom);
    }
    :root {
      --safe-top: env(safe-area-inset-top);
      --safe-bottom: env(safe-area-inset-bottom);
      --sticky-cta-height: 64px;
    }
    button,
    input:not([type="checkbox"]):not([type="radio"]):not([type="range"]),
    select,
    textarea {
      min-height: 44px;
    }
    .content-wrapper { max-width: 1200px; margin: 18px auto; padding: 12px; }
    .panel { background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.45)); border-radius: 12px; border: 1px solid rgba(255,255,255,0.03); padding: 12px; }
    .vinyl-spin { animation: spin 4s linear infinite; }
    .bounce-icon { animation: bounce 2s ease-in-out infinite; }
    @keyframes spin { from { transform: rotate(0) } to { transform: rotate(360deg) } }
    @keyframes bounce { 0%,100% { transform: translateY(0) } 50% { transform: translateY(-8px) } }
    .graffiti-text { text-shadow: 3px 3px 0 #ff6b9d, 6px 6px 0 rgba(255,107,157,0.22); letter-spacing: 1px; }
    .camelot-pill { padding: 6px 10px; border-radius: 10px; font-weight: 700; color: #fff; }
    .score-badge { font-weight: 800; letter-spacing: .6px; padding: 6px 10px; border-radius: 8px; display:inline-block; }
    .small-muted { color: rgba(230,247,255,0.7); font-size: 13px; }
    .sandbox-drop { min-height: 110px; border-radius: 12px; padding: 10px; border: 2px dashed rgba(255,255,255,0.04); }
    .context-menu { position: fixed; background: rgba(0,0,0,0.95); border-radius: 8px; padding: 8px; z-index:10000; backdrop-filter: blur(8px); border: 1px solid rgba(0,217,255,0.12); color: #e6f7ff; }
    .glow-perfect { box-shadow: 0 0 18px rgba(57,255,20,0.85), 0 0 48px rgba(57,255,20,0.12); }
    .glow-good { box-shadow: 0 0 12px rgba(255,230,65,0.9), 0 0 36px rgba(255,230,65,0.08); }
    .glow-bad { box-shadow: 0 0 12px rgba(255,63,63,0.9), 0 0 36px rgba(255,63,63,0.08); }
    .selected-panel { border: 2px solid rgba(0,217,255,0.6); box-shadow: 0 0 18px rgba(0,217,255,0.18), 0 0 32px rgba(255,107,157,0.18); background: linear-gradient(90deg, rgba(0,217,255,0.1), rgba(255,107,157,0.12)); }
    .selected-badge { background: linear-gradient(90deg,#06b6d4,#ec4899); color:#fff; font-weight:800; padding:6px 10px; border-radius:999px; font-size:11px; letter-spacing:0.5px; box-shadow: 0 0 12px rgba(6,182,212,0.4); }
    .selected-card { border: 2px solid rgba(0,217,255,0.8); box-shadow: 0 0 26px rgba(0,217,255,0.45), 0 0 12px rgba(236,72,153,0.25); }
    #adminToolsBtn { pointer-events: auto; cursor: pointer; }
    .admin-tools-menu { z-index: 6000; pointer-events: auto; position: absolute; }
    .song-grid { grid-template-columns: 1fr; contain: layout paint; }
    .song-card { content-visibility: auto; contain-intrinsic-size: 320px 220px; }
    .reduced-effects .vinyl-spin,
    .reduced-effects .bounce-icon { animation: none !important; }
    .reduced-effects .glow-perfect,
    .reduced-effects .glow-good,
    .reduced-effects .glow-bad,
    .reduced-effects .selected-card { box-shadow: none !important; }
    .reduced-effects .song-card { transition: none; }
    .header-actions { gap: 12px; }
    .header-secondary { margin-top: 8px; }
    .header-secondary[hidden] { display: none; }
    .safe-header { padding-top: var(--safe-top); }
    .mobile-hidden { display: none; }
    .mobile-only { display: none; }
    .sticky-cta-bar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 90;
      padding: 10px 16px calc(10px + var(--safe-bottom));
      background: rgba(10, 10, 24, 0.92);
      border-top: 1px solid rgba(0,217,255,0.2);
      backdrop-filter: blur(14px);
      box-shadow: 0 -6px 24px rgba(0,0,0,0.4);
      transform: translateY(0);
      transition: transform 0.2s ease;
    }
    .sticky-cta-bar.hidden { transform: translateY(110%); }
    .sticky-cta-button {
      width: 100%;
      min-height: 48px;
      border-radius: 14px;
      background: linear-gradient(90deg,#ff6b9d,#8b5cf6);
      color: #fff;
      font-weight: 800;
      letter-spacing: 0.3px;
      border: none;
    }
    .sticky-cta-copy { font-size: 12px; color: rgba(230,247,255,0.75); margin-top: 4px; text-align: center; }
    .sticky-cta-spotlight { opacity: 0.7; transition: opacity 0.2s ease; }
    .sticky-cta-active .sticky-cta-spotlight { opacity: 1; }
    .sticky-cta-active .dim-when-sticky { opacity: 0.7; }
    .song-list-highlight .song-card { border-color: rgba(0,217,255,0.45); }
    .skeleton-card {
      border-radius: 14px;
      padding: 16px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      animation: pulse 1.5s ease-in-out infinite;
    }
    .skeleton-line { height: 12px; border-radius: 999px; background: rgba(255,255,255,0.12); margin-bottom: 8px; }
    .skeleton-line.short { width: 50%; }
    .skeleton-line.medium { width: 70%; }
    .skeleton-line.long { width: 90%; }
    .inline-banner {
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(59,130,246,0.12);
      border: 1px solid rgba(59,130,246,0.4);
      color: #dff7ff;
      font-size: 12px;
      font-weight: 600;
    }
    .quickstart-modal {
      position: fixed;
      inset: 0;
      z-index: 21000;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(2,6,23,0.8);
      backdrop-filter: blur(8px);
      padding: 16px;
    }
    .quickstart-card {
      width: min(520px, 94vw);
      background: linear-gradient(180deg, rgba(8,13,30,0.98), rgba(16,10,32,0.98));
      border-radius: 18px;
      border: 1px solid rgba(0,217,255,0.2);
      padding: 18px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.6);
    }
    .quickstart-actions { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 16px; }
    .quickstart-actions button { flex: 1 1 140px; }
    .quickstart-option {
      width: 100%;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: #fff;
      font-weight: 700;
      text-align: left;
    }
    .quickstart-option strong { display: block; font-size: 15px; }
    .quickstart-track {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.12);
      cursor: pointer;
    }
    .quickstart-track:hover { border-color: rgba(0,217,255,0.6); }

    @media (max-width: 640px) {
      .header-secondary { display: none; }
      .header-secondary.is-open { display: block; }
      .mobile-hidden { display: none !important; }
      .mobile-only { display: inline-flex; }
      .header-actions { gap: 10px; }
      .content-wrapper { padding: 8px; }
    }
    @media (prefers-reduced-motion: reduce) {
      .sticky-cta-bar { transition: none; }
    }
    @media (min-width: 768px) {
      .song-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    .live-carousel { scroll-snap-type: x mandatory; scroll-behavior: smooth; }
    .live-carousel > * { scroll-snap-align: start; }
    .live-carousel.dragging { cursor: grabbing; }
    .live-carousel::-webkit-scrollbar { height: 6px; }
    .live-carousel::-webkit-scrollbar-thumb { background: rgba(79,70,229,0.6); border-radius: 999px; }
    .rating-star { color: rgba(255,255,255,0.35); transition: transform 0.15s ease, color 0.15s ease; }
    .rating-star.active { color: #fbbf24; transform: translateY(-1px) scale(1.05); }
    .rating-star-display { color: #fbbf24; }
    .profile-accent-border { border-color: var(--profile-accent, #ff6b9d); }
    .profile-accent-glow { box-shadow: 0 0 18px var(--profile-accent-glow, rgba(255,107,157,0.45)); }
    .profile-accent-pill { background: rgba(255,255,255,0.06); border: 1px solid var(--profile-accent, #ff6b9d); color: #fff; }
    .profile-avatar-action { cursor: pointer; }
    .profile-avatar-action:focus-visible { outline: 2px solid var(--profile-accent, #ff6b9d); outline-offset: 4px; }
    .profile-avatar-overlay { pointer-events: none; }
    .persona-option { border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.04); }
    .persona-option.active { border-color: var(--profile-accent, #ff6b9d); box-shadow: 0 0 12px var(--profile-accent-glow, rgba(255,107,157,0.45)); transform: scale(1.04); }
    .persona-option:hover { box-shadow: 0 0 16px rgba(255,255,255,0.2); transform: translateY(-1px) scale(1.02); }
    .persona-badge { position: relative; display: inline-flex; align-items: center; justify-content: center; }
    .persona-badge svg { display: block; }
    .persona-energy { position: absolute; right: -4px; bottom: -4px; font-size: 12px; padding: 2px 6px; border-radius: 999px; background: rgba(0,0,0,0.75); border: 1px solid rgba(255,255,255,0.3); box-shadow: 0 0 10px rgba(255,255,255,0.2); }
    .persona-ring { animation: personaPulse 3s ease-in-out infinite; }
    .persona-spark { animation: personaSpark 2.2s ease-in-out infinite; }
    .persona-card { transition: transform 0.15s ease, box-shadow 0.15s ease; }
    .persona-card:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 0 16px rgba(56,189,248,0.3); }
    @keyframes personaPulse { 0%,100% { opacity: 0.85; } 50% { opacity: 0.55; } }
    @keyframes personaSpark { 0%,100% { transform: translateY(0); opacity: 0.8; } 50% { transform: translateY(-3px); opacity: 1; } }
    .profile-toggle { accent-color: var(--profile-accent, #ff6b9d); }

    /* Help modal */
    #helpModal {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 20000;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      backdrop-filter: blur(6px);
    }
    #helpModal[aria-hidden="true"] { display: none; pointer-events: none; }
    #helpModal[aria-hidden="false"] { pointer-events: auto; }
    .helpBox {
      width: 92%;
      max-width: 760px;
      height: 80vh;
      background: linear-gradient(180deg, rgba(12,10,25,0.96), rgba(20,16,38,0.98));
      border-radius: 14px;
      border: 2px solid rgba(0,217,255,0.14);
      box-shadow: 0 10px 40px rgba(0,0,0,0.6), 0 0 50px rgba(0,217,255,0.06);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .helpHeader {
      padding: 14px 18px;
      border-bottom: 1px solid rgba(0,217,255,0.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .helpTitle { font-size:20px; font-weight:800; color:#fff; display:flex; gap:10px; align-items:center; }
    .helpTabs { display:flex; gap:8px; align-items:center; }
    .helpTabBtn { padding:8px 10px; border-radius:10px; border:1px solid rgba(0,217,255,0.18); background:rgba(255,255,255,0.06); color:#dff7ff; font-weight:800; cursor:pointer; }
    .helpTabBtn.active { background: linear-gradient(90deg,#ff6b9d,#8b5cf6); border-color: rgba(255,255,255,0.14); box-shadow:0 0 18px rgba(139,92,246,0.18); color:#fff; }
    .helpContent {
      padding: 14px 18px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      color: #dff7ff;
      line-height:1.45;
      font-size:14px;
    }
    .helpSection { margin-bottom: 18px; }
    .helpSection h3 { font-size: 16px; margin-bottom: 6px; font-weight: 800; color: #fff; }
    .helpSection h4 { font-size: 14px; margin-bottom: 6px; font-weight: 800; color: #9fe8ff; }
    .helpSection p, .helpSection ul, .helpSection ol { margin-bottom: 8px; }
    .helpSection ul { margin-left: 16px; }
    .helpSection ol { margin-left: 18px; }
    .helpComing { color: rgba(159,232,255,0.7); font-size: 12px; font-style: italic; display: none; }
    .helpFaq { border: 1px solid rgba(0,217,255,0.18); background: rgba(255,255,255,0.03); border-radius: 10px; padding: 8px 12px; margin-bottom: 10px; }
    .helpFaq summary { cursor: pointer; font-weight: 700; color: #e6f7ff; list-style: none; }
    .helpFaq summary::-webkit-details-marker { display: none; }
    .helpFaq p { margin-top: 6px; color: rgba(230,247,255,0.8); font-size: 13px; }
    .helpDivider { margin: 14px 0; border-color: rgba(0,217,255,0.08); }
    .anchorGrid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 8px; margin-bottom: 12px; }
    .anchorLink { display: block; padding: 10px 12px; border-radius: 10px; background: rgba(0,217,255,0.06); border: 1px solid rgba(0,217,255,0.12); color: #e6f7ff; text-decoration: none; font-weight: 700; }
    .anchorLink:hover { border-color: rgba(255,107,157,0.35); box-shadow: 0 0 12px rgba(255,107,157,0.18); }
    .callout { padding: 12px; border-radius: 10px; border: 1px solid rgba(0,217,255,0.14); background: rgba(0,217,255,0.05); margin-bottom: 10px; }
    .calloutTitle { font-weight: 800; margin-bottom: 6px; display: flex; align-items: center; gap: 6px; color: #9fe8ff; text-transform: uppercase; letter-spacing: 0.3px; font-size: 12px; }
    .tag { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 999px; background: rgba(0,217,255,0.12); color: #bdeeff; font-weight: 700; font-size: 12px; }
    .camelot-wheel { width: 100%; max-width: 520px; margin: 10px auto; display: flex; justify-content: center; }
    .camelot-wheel svg { width: 100%; height: auto; }
    .camelot-caption { text-align: center; color: #e6f7ff; font-size: 13px; margin-top: 6px; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; font-weight: 800; font-size: 12px; }
    .helpFooter { padding: 10px 14px; border-top: 1px solid rgba(0,217,255,0.04); text-align:right; }
    .helpFooter { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .helpFooterActions { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .helpAltBtn {
      background: rgba(255,255,255,0.08);
      padding: 8px 12px;
      border-radius: 10px;
      color: #dff7ff;
      font-weight:700;
      cursor:pointer;
      border: 1px solid rgba(0,217,255,0.2);
      transition: all .2s ease;
    }
    .helpAltBtn:hover { background: rgba(255,255,255,0.16); color: #fff; border-color: rgba(255,255,255,0.3); }

    /* Custom neon scrollbar for helpContent */
    .helpContent::-webkit-scrollbar { width: 12px; }
    .helpContent::-webkit-scrollbar-track { background: linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.06)); border-radius:8px; }
    .helpContent::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(0,217,255,0.9), rgba(255,107,157,0.9));
      border-radius: 8px;
      border: 2px solid rgba(0,0,0,0.2);
      box-shadow: 0 0 12px rgba(0,217,255,0.14);
    }
    .helpCloseBtn {
      background: linear-gradient(90deg,#ff6b9d,#8b5cf6);
      padding: 8px 12px;
      border-radius: 10px;
      color: #fff;
      font-weight:700;
      cursor:pointer;
      border: none;
      box-shadow: 0 6px 24px rgba(139,92,246,0.12);
    }
    .helpIconBtn {
      width: 40px;
      height: 40px;
      min-width: 40px;
      min-height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      color: #e5f6ff;
      font-weight: 800;
      font-size: 14px;
      cursor: pointer;
      transition: all .2s ease;
    }
    .helpIconBtn:hover { background: rgba(255,255,255,0.2); color: #fff; }
    .helpIconBtn:focus-visible { outline: 2px solid rgba(0,217,255,0.8); outline-offset: 2px; }

    /* Admin editor modal */
    .admin-editor-modal { position: fixed; inset: 0; z-index: 7000; display: flex; align-items: center; justify-content: center; background: rgba(3,7,18,0.75); backdrop-filter: blur(8px); }
    .admin-editor-card { width: min(1100px, 95vw); max-height: 90vh; overflow: hidden; background: rgba(3,7,18,0.95); border: 1px solid rgba(0,217,255,0.2); border-radius: 18px; display: flex; flex-direction: column; }
    .admin-editor-header { padding: 16px 20px; border-bottom: 1px solid rgba(0,217,255,0.15); display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .admin-editor-body { padding: 18px 20px; overflow: auto; display: grid; gap: 16px; }
    .admin-editor-columns { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
    .admin-editor-section { border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 12px; background: rgba(255,255,255,0.04); }
    .admin-editor-row { display: grid; gap: 8px; align-items: center; grid-template-columns: 1fr auto; }
    .admin-editor-row + .admin-editor-row { margin-top: 8px; }
    .admin-editor-input, .admin-editor-textarea { width: 100%; background: rgba(15,23,42,0.9); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 8px 10px; color: #fff; font-size: 13px; }
    .admin-editor-textarea { min-height: 70px; resize: vertical; }
    .admin-editor-actions { display: flex; flex-wrap: wrap; gap: 8px; justify-content: flex-end; }
    .admin-editor-btn { padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.08); color: #fff; font-size: 12px; font-weight: 600; }
    .admin-editor-btn:hover { background: rgba(255,255,255,0.18); }
    .admin-editor-preview { border: 1px solid rgba(0,217,255,0.18); border-radius: 12px; padding: 12px; background: rgba(0,0,0,0.4); max-height: 520px; overflow: auto; }
    .admin-editor-inline-actions { display: flex; gap: 6px; flex-wrap: wrap; }

    /* Tour overlay */
    #tourOverlay {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 25000;
      pointer-events: none;
    }
    #tourOverlay[aria-hidden="true"] { display: none; pointer-events: none; }
    #tourOverlay[aria-hidden="false"] { pointer-events: auto; }
    #tourOverlay[data-open="true"] { display: block; pointer-events: auto; }
    .tour-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(5,8,20,0.75);
      backdrop-filter: blur(3px);
    }
    .tour-highlight {
      position: fixed;
      border-radius: 14px;
      border: 2px solid rgba(0,217,255,0.75);
      box-shadow: 0 0 0 2px rgba(0,217,255,0.15), 0 0 25px rgba(0,217,255,0.45);
      transition: all .2s ease;
      pointer-events: none;
    }
    .tour-tooltip {
      position: fixed;
      max-width: 320px;
      width: calc(100% - 32px);
      background: linear-gradient(180deg, rgba(12,10,25,0.98), rgba(20,16,38,0.98));
      border-radius: 14px;
      border: 1px solid rgba(0,217,255,0.22);
      box-shadow: 0 12px 35px rgba(0,0,0,0.55), 0 0 28px rgba(0,217,255,0.18);
      color: #e6f7ff;
      padding: 14px 16px;
      pointer-events: auto;
    }
    .tour-title { font-size: 16px; font-weight: 800; margin-bottom: 6px; }
    .tour-copy { font-size: 14px; color: rgba(230,247,255,0.85); margin-bottom: 10px; }
    .tour-hint { font-size: 12px; color: rgba(159,232,255,0.8); margin-bottom: 10px; }
    .tour-actions { display: flex; flex-wrap: wrap; gap: 8px; justify-content: space-between; }
    .tour-actions .tour-left { display:flex; gap:8px; flex-wrap:wrap; }
    .tour-actions .tour-right { display:flex; gap:8px; flex-wrap:wrap; margin-left:auto; }
    .tour-btn {
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 700;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      color: #e6f7ff;
      cursor: pointer;
    }
    .tour-btn:hover { background: rgba(255,255,255,0.18); }
    .tour-btn-primary { background: linear-gradient(90deg,#ff6b9d,#8b5cf6); border: none; color: #fff; }
    .tour-btn-primary:hover { filter: brightness(1.05); }
    .tour-btn-secondary { border-color: rgba(0,217,255,0.4); color: #bdf1ff; }
    .tour-btn[disabled] { opacity: 0.5; cursor: not-allowed; }

    /* responsive tweaks */
    @media (max-width: 980px) {
      .two-col { flex-direction: column; }
      .rightCol { width: 100% !important; min-width: auto; }
    }
  </style>
</head>
<body>
  <div class="content-wrapper">
    <div id="app">
      <div class="min-h-screen flex items-center justify-center">
        <div class="text-center">
          <div class="text-6xl mb-4 animate-pulse">ðŸŽµ</div>
          <div class="text-2xl font-bold text-white" data-brand="loading">Loading Fortnite Jam Mixer...</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Modal (outside #app so it persists) -->
  <div id="helpModal" aria-hidden="true">
      <div class="helpBox" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
      <div class="helpHeader">
        <div class="helpTitle" id="helpTitle">
          <div style="width:50px;height:50px;border-radius:10px;display:flex;align-items:center;justify-content:center;background:linear-gradient(90deg,#ff6b9d,#8b5cf6);box-shadow:0 8px 24px rgba(139,92,246,0.12);font-size:22px;">ðŸŽ§</div>
          <div>
            <div style="font-size:18px;font-weight:800">HELP & FEATURES</div>
            <div style="font-size:12px;color:#bdeeff">Everything the landing page explains â€” available anytime</div>
          </div>
        </div>
        <div class="helpTabs" role="tablist" aria-label="Help tabs">
          <button id="helpTabBasic" class="helpTabBtn active" data-tab="basic" role="tab" aria-selected="true" aria-controls="helpBasic">Basic</button>
          <button id="helpTabAdvanced" class="helpTabBtn" data-tab="advanced" role="tab" aria-selected="false" aria-controls="helpAdvanced" tabindex="-1">Advanced</button>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <button class="helpCloseBtn" onclick="closeHelp()" aria-label="Close help">âœ• Close</button>
        </div>
      </div>

      <div class="helpContent" id="helpContent">
        <div id="helpBasic" data-help-pane="basic">
          <div class="helpSection" id="welcome">
            <h3 data-brand="help-title">Fortnite Jam Mixer Help</h3>
            <p class="small-muted" data-brand="help-intro">Simple steps you can follow fast. Start with Quick Start, then skim the sections below.</p>
          </div>

          <div class="helpSection" id="quickstart">
            <h3>Quick Start (30 seconds)</h3>
            <ol id="helpQuickStartList" style="line-height:1.6"></ol>
          </div>

          <div class="helpSection" id="whatsNew">
            <h3>Whatâ€™s New</h3>
            <ul id="whatsNewList"></ul>
            <p class="small-muted" id="whatsNewEmpty" style="display:none">Nothing new right now â€” check back after the next update.</p>
          </div>

          <div id="helpBasicSections"></div>

          <div class="helpSection" id="helpFaq">
            <h3>Troubleshooting FAQ</h3>
            <div id="helpFaqList"></div>
          </div>
        </div>

        <div id="helpAdvanced" data-help-pane="advanced" style="display:none">
          <div id="helpAdvancedSections"></div>
        </div>
      </div>

      <div class="helpFooter">
        <span class="small-muted" id="helpVersion"></span>
        <div class="helpFooterActions">
          <button class="helpAltBtn" onclick="startTour('help',{ force: true })">Run Quick Tour</button>
          <button class="helpCloseBtn" onclick="closeHelp()">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Quick Start Modal -->
  <div id="quickStartModal" class="quickstart-modal" aria-hidden="true">
    <div class="quickstart-card" role="dialog" aria-modal="true" aria-labelledby="quickStartTitle">
      <div class="flex items-center justify-between mb-3">
        <div>
          <div id="quickStartTitle" class="text-lg font-bold text-white">Quick Start</div>
          <div id="quickStartSubtitle" class="text-xs text-cyan-200">Get mixing in under 30 seconds.</div>
        </div>
        <button class="text-sm text-gray-200 hover:text-white" data-action="closeQuickStart" aria-label="Close Quick Start">âœ•</button>
      </div>
      <div id="quickStartBody" class="space-y-3"></div>
      <div class="quickstart-actions">
        <button class="px-4 py-2 rounded-lg bg-white/10 border border-white/20 text-white" data-action="quickStartBack">Back</button>
        <button class="px-4 py-2 rounded-lg bg-white/10 border border-white/20 text-white" data-action="quickStartSkip">Skip for now</button>
      </div>
    </div>
  </div>

  <!-- Tour Overlay -->
  <div id="tourOverlay" aria-hidden="true">
    <div class="tour-backdrop"></div>
    <div class="tour-highlight" id="tourHighlight" style="display:none"></div>
    <div class="tour-tooltip" id="tourTooltip" role="dialog" aria-modal="true" aria-labelledby="tourTitle">
      <div class="tour-title" id="tourTitle"></div>
      <div class="tour-copy" id="tourCopy"></div>
      <div class="tour-hint" id="tourHint" style="display:none"></div>
      <div class="tour-actions">
        <div class="tour-left">
          <button class="tour-btn" id="tourBackBtn">Back</button>
          <button class="tour-btn tour-btn-secondary" id="tourRouteBtn" style="display:none">Go to Profile</button>
        </div>
        <div class="tour-right">
          <button class="tour-btn" id="tourSkipBtn">Skip</button>
          <button class="tour-btn tour-btn-primary" id="tourNextBtn">Next</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /**************************************************************************
     * Final merged app
     * - All fixes applied (setlist rendering, show-all toggle, mixable toggle, band member)
     * - Optional Firebase (see firebaseEnabled & firebaseConfig)
     * - Help modal integrated (manual open via header button)
     **************************************************************************/

const BRAND = Object.freeze({
  APP_NAME: 'Fortnite Jam Mixer',
  SHORT_NAME: 'Jam Mixer',
  EXPORT_PREFIX: 'fortnite-jam-mixer',
  BROWSER_TITLE: 'Fortnite Jam Mixer â€“ Cross-Browser Edition'
});
const DEBUG_UI = false;
const DEBUG_PROFILE = DEBUG_UI || (new URLSearchParams(window.location.search).get('debug') === '1');
let profileScriptError = null;
document.title = BRAND.BROWSER_TITLE;

    // -------------------- FIREBASE (auto-detect) ----------------------------
// We auto-enable Firebase if /api/firebase-config injected window.firebaseConfig (Vercel env vars).
// This prevents the "no signup option" problem when firebaseEnabled was left false.
const DEBUG_LOG_MAX = 50;
function logEvent(type, payload = {}) {
  const entry = {
    type,
    ts: Date.now(),
    payload
  };
  if (typeof location !== 'undefined' && location.hostname === 'localhost') {
    console.log('[telemetry]', entry);
  }
  try {
    const existing = JSON.parse(localStorage.getItem('debugLogs') || '[]');
    existing.push(entry);
    while (existing.length > DEBUG_LOG_MAX) existing.shift();
    localStorage.setItem('debugLogs', JSON.stringify(existing));
  } catch (e) {
    console.warn('Failed to persist debug log', e);
  }
}

function debugProfileLog(message, data = {}){
  if(!DEBUG_PROFILE) return;
  if(Object.keys(data || {}).length){
    console.log(`[debug][profile] ${message}`, data);
  } else {
    console.log(`[debug][profile] ${message}`);
  }
}

function getEventElement(event){
  if(!event) return null;
  const path = typeof event.composedPath === 'function' ? event.composedPath() : null;
  if(path && path.length){
    for(const node of path){
      if(node instanceof Element) return node;
    }
  }
  const target = event.target;
  if(target instanceof Element) return target;
  if(target && target.nodeType === Node.TEXT_NODE) return target.parentElement;
  if(target && target.parentElement) return target.parentElement;
  return null;
}

function closestFromEvent(event, selector, options = {}){
  const start = getEventElement(event);
  if(!start || !selector) return null;
  const match = start.closest(selector);
  if(!match) return null;
  const within = options.within;
  if(within){
    const boundary = typeof within === 'string' ? document.querySelector(within) : within;
    if(boundary instanceof Element && !boundary.contains(match)) return null;
  }
  return match;
}

function showDelegationToast(message){
  if(!DEBUG_UI && !DEBUG_PROFILE) return;
  const existing = document.getElementById('delegationDevToast');
  if(existing){
    existing.textContent = message;
    return;
  }
  const toast = document.createElement('div');
  toast.id = 'delegationDevToast';
  toast.textContent = message;
  toast.style.position = 'fixed';
  toast.style.bottom = '16px';
  toast.style.right = '16px';
  toast.style.zIndex = '9999';
  toast.style.background = 'rgba(0,0,0,0.75)';
  toast.style.color = '#fff';
  toast.style.padding = '8px 12px';
  toast.style.borderRadius = '8px';
  toast.style.fontSize = '12px';
  toast.style.pointerEvents = 'none';
  document.body.appendChild(toast);
  setTimeout(()=>{ toast.remove(); }, 3000);
}

function safeOn(type, handler, meta = {}){
  return function(event){
    try{
      handler(event);
    }catch(err){
      const detail = {
        type,
        action: meta.action || meta.selector || 'unknown',
        stack: err?.stack || String(err)
      };
      console.error('[delegation] handler error', detail);
      showDelegationToast(`[delegation] ${type} error`);
    }
  };
}

const firebaseConfig = window.firebaseConfig || {};
const firebaseConfigValid = !!firebaseConfig?.apiKey;
let firebaseEnabled = false;

    const ADMIN_USERS = ['BattleNeBody'];
    function applyAdminFlag(profile){
      if(!profile) return profile;
      return { ...profile, isAdmin: ADMIN_USERS.includes(profile.username) };
    }
    function adminStatusChanged(originalProfile, updatedProfile){
      if(!updatedProfile) return false;
      const previous = originalProfile?.isAdmin ?? false;
      return previous !== (updatedProfile.isAdmin ?? false) || typeof originalProfile?.isAdmin === 'undefined';
    }
    async function persistAdminFlagIfNeeded(originalProfile, updatedProfile){
      if(!updatedProfile) return;
      if(adminStatusChanged(originalProfile, updatedProfile)){
        await saveUserProfileToBackend(updatedProfile);
      }
    }

function applyBrandingCopy(){
  const loading = document.querySelector('[data-brand="loading"]');
  if(loading) loading.textContent = `Loading ${BRAND.APP_NAME}...`;
  const helpTitle = document.querySelector('[data-brand="help-title"]');
  if(helpTitle) helpTitle.textContent = `${BRAND.APP_NAME} Help`;
  const helpIntro = document.querySelector('[data-brand="help-intro"]');
  if(helpIntro) helpIntro.textContent = `A complete, beginner-to-pro guide for every tool in ${BRAND.APP_NAME}. Open this help anytime with the â“ button in the header.`;
  const camelotAnchor = document.querySelector('[data-brand="help-anchor-camelot"]');
  if(camelotAnchor) camelotAnchor.textContent = `How ${BRAND.APP_NAME} uses Camelot`;
  const priorityDesc = document.querySelector('[data-brand="priority-desc"]');
  if(priorityDesc) priorityDesc.textContent = `${BRAND.APP_NAME} always calculates a blended compatibility score (Key â†’ BPM â†’ Genre). Priority modes only decide how ties are broken, not the overall score.`;
  const camelotHeading = document.querySelector('[data-brand="camelot-heading"]');
  if(camelotHeading) camelotHeading.textContent = `How ${BRAND.APP_NAME} Uses Camelot`;
}

let delegationSelfTested = false;
function runDelegationSelfTest(){
  if(delegationSelfTested || (!DEBUG_UI && !DEBUG_PROFILE)) return;
  delegationSelfTested = true;
  const helpersReady = typeof getEventElement === 'function' && typeof closestFromEvent === 'function' && typeof safeOn === 'function';
  console.log('[delegation] hardened listeners active', { helpersReady, documentClick: dataActionDelegatesBound === true });
}

applyBrandingCopy();

window.addEventListener('error', (event) => {
  logEvent('error', {
    message: event?.message || 'Unknown error',
    stack: event?.error?.stack || null,
    view,
    firebaseEnabled,
    online: navigator.onLine
  });
  notifyProfileScriptError(event?.message || 'Profile scripts failed. Open console.', event?.error || event);
});
window.addEventListener('unhandledrejection', (event) => {
  logEvent('unhandledrejection', {
    message: event?.reason?.message || event?.reason || 'Unknown rejection',
    stack: event?.reason?.stack || null,
    view,
    firebaseEnabled,
    online: navigator.onLine
  });
  notifyProfileScriptError(event?.reason?.message || 'Profile scripts failed. Open console.', event?.reason || event);
});

function buildExportFilename(username = 'profile'){
  const safeName = (username || 'profile').trim() || 'profile';
  return `${BRAND.EXPORT_PREFIX}-${safeName}.json`;
}

let firebaseApp = null, firebaseAuth = null, firestore = null;
let firebaseAuthUnsub = null;
let userProfileUnsub = null;
let authSettledUser = null;
let authProcessing = false;
let authInFlight = false;
let appConfigLoaded = false;
if (firebaseConfigValid && window.firebase?.initializeApp && window.firebase?.auth && window.firebase?.firestore) {
  try {
    firebaseApp = firebase.initializeApp(firebaseConfig);
    firebaseAuth = firebase.auth();
    firestore = firebase.firestore();
    firebaseEnabled = true;
    if(window.profileStore?.setFirestore) window.profileStore.setFirestore(firestore);
    if(window.profileStore?.setFirebase) window.profileStore.setFirebase(firebase);
    firebaseAuth.setPersistence(firebase.auth.Auth.Persistence.LOCAL).catch((err)=>{
      console.warn('Firebase persistence failed', err);
      logEvent('auth_persistence_fail', { message: err?.message, code: err?.code });
    });
    console.log('Firebase initialized');
    logEvent('firebase_init', { projectId: firebaseConfig.projectId });
  } catch (e) {
    console.warn('Firebase init failed', e);
    logEvent('firebase_init_fail', { message: e?.message, code: e?.code });
    firebaseApp = null;
    firebaseAuth = null;
    firestore = null;
    firebaseEnabled = false;
  }
} else {
  logEvent('firebase_disabled', { reason: 'missing config or sdk', firebaseConfigValid });
}

function getAppVersion(){
  return window.appVersion || window.APP_VERSION || firebaseConfig?.appVersion || firebaseConfig?.version || null;
}
function warnIfWhatsNewStale(){
  const host = typeof location !== 'undefined' ? location.hostname : '';
  const isDevHost = host === 'localhost' || host === '127.0.0.1';
  if(!isDevHost) return;
  const appVersion = getAppVersion();
  const items = Array.isArray(window.DEFAULT_WHATS_NEW?.items) ? window.DEFAULT_WHATS_NEW.items : [];
  if(!appVersion || items.length === 0) return;
  const signature = items.map(item => item.id).join('|');
  let previous = {};
  try{
    previous = JSON.parse(localStorage.getItem('whatsNewSignature') || '{}');
  }catch(_){}
  if(previous?.version && previous.version !== appVersion && previous.signature === signature){
    console.warn(`[whats-new] APP_VERSION changed to ${appVersion} but WHATS_NEW looks unchanged.`);
  }
  localStorage.setItem('whatsNewSignature', JSON.stringify({ version: appVersion, signature }));
}
warnIfWhatsNewStale();
let helpContentState = window.DEFAULT_HELP_CONTENT || null;
let whatsNewState = window.DEFAULT_WHATS_NEW || null;
let configLoadPromise = null;
function getFirebaseAnalytics(){
  if(!firebaseEnabled) return null;
  if(typeof firebase?.analytics !== 'function') return null;
  try {
    return firebase.analytics();
  } catch (e) {
    console.warn('Firebase analytics unavailable', e);
    return null;
  }
}
function track(eventName, payload = {}){
  const safePayload = payload && typeof payload === 'object' ? payload : {};
  const analyticsInstance = getFirebaseAnalytics();
  if(analyticsInstance && typeof analyticsInstance.logEvent === 'function'){
    try {
      analyticsInstance.logEvent(eventName, safePayload);
      return;
    } catch (e) {
      console.warn('Analytics logEvent failed', e);
    }
  }
  console.debug('[analytics]', eventName, safePayload);
}


    function normalizeStreamUrlInput(value){
      const trimmed = (value || '').trim();
      if(!trimmed) return '';
      if(/^https?:\/\//i.test(trimmed)) return trimmed;
      if(/^www\./i.test(trimmed)) return `https://${trimmed}`;
      if(/^[\w.-]+\.[a-z]{2,}/i.test(trimmed)) return `https://${trimmed}`;
      return trimmed;
    }
    function isValidStreamUrl(value){
      if(!value) return false;
      try{
        const parsed = new URL(value);
        return ['http:','https:'].includes(parsed.protocol) && !!parsed.hostname;
      }catch(_){
        return false;
      }
    }
    function normalizeLiveProfileFields(profile){
      const streamUrl = normalizeStreamUrlInput(profile?.streamUrl || '');
      const streamUrlValid = isValidStreamUrl(streamUrl);
      const liveStartedAt = streamUrlValid ? (profile?.liveStartedAt || profile?.liveSince || null) : null;
      return {
        streamUrl,
        isLive: streamUrlValid ? profile?.isLive === true : false,
        liveStartedAt
      };
    }
    const RATING_TAGS = ['Vibes', 'Transitions', 'Song Selection', 'Crowd Control', 'FX', 'Mixing'];
    const RATING_MAX_COMMENT = 140;
    const RATING_UPDATE_LIMIT = 3;
    const RATING_WINDOW_MS = 60 * 60 * 1000;

    function normalizeRatingBreakdown(breakdown){
      const base = { 1:0, 2:0, 3:0, 4:0, 5:0 };
      if(!breakdown) return base;
      Object.keys(base).forEach(key=>{
        const val = Number(breakdown[key] ?? breakdown[Number(key)]);
        base[key] = Number.isFinite(val) && val > 0 ? Math.floor(val) : 0;
      });
      return base;
    }

    function computeRatingAggregates(breakdown){
      const ratingBreakdown = normalizeRatingBreakdown(breakdown);
      const ratingCount = Object.values(ratingBreakdown).reduce((sum, val)=> sum + val, 0);
      const totalStars = Object.entries(ratingBreakdown).reduce((sum, [stars, count])=> sum + (Number(stars) * count), 0);
      const avgRating = ratingCount ? Number((totalStars / ratingCount).toFixed(2)) : 0;
      return { avgRating, ratingCount, ratingBreakdown };
    }

    function normalizeRatingFields(profile){
      const ratingBreakdown = normalizeRatingBreakdown(profile?.ratingBreakdown);
      const computed = computeRatingAggregates(ratingBreakdown);
      const avgCandidate = Number(profile?.avgRating);
      const countCandidate = Number(profile?.ratingCount);
      return {
        avgRating: Number.isFinite(avgCandidate) ? avgCandidate : computed.avgRating,
        ratingCount: Number.isFinite(countCandidate) ? countCandidate : computed.ratingCount,
        ratingBreakdown: ratingBreakdown
      };
    }

    const PROFILE_COLLECTION = 'users';
    const LEGACY_PROFILE_COLLECTION = 'profiles';
    const PROFILE_BIO_MAX = 160;
    const PERSONA_STORAGE_KEYS = Object.freeze({
      id: 'profilePersonaId',
      theme: 'profilePersonaTheme',
      seed: 'profilePersonaSeed'
    });
    const PERSONA_THEMES = [
      { id: 'neonPop', label: 'Neon Pop', ring: ['#ff6b9d', '#38bdf8'], background: ['#1e1b4b', '#0f172a'], accent: '#facc15', glow: 'rgba(255,107,157,0.55)', particle: '#fef3c7' },
      { id: 'midnight', label: 'Midnight', ring: ['#0ea5e9', '#6366f1'], background: ['#0f172a', '#111827'], accent: '#38bdf8', glow: 'rgba(56,189,248,0.4)', particle: '#e0f2fe' },
      { id: 'sunset', label: 'Sunset', ring: ['#fb7185', '#f97316'], background: ['#3b0a2a', '#1f2937'], accent: '#facc15', glow: 'rgba(249,115,22,0.4)', particle: '#fde68a' },
      { id: 'mintwave', label: 'Mintwave', ring: ['#22d3ee', '#34d399'], background: ['#0f172a', '#064e3b'], accent: '#a7f3d0', glow: 'rgba(52,211,153,0.4)', particle: '#ccfbf1' },
      { id: 'orbit', label: 'Orbit', ring: ['#60a5fa', '#c084fc'], background: ['#111827', '#312e81'], accent: '#f472b6', glow: 'rgba(192,132,252,0.45)', particle: '#fbcfe8' }
    ];
    const PERSONAS = Object.freeze({
      raver: {
        id: 'raver',
        name: 'Raver',
        energy: 'âš¡',
        render: ({ theme }) => `
          <circle cx="128" cy="86" r="22" fill="${theme.accent}" opacity="0.9"/>
          <path d="M58 128 L96 96" stroke="${theme.accent}" stroke-width="10" stroke-linecap="round"/>
          <path d="M198 128 L160 96" stroke="${theme.accent}" stroke-width="10" stroke-linecap="round"/>
          <path d="M92 188 L128 138 L164 188" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round" opacity="0.9"/>
          <circle cx="68" cy="116" r="6" fill="${theme.particle}"/>
          <circle cx="188" cy="116" r="6" fill="${theme.particle}"/>
        `
      },
      mc: {
        id: 'mc',
        name: 'MC',
        energy: 'ðŸŽ¤',
        render: ({ theme }) => `
          <circle cx="128" cy="90" r="22" fill="${theme.accent}" opacity="0.95"/>
          <rect x="96" y="70" width="64" height="16" rx="8" fill="${theme.ring[0]}" opacity="0.9"/>
          <path d="M92 168 L128 128 L164 168" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/>
          <rect x="178" y="120" width="18" height="40" rx="6" fill="${theme.ring[1]}" opacity="0.9"/>
          <circle cx="187" cy="112" r="10" fill="${theme.accent}"/>
        `
      },
      breaker: {
        id: 'breaker',
        name: 'Breaker',
        energy: 'ðŸ”¥',
        render: ({ theme }) => `
          <circle cx="110" cy="92" r="18" fill="${theme.accent}" opacity="0.95"/>
          <path d="M70 172 L122 132 L170 154" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M156 104 L182 70" stroke="${theme.ring[1]}" stroke-width="12" stroke-linecap="round"/>
          <path d="M84 130 L52 92" stroke="${theme.ring[0]}" stroke-width="12" stroke-linecap="round"/>
        `
      },
      turntablist: {
        id: 'turntablist',
        name: 'Turntablist',
        energy: 'ðŸŽ§',
        render: ({ theme }) => `
          <circle cx="128" cy="78" r="20" fill="${theme.accent}" opacity="0.95"/>
          <rect x="64" y="120" width="128" height="48" rx="14" fill="rgba(255,255,255,0.12)" stroke="${theme.ring[1]}" stroke-width="4"/>
          <circle cx="104" cy="144" r="16" fill="${theme.ring[0]}" opacity="0.9"/>
          <circle cx="152" cy="144" r="12" fill="${theme.ring[1]}" opacity="0.9"/>
          <path d="M110 178 L128 148 L146 178" stroke="white" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/>
        `
      },
      producer: {
        id: 'producer',
        name: 'Producer',
        energy: 'ðŸ’»',
        render: ({ theme }) => `
          <circle cx="128" cy="80" r="20" fill="${theme.accent}" opacity="0.95"/>
          <rect x="70" y="120" width="116" height="54" rx="10" fill="rgba(255,255,255,0.1)" stroke="${theme.ring[0]}" stroke-width="4"/>
          <path d="M86 148 L106 138 L126 146 L146 132 L170 140" stroke="${theme.accent}" stroke-width="6" stroke-linecap="round"/>
        `
      },
      rocker: {
        id: 'rocker',
        name: 'Rock Shredder',
        energy: 'ðŸŽ¸',
        render: ({ theme }) => `
          <circle cx="108" cy="86" r="20" fill="${theme.accent}" opacity="0.95"/>
          <path d="M88 160 L132 118 L176 170" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/>
          <circle cx="188" cy="178" r="14" fill="${theme.ring[1]}" opacity="0.9"/>
          <rect x="150" y="146" width="48" height="10" rx="5" fill="${theme.ring[0]}"/>
        `
      },
      disco: {
        id: 'disco',
        name: 'Disco Diva',
        energy: 'âœ¨',
        render: ({ theme }) => `
          <circle cx="128" cy="78" r="20" fill="${theme.accent}" opacity="0.95"/>
          <circle cx="128" cy="122" r="22" fill="rgba(255,255,255,0.18)" stroke="${theme.ring[0]}" stroke-width="4"/>
          <path d="M90 176 L128 136 L166 176" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/>
          <circle cx="112" cy="118" r="6" fill="${theme.particle}"/>
          <circle cx="144" cy="126" r="6" fill="${theme.particle}"/>
        `
      },
      cyber: {
        id: 'cyber',
        name: 'Cyber DJ',
        energy: 'ðŸ›¸',
        render: ({ theme }) => `
          <circle cx="128" cy="88" r="22" fill="${theme.accent}" opacity="0.95"/>
          <rect x="90" y="78" width="76" height="18" rx="9" fill="${theme.ring[1]}" opacity="0.9"/>
          <path d="M88 170 L128 130 L168 170" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M104 108 L152 108" stroke="${theme.particle}" stroke-width="4" stroke-linecap="round"/>
        `
      },
      punk: {
        id: 'punk',
        name: 'Punk',
        energy: 'ðŸ”Š',
        render: ({ theme }) => `
          <circle cx="128" cy="86" r="20" fill="${theme.accent}" opacity="0.95"/>
          <path d="M112 64 L128 40 L144 64" stroke="${theme.ring[0]}" stroke-width="8" stroke-linecap="round"/>
          <rect x="70" y="130" width="116" height="46" rx="12" fill="rgba(255,255,255,0.12)" stroke="${theme.ring[1]}" stroke-width="4"/>
          <circle cx="102" cy="152" r="10" fill="${theme.accent}"/>
          <circle cx="154" cy="152" r="10" fill="${theme.accent}"/>
        `
      },
      kpop: {
        id: 'kpop',
        name: 'K-Pop',
        energy: 'â­',
        render: ({ theme }) => `
          <circle cx="128" cy="84" r="20" fill="${theme.accent}" opacity="0.95"/>
          <path d="M94 178 L128 136 L162 178" stroke="white" stroke-width="14" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M70 118 L90 88" stroke="${theme.ring[0]}" stroke-width="8" stroke-linecap="round"/>
          <path d="M186 118 L166 88" stroke="${theme.ring[1]}" stroke-width="8" stroke-linecap="round"/>
          <circle cx="70" cy="124" r="6" fill="${theme.particle}"/>
          <circle cx="186" cy="124" r="6" fill="${theme.particle}"/>
        `
      }
    });
    const PERSONA_LIST = Object.values(PERSONAS);
    // Persona QA checklist:
    // 1) Profile â†’ pick a persona â†’ refresh â†’ selection persists.
    // 2) Change theme â†’ ring/background update instantly.
    // 3) Randomize seed â†’ sparkles/accents shift.
    // 4) Go offline â†’ persona picker still works with no errors.
    const THEME_ACCENTS = [
      { id: 'pink-pop', label: 'Pink Pop', color: '#ff6b9d' },
      { id: 'electric-blue', label: 'Electric Blue', color: '#38bdf8' },
      { id: 'neon-violet', label: 'Neon Violet', color: '#a855f7' },
      { id: 'sunset-gold', label: 'Sunset Gold', color: '#facc15' },
      { id: 'mint-laser', label: 'Mint Laser', color: '#34d399' }
    ];

    function getProfileCollection(){
      return firestore ? firestore.collection(PROFILE_COLLECTION) : null;
    }

    function getLegacyProfileCollection(){
      return firestore ? firestore.collection(LEGACY_PROFILE_COLLECTION) : null;
    }

    function normalizeUsernameLower(value){
      return (value || '').trim().toLowerCase();
    }

    function buildSearchTokens(value){
      const normalized = normalizeUsernameLower(value);
      const maxTokens = Math.min(20, normalized.length);
      const tokens = [];
      for(let i=1; i<=maxTokens; i+=1){
        tokens.push(normalized.slice(0, i));
      }
      return tokens;
    }

    function hexToRgba(hex, alpha = 0.45){
      const clean = (hex || '').replace('#','');
      const normalized = clean.length === 3
        ? clean.split('').map(ch => ch + ch).join('')
        : clean;
      if(normalized.length !== 6) return `rgba(255,107,157,${alpha})`;
      const r = parseInt(normalized.slice(0,2), 16);
      const g = parseInt(normalized.slice(2,4), 16);
      const b = parseInt(normalized.slice(4,6), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function resolveThemeAccent(accent){
      const preset = THEME_ACCENTS.find(item => item.id === accent);
      if(preset) return preset.color;
      if(/^#([0-9a-f]{3}){1,2}$/i.test(accent || '')) return accent;
      return THEME_ACCENTS[0].color;
    }

    function createSeededRandom(seed){
      let hash = 0;
      String(seed || '').split('').forEach((char)=>{
        hash = ((hash << 5) - hash) + char.charCodeAt(0);
        hash |= 0;
      });
      let value = Math.abs(hash) || 1;
      return () => {
        value = (value * 9301 + 49297) % 233280;
        return value / 233280;
      };
    }

    function getStoredPersona(){
      return {
        personaId: localStorage.getItem(PERSONA_STORAGE_KEYS.id),
        personaTheme: localStorage.getItem(PERSONA_STORAGE_KEYS.theme),
        personaSeed: localStorage.getItem(PERSONA_STORAGE_KEYS.seed)
      };
    }

    function persistPersonaToStorage(persona){
      if(!persona) return;
      if(persona.personaId) localStorage.setItem(PERSONA_STORAGE_KEYS.id, persona.personaId);
      if(persona.personaTheme) localStorage.setItem(PERSONA_STORAGE_KEYS.theme, persona.personaTheme);
      if(persona.personaSeed) localStorage.setItem(PERSONA_STORAGE_KEYS.seed, persona.personaSeed);
    }

    function ensurePersona(profile){
      const fallbackSeed = profile?.username || profile?.uid || localDeviceId || Math.random().toString(36).slice(2, 8);
      const isSelf = !!(profile && currentUser && ((profile.uid && profile.uid === currentUser.uid) || (profile.username && profile.username === currentUser.username)));
      const stored = isSelf || !profile ? getStoredPersona() : {};
      const personaId = profile?.personaId || stored.personaId || 'turntablist';
      const personaTheme = profile?.personaTheme || stored.personaTheme || 'neonPop';
      const personaSeed = profile?.personaSeed || stored.personaSeed || fallbackSeed;
      return { personaId, personaTheme, personaSeed };
    }

    function getPersonaTheme(themeId){
      return PERSONA_THEMES.find(item => item.id === themeId) || PERSONA_THEMES[0];
    }

    function renderPersonaSVG({ personaId, themeId, seed, size = 96 }){
      const persona = PERSONAS[personaId] || PERSONAS.turntablist;
      const theme = getPersonaTheme(themeId);
      const random = createSeededRandom(`${seed}-${personaId}-${themeId}`);
      const unique = Math.abs(Math.floor(random() * 100000));
      const bgId = `persona-bg-${personaId}-${unique}`;
      const ringId = `persona-ring-${personaId}-${unique}`;
      const accentId = `persona-accent-${personaId}-${unique}`;
      const sparkles = Array.from({ length: 5 }).map(() => {
        const cx = 48 + Math.floor(random() * 160);
        const cy = 48 + Math.floor(random() * 160);
        const r = 3 + Math.floor(random() * 5);
        return `<circle class="persona-spark" cx="${cx}" cy="${cy}" r="${r}" fill="${theme.particle}" opacity="0.7"/>`;
      }).join('');
      return `
        <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 256 256" role="img" aria-label="${persona.name} persona">
          <defs>
            <linearGradient id="${bgId}" x1="0" x2="1" y1="0" y2="1">
              <stop offset="0%" stop-color="${theme.background[0]}"/>
              <stop offset="100%" stop-color="${theme.background[1]}"/>
            </linearGradient>
            <linearGradient id="${ringId}" x1="0" x2="1" y1="0" y2="1">
              <stop offset="0%" stop-color="${theme.ring[0]}"/>
              <stop offset="100%" stop-color="${theme.ring[1]}"/>
            </linearGradient>
            <radialGradient id="${accentId}" cx="0.5" cy="0.4" r="0.6">
              <stop offset="0%" stop-color="${theme.accent}"/>
              <stop offset="100%" stop-color="rgba(255,255,255,0)"/>
            </radialGradient>
          </defs>
          <rect width="256" height="256" rx="56" fill="url(#${bgId})"/>
          <circle cx="128" cy="128" r="102" fill="url(#${accentId})" opacity="0.45"/>
          ${sparkles}
          <circle class="persona-ring" cx="128" cy="128" r="108" fill="none" stroke="url(#${ringId})" stroke-width="10" opacity="0.9"/>
          ${persona.render({ theme })}
        </svg>
      `.trim();
    }

    function renderPersonaBadge(profile, size = 48, extraClass = ''){
      const persona = ensurePersona(profile);
      const personaSvg = renderPersonaSVG({
        personaId: persona.personaId,
        themeId: persona.personaTheme,
        seed: persona.personaSeed,
        size
      });
      const energy = (PERSONAS[persona.personaId] || PERSONAS.turntablist).energy || 'âš¡';
      const label = escapeHtml(profile?.djName || profile?.username || 'DJ');
      return `
        <div class="persona-badge ${extraClass}" style="width:${size}px;height:${size}px;" aria-label="${label} persona">
          ${personaSvg}
          <span class="persona-energy">${energy}</span>
        </div>
      `.trim();
    }

    // Backend save/load wrappers (Firestore or localStorage)
    function normalizeProfileShape(profile, fallbackId){
      if(!profile) return null;
      const ownedFromMap = Object.keys(profile.ownedMap || {});
      const ownedArray = Array.isArray(profile.ownedTracks) ? profile.ownedTracks : ownedFromMap;
      const username = profile.username || fallbackId || profile.uid || '';
      const djName = profile.djName || username;
      const email = profile.email || profile.mail || '';
      const oauth = profile.oauth || {};
      const isAdmin = profile.isAdmin === true;
      const normalizedSetlist = normalizeSetlistIds(profile.setlist || profile.setlistIds || profile.setlists);
      const liveDefaults = normalizeLiveProfileFields(profile);
      const ratingDefaults = normalizeRatingFields(profile);
      const persona = ensurePersona(profile);
      const bio = (profile.bio || '').slice(0, PROFILE_BIO_MAX);
      const themeAccent = profile.themeAccent || THEME_ACCENTS[0].id;
      const isPublic = profile.isPublic !== false;
      const allowFriendRequests = profile.allowFriendRequests !== false;
      const rulesAccepted = profile.rulesAccepted === true;
      const rulesAcceptedAt = profile.rulesAcceptedAt || null;
      const usernameLower = profile.usernameLower || normalizeUsernameLower(username);
      const djNameLower = profile.djNameLower || normalizeUsernameLower(djName);
      const searchNameLower = profile.searchNameLower || usernameLower;
      const searchTokens = Array.isArray(profile.searchTokens) ? profile.searchTokens : buildSearchTokens(usernameLower);
      const { setlists, setlistIds, ...profileRest } = profile;
      return {
        ...profileRest,
        ...liveDefaults,
        ...ratingDefaults,
        username,
        djName,
        email,
        ownedTracks: ownedArray,
        setlist: normalizedSetlist,
        oauth,
        isAdmin,
        bio,
        themeAccent,
        personaId: persona.personaId,
        personaTheme: persona.personaTheme,
        personaSeed: persona.personaSeed,
        isPublic,
        allowFriendRequests,
        rulesAccepted,
        rulesAcceptedAt,
        usernameLower,
        djNameLower,
        searchNameLower,
        searchTokens
      };
    }
    function buildOwnedMap(ids){
      const map = {};
      (ids||[]).forEach(id=>{ map[id] = true; });
      return map;
    }
    async function saveUserProfileToBackend(profile) {
      if (!profile) return;
      const firebaseUser = firebaseAuth?.currentUser;
      const profileKey = profile.uid || firebaseUser?.uid;
      const setlistItems = profile.setlist || [];
      const serverTimestamp = firebase?.firestore?.FieldValue?.serverTimestamp;
      const usernameLower = normalizeUsernameLower(profile.username || profileKey);
      const djNameLower = normalizeUsernameLower(profile.djName || profile.username || profileKey);
      const searchNameLower = profile.searchNameLower || usernameLower;
      const persona = ensurePersona(profile);
      const { setlists, setlistIds, ownedTracks, ownedMap, ...profileRest } = profile;
      const payload = {
        ...profileRest,
        uid: profileKey,
        username: profile.username || profileKey,
        djName: profile.djName || profile.username || profileKey,
        usernameLower,
        djNameLower,
        searchNameLower,
        searchTokens: Array.isArray(profile.searchTokens) ? profile.searchTokens : buildSearchTokens(usernameLower),
        bio: (profile.bio || '').slice(0, PROFILE_BIO_MAX),
        themeAccent: profile.themeAccent || THEME_ACCENTS[0].id,
        personaId: persona.personaId,
        personaTheme: persona.personaTheme,
        personaSeed: persona.personaSeed,
        isPublic: profile.isPublic !== false,
        allowFriendRequests: profile.allowFriendRequests !== false,
        rulesAccepted: profile.rulesAccepted === true,
        rulesAcceptedAt: profile.rulesAcceptedAt || null,
        email: profile.email || firebaseUser?.email || '',
        setlist: setlistItems,
        updatedAt: serverTimestamp ? serverTimestamp() : new Date().toISOString()
      };
      let backendOk = true;
      if (firestore && firebaseUser && profileKey) {
        try {
          const collection = getProfileCollection();
          if(collection){
            await collection.doc(profileKey).set(payload, { merge: true });
          }
        } catch (e) {
          console.warn('Firestore save failed', e);
          backendOk = false;
        }
      }
      const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');
      if (payload.username) profiles[payload.username] = payload;
      if (profileKey) profiles[profileKey] = payload;
      localStorage.setItem('userProfiles', JSON.stringify(profiles));
      return backendOk;
    }
    async function loadUserProfileFromBackend(identifier) {
      if (!identifier && !firebaseAuth?.currentUser) return null;
      const firebaseUser = firebaseAuth?.currentUser;
      const lookupKey = identifier || firebaseUser?.uid;
      const isLikelyUid = typeof lookupKey === 'string' && (lookupKey.startsWith('local:') || lookupKey.length >= 20);
      if (firestore && lookupKey) {
        try {
          const primaryCollection = getProfileCollection();
          const legacyCollection = getLegacyProfileCollection();
          if(primaryCollection && isLikelyUid){
            const doc = await primaryCollection.doc(lookupKey).get();
            if (doc.exists) return normalizeProfileShape(doc.data(), lookupKey);
          }
          if(legacyCollection && isLikelyUid){
            const legacyDoc = await legacyCollection.doc(lookupKey).get();
            if (legacyDoc.exists) return normalizeProfileShape(legacyDoc.data(), lookupKey);
          }
          if(identifier && primaryCollection){
            const query = await primaryCollection.where('usernameLower','==', normalizeUsernameLower(identifier)).limit(1).get();
            const match = query.docs[0];
            if(match?.exists) return normalizeProfileShape({ ...match.data(), uid: match.id }, match.id);
          }
        } catch (e) { console.warn('Firestore load failed', e); }
      }
      const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');
      if (lookupKey && profiles[lookupKey]) return normalizeProfileShape(profiles[lookupKey], lookupKey);
      if (firebaseUser?.uid && profiles[firebaseUser.uid]) return normalizeProfileShape(profiles[firebaseUser.uid], firebaseUser.uid);
      return identifier ? normalizeProfileShape(profiles[identifier], identifier) || null : null;
    }

    function getStreamPlatformInfo(streamUrl){
      if(!streamUrl) return { label: 'Other', icon: 'ðŸŒ' };
      try{
        const host = new URL(streamUrl).hostname.replace('www.','').toLowerCase();
        if(host.includes('twitch')) return { label: 'Twitch', icon: 'ðŸŸ£' };
        if(host.includes('youtube') || host.includes('youtu.be')) return { label: 'YouTube', icon: 'ðŸ”´' };
        if(host.includes('kick')) return { label: 'Kick', icon: 'ðŸŸ¢' };
        if(host.includes('tiktok')) return { label: 'TikTok', icon: 'ðŸŽµ' };
      }catch(_){}
      return { label: 'Other', icon: 'ðŸŒ' };
    }

    function getProfileRatingDisplay(profile){
      const ratingCount = Number(profile?.ratingCount) || 0;
      const avgRating = Number(profile?.avgRating) || 0;
      const roundedStars = Math.round(avgRating);
      const stars = Array.from({ length: 5 }, (_, i)=> i < roundedStars ? 'â˜…' : 'â˜†').join('');
      return { ratingCount, avgRating, stars };
    }

    function renderRatingBreakdownBars(breakdown, ratingCount){
      if(!ratingCount) return '';
      return `<div class="space-y-2">
        ${[5,4,3,2,1].map(star=>{
          const count = breakdown[String(star)] || 0;
          const pct = ratingCount ? Math.round((count / ratingCount) * 100) : 0;
          return `<div class="flex items-center gap-2 text-xs text-gray-300">
            <div class="w-6 text-right">${star}â˜…</div>
            <div class="flex-1 h-2 rounded-full bg-white/10 overflow-hidden">
              <div class="h-full bg-amber-400/80" style="width:${pct}%;"></div>
            </div>
            <div class="w-10 text-right text-gray-400">${count}</div>
          </div>`;
        }).join('')}
      </div>`;
    }

    function getLocalRatings(){
      return JSON.parse(localStorage.getItem('ratings') || '{}');
    }

    function saveLocalRatings(ratings){
      localStorage.setItem('ratings', JSON.stringify(ratings));
    }

    async function getExistingRating(streamerUid, raterUid){
      if(!streamerUid || !raterUid) return null;
      if(firestore){
        try{
          const collection = getProfileCollection();
          if(!collection) return null;
          const doc = await collection.doc(streamerUid).collection('ratings').doc(raterUid).get();
          return doc.exists ? doc.data() : null;
        }catch(err){ console.warn('rating load failed', err); }
      }
      const ratings = getLocalRatings();
      return ratings?.[streamerUid]?.[raterUid] || null;
    }

    function updateAggregatesWithRating(profile, previousStars, nextStars){
      const ratingBreakdown = normalizeRatingBreakdown(profile?.ratingBreakdown);
      let ratingCount = Math.max(0, Number(profile?.ratingCount) || 0);
      if(previousStars){
        const prevKey = String(previousStars);
        ratingBreakdown[prevKey] = Math.max(0, (ratingBreakdown[prevKey] || 0) - 1);
      } else {
        ratingCount += 1;
      }
      const nextKey = String(nextStars);
      ratingBreakdown[nextKey] = (ratingBreakdown[nextKey] || 0) + 1;
      const computed = computeRatingAggregates(ratingBreakdown);
      ratingCount = Math.max(ratingCount, computed.ratingCount);
      return { avgRating: computed.avgRating, ratingCount, ratingBreakdown };
    }

    function checkRatingUpdateLimit(streamerUid, raterUid){
      const now = Date.now();
      const logs = JSON.parse(localStorage.getItem('ratingUpdateLog') || '{}');
      const streamerLog = logs[streamerUid] || {};
      const updates = (streamerLog[raterUid] || []).filter(ts => now - ts < RATING_WINDOW_MS);
      if(updates.length >= RATING_UPDATE_LIMIT){
        const oldest = updates[0];
        return { allowed: false, retryAt: oldest + RATING_WINDOW_MS };
      }
      return { allowed: true, updates, logs };
    }

    function recordRatingUpdate(streamerUid, raterUid, updates, logs){
      const now = Date.now();
      const nextUpdates = [...updates, now];
      const streamerLog = logs[streamerUid] || {};
      streamerLog[raterUid] = nextUpdates;
      logs[streamerUid] = streamerLog;
      localStorage.setItem('ratingUpdateLog', JSON.stringify(logs));
    }

    async function getLiveUsers(){
      if(firestore){
        try{
          const collection = getProfileCollection();
          if(!collection) return [];
          const snap = await collection
            .where('isLive','==',true)
            .orderBy('liveStartedAt','desc')
            .get();
          return snap.docs
            .map(doc=> normalizeProfileShape({ ...doc.data(), uid: doc.id }, doc.id))
            .filter(profile=> isValidStreamUrl(profile.streamUrl));
        }catch(err){
          console.warn('live users query failed', err);
        }
      }
      const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');
      const unique = {};
      Object.values(profiles)
        .map(profile=> normalizeProfileShape(profile, profile?.username || profile?.uid || ''))
        .filter(profile=> profile?.isLive && isValidStreamUrl(profile.streamUrl))
        .forEach(profile=>{
          const key = profile?.username || profile?.uid;
          if(key && !unique[key]) unique[key] = profile;
        });
      return Object.values(unique)
        .sort((a,b)=> new Date(b.liveStartedAt || 0) - new Date(a.liveStartedAt || 0));
    }

    // ---------------------------- Data ------------------------------
    const camelotColors = {
      '1A':'#FF6B9D','1B':'#FF8FAB','2A':'#FFA07A','2B':'#FFB699','3A':'#FFD700','3B':'#FFE55C',
      '4A':'#98D8C8','4B':'#7FD8BE','5A':'#6BCB77','5B':'#8FD89F','6A':'#4D96FF','6B':'#6FB1FF',
      '7A':'#9D4EDD','7B':'#B877FF','8A':'#E84A5F','8B':'#FF6B81','9A':'#00D9FF','9B':'#4DFFFF',
      '10A':'#FFA400','10B':'#FFBB5C','11A':'#FE6D73','11B':'#FF8C94','12A':'#A8E6CF','12B':'#C1F0DD'
    };
    const knownCorrections = [
      { id: 'dont_fear_the_reaper', expectedCamelot: '8A' },
    ];
    const keyToCamelot = { 'C':'8B','Am':'8A','A Minor':'8A','C Major':'8B','G':'9B','Em':'9A','E Minor':'9A','G Major':'9B','D':'10B','Bm':'10A','B Minor':'10A','D Major':'10B','A':'11B','F#m':'11A','F# Minor':'11A','A Major':'11B','E':'12B','C#m':'12A','C# Minor':'12A','E Major':'12B','B':'1B','G#m':'1A','G# Minor':'1A','B Major':'1B','F#':'2B','D#m':'2A','D# Minor':'2A','F# Major':'2B','Db':'3B','Bbm':'3A','Bb Minor':'3A','Db Major':'3B','Ab':'4B','Fm':'4A','F Minor':'4A','Ab Major':'4B','Eb':'5B','Cm':'5A','C Minor':'5A','Eb Major':'5B','Bb':'6B','Gm':'6A','G Minor':'6A','Bb Major':'6B','F':'7B','Dm':'7A','D Minor':'7A','F Major':'7B' };

    const genreMap = {
      'Rock': ['foo fighters','nirvana','pearl jam','soundgarden','alice in chains','red hot chili peppers','radiohead','muse','queens of the stone age','rage against the machine'],
      'Classic Rock': ['beatles','rolling stones','led zeppelin','pink floyd','queen','the who','aerosmith'],
      'Alternative': ['green day','blink-182','sum 41','my chemical romance','fall out boy','arctic monkeys','the strokes','the killers'],
      'Punk': ['ramones','sex pistols','the clash'],
      'Metal': ['metallica','megadeth','slayer','anthrax','iron maiden'],
      'Pop': ['taylor swift','ariana grande','billie eilish','dua lipa','lady gaga','katy perry'],
      'Hip-Hop': ['eminem','dr. dre','snoop dogg','2pac','notorious b.i.g','jay-z','nas','kanye west','kendrick lamar','drake'],
      'R&B': ['the weeknd','bruno mars','usher','beyonce','rihanna'],
      'Electronic': ['daft punk','deadmau5','skrillex','diplo','zedd','avicii','calvin harris'],
      'Indie': ['vampire weekend','tame impala','mgmt','arctic monkeys','the strokes'],
      'Country': ['johnny cash','garth brooks','shania twain','tim mcgraw'],
      'Disco/Funk': ['bee gees','donna summer','chic','earth wind & fire','bruno mars'],
      'Blues': ['bb king','muddy waters','howlin wolf'],
      'Jazz': ['miles davis','john coltrane'],
      'Reggae': ['bob marley'],
      'Latin': ['shakira','ricky martin','enrique iglesias'],
      'Soul': ['aretha franklin','otis redding','sam cooke']
    };

    // -------------------------- State -----------------------------
    let currentUser = null;
    let songsLoaded = false;
    let userKey = null;
    let localDeviceId = localStorage.getItem('localDeviceId') || null;
    let songs = [];
    let songsById = {};
    let draftProfile = null;
    let ownedTracks = [];
    let ownedLibraryState = { phase: 'idle', source: 'none', message: '' };
    let ownedLibraryRestoring = false;
    let ownedLibraryPendingWrite = null;
    let selectedSong = null;
    let sortMode = 'bpm';
    let previewSong = null;
    let setlist = [];
    let searchTerm = '';
    let view = 'browser';
    let showOwnedOnly = false;
    let showMixableOnly = false;
    let selectedGenre = 'All';
    let bandMembers = [];
    let viewingProfile = null;
    let profileOwnedSearch = '';
    let friendSearchTerm = '';
    let socialFriendSearchTerm = '';
    let socialFriendSearchDebounce = null;
    let socialFriendSearchResults = [];
    let socialFriendSearchLoading = false;
    let socialFriendSearchError = '';
    let socialFriendSearchNotice = '';
    let socialFriendSearchNoticeTone = 'info';
    let socialFriendSearchQuery = '';
    let friendRequestsIncoming = [];
    let friendRequestsOutgoing = [];
    let friendsList = [];
    let friendsLoading = false;
    let friendsLoadedAt = 0;
    let friendsError = '';
    let friendLookupError = '';
    let friendLookupResults = [];
    let profileOwnedPagerOwnerKey = '';
    let liveNowUsers = [];
    let liveNowLoading = false;
    let liveNowLoadedAt = 0;
    let liveNowError = '';
    let ratingDraft = { stars: 0, tags: [], comment: '', hasExisting: false };
    let ratingLoadedFor = '';
    let ratingLoading = false;
    let ratingSubmitting = false;
    let ratingStatusMessage = '';
    let ratingStatusTone = 'info';
    let genreOverrides = {};
    let sandboxTracks = [];
    let sandboxIds = [];
    let helpTab = 'basic';
    let helpScroll = { basic: 0, advanced: 0 };
    let helpOpenedAt = null;
    let helpOpenTarget = 'none';
    let helpOpenSource = 'other';
    let helpTabTracked = false;
    let profileEditMode = true;
    let profileHandlersBound = false;
    let debugUiBound = false;
    let headerMoreOpen = false;
    let isLowPowerMode = false;
    let isSearchFocused = false;
    let searchDebounceTimer = null;
    let searchDebouncePending = false;
    let trackLoadState = { status: 'idle', loaded: 0, total: 0, message: '' };
    let trackLoadNotice = '';
    let loadSongsStartTime = 0;
    let firstListRenderLogged = false;
    let maxMobileCardsRendered = 0;
    let maxCardsLogged = false;
    let listRenderCount = 0;
    let songListRenderScheduled = false;
    let songListRenderReason = '';
    let selectedSongCriteria = null;
    let lastFilteredCount = 0;
    let mobileListObserver = null;
    let mixableInlineNotice = '';
    let mixableInlineTimer = null;
    let matchHintMessage = '';
    let quickStartState = { open: false, step: 0, preset: null };
    let stickyCtaDismissed = localStorage.getItem('jamMixer.stickyCtaDismissed') === 'true';
    let quickStartDone = localStorage.getItem('jamMixer.quickStartDone') === 'true';
    let quickStartPrompted = false;
    let quickStartDelegatesBound = false;
    let justEnteredProfile = false;
    let mobileWindowState = { start: 0, count: 40 };
    const TOUR_VERSION = 1;
    const TOUR_STORAGE_KEY = 'tour_done_v1';
    const TOUR_STEPS = [
      { id: 'browse', selector: '#searchInput', title: 'Browse Tracks', copy: 'Scroll or search to find songs you want to mix.', route: 'browser', routeLabel: 'Go to Browse' },
      { id: 'setlist', selector: '#setlistBtn', title: 'Build Your Setlist', copy: 'Tap a track to add it, then open Setlist to review your picks.', route: 'browser' },
      { id: 'go-live', selector: '#profileStreamUrl', title: 'Go Live (Optional)', copy: 'Add your stream link, then turn on LIVE. The green pill opens your stream.', route: 'profile', routeLabel: 'Go to Profile' }
    ];
    const tourState = {
      isOpen: false,
      stepIndex: 0,
      steps: TOUR_STEPS,
      source: 'auto',
      lastFocused: null
    };
    const PAGE_SIZE_OPTIONS = [12,24,48,96];
    const PAGE_SIZE_KEY = 'jamMixer.pageSize';
    const CURRENT_PAGE_KEY = 'jamMixer.currentPage';
    const DEFAULT_PAGE_SIZE = 24;
    const MOBILE_PAGE_CHUNK = 40;
    const MOBILE_MAX_CARDS = 80;
    const MOBILE_BREAKPOINT = 768;
    const reducedMotionQuery = window.matchMedia ? window.matchMedia('(prefers-reduced-motion: reduce)') : null;
    const mobileViewportQuery = window.matchMedia ? window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`) : null;
    let friendPanelTab = 'friends';
    let mainPager = null;
    let profileOwnedPager = null;
    let priorityStrength = 'medium';
    let profileSyncState = { syncing: false, message: '' };
    let profileSyncTimeout = null;
    let keyMatchMode = (localStorage.getItem('jamMixer.keyMatchMode') || 'camelot') === 'semitone' ? 'semitone' : 'camelot';
    let maxSemitoneRange = Math.min(6, Math.max(1, parseInt(localStorage.getItem('jamMixer.maxSemitoneRange') || '6', 10) || 6));
    let includeOppositeMode = localStorage.getItem('jamMixer.includeOppositeMode');
    includeOppositeMode = includeOppositeMode === null ? true : includeOppositeMode === 'true';
    function applyPreferencesFromProfile(profile){
      const prefs = profile?.preferences || {};
      if(prefs.keyMatchMode){ keyMatchMode = prefs.keyMatchMode === 'semitone' ? 'semitone' : 'camelot'; }
      if(Number.isFinite(prefs.maxSemitoneRange)){ maxSemitoneRange = Math.min(6, Math.max(1, Number(prefs.maxSemitoneRange))); }
      if(typeof prefs.includeOppositeMode === 'boolean'){ includeOppositeMode = prefs.includeOppositeMode; }
      if(['low','medium','high'].includes(prefs.priorityStrength)){ priorityStrength = prefs.priorityStrength; }
      const wasPersisting = isPersistingProfile;
      isPersistingProfile = true;
      persistKeyMatchSettings();
      isPersistingProfile = wasPersisting;
    }
    function syncPreferencesIntoProfile(){
      if(!currentUser) return;
      const prefs = { keyMatchMode, maxSemitoneRange, includeOppositeMode, priorityStrength };
      currentUser.preferences = prefs;
      if(draftProfile) draftProfile.preferences = prefs;
    }
    let preferenceSaveTimeout = null;
    let isPersistingProfile = false;
    function schedulePreferencePersist(){
      if(!currentUser) return;
      clearTimeout(preferenceSaveTimeout);
      preferenceSaveTimeout = setTimeout(()=>{
        if(!currentUser) return;
        persistCurrentUserProfile().catch(err=>console.warn('[profile] preference persistence failed', err));
      }, 300);
    }
    let camelotOverridesStore = { ids: {}, names: {} };
    let bpmOverridesStore = { ids: {}, names: {} };
    let auditSearch = '';
    let auditFilters = { flaggedOnly:false, overriddenOnly:false, invalidCamelot:false, modeMismatch:false, bpmOutlier:false };
    let regressionWarnings = [];
    let adminMenuOpen = false;
    let adminMenuListenersBound = false;
    let isOffline = !navigator.onLine;
    let trackSource = 'network';
    const FEATURE_SIGNIN_STATS = false;
    const communityStats = { totalDjs: 'â€¦' };
    const communityStatGraceTimers = {};
    const COMMUNITY_STAT_GRACE_MS = 3000;
    const COMMUNITY_TOTAL_DJS_CACHE_KEY = 'ffmCommunityTotalDjs';
    const TRACK_DB = { name: 'ffm-track-cache', store: 'tracks' };
    const SAMPLE_TRACKS = [
      { id:'s1', title:'Bad Guy', artist:'Billie Eilish', bpm:135, rawBpm:135, key:'C major', rawKey:'C', rawMode:'major', mode:'major', camelot:'8B', derivedCamelot:'8B', duration:180, albumArt:'', genre:'Pop'},
      { id:'s2', title:'Need You Tonight', artist:'INXS', bpm:115, rawBpm:115, key:'C minor', rawKey:'C', rawMode:'minor', mode:'minor', camelot:'8A', derivedCamelot:'8A', duration:210, albumArt:'', genre:'Rock'},
      { id:'s3', title:'Electric Night', artist:'Daft Sample', bpm:128, rawBpm:128, key:'D major', rawKey:'D', rawMode:'major', mode:'major', camelot:'10B', derivedCamelot:'10B', duration:200, albumArt:'', genre:'Electronic'},
      { id:'s4', title:'Slow Burn', artist:'Indie Star', bpm:95, rawBpm:95, key:'G minor', rawKey:'G', rawMode:'minor', mode:'minor', camelot:'9A', derivedCamelot:'9A', duration:190, albumArt:'', genre:'Indie'},
      { id:'s5', title:'Drop The Bass', artist:'SkrillSample', bpm:142, rawBpm:142, key:'A minor', rawKey:'A', rawMode:'minor', mode:'minor', camelot:'11A', derivedCamelot:'11A', duration:160, albumArt:'', genre:'Electronic'}
    ].map(t=>({ ...t, flags: computeTrackFlags ? computeTrackFlags(t) : {} }));
    const usernamePattern = /^[A-Za-z0-9_]{3,20}$/;
    const profileParam = new URLSearchParams(window.location.search).get('profile');
    const pendingOAuthToast = sessionStorage.getItem('oauthSuccess');
    if(pendingOAuthToast){ sessionStorage.removeItem('oauthSuccess'); setTimeout(()=>alert(pendingOAuthToast), 500); }

    // ---------------------- Admin & identity helpers -----------------------
    function ensureLocalDeviceId(){
      if(!localDeviceId){
        localDeviceId = 'device_' + Math.random().toString(36).slice(2,10);
        localStorage.setItem('localDeviceId', localDeviceId);
      }
      return localDeviceId;
    }
    function computeUserKey(){
      const firebaseUser = firebaseAuth?.currentUser;
      if(firebaseUser?.uid) return firebaseUser.uid;
      if(currentUser?.uid) return currentUser.uid;
      return ensureLocalDeviceId();
    }
    function getNamespacedKey(base){
      const key = computeUserKey();
      userKey = key;
      return `${base}_${key}`;
    }
    const PROFILE_MIGRATION_KEY = 'ffjm_migrated_uid';
    function readLegacyLocalProfile(){
      const legacyOwned = JSON.parse(localStorage.getItem('ownedTracks') || '[]');
      const legacySetlist = JSON.parse(localStorage.getItem('setlist') || '[]');
      const legacySetlistIds = JSON.parse(localStorage.getItem('setlistIds') || '[]');
      const legacyGenre = JSON.parse(localStorage.getItem('genreOverrides') || '{}');
      const setlistSource = legacySetlistIds.length ? legacySetlistIds : legacySetlist;
      return {
        ownedTracks: normalizeOwnedList(legacyOwned),
        setlist: normalizeSetlistIds(setlistSource),
        genreOverrides: legacyGenre
      };
    }
    function loadSandboxState(){
      sandboxIds = JSON.parse(localStorage.getItem(getNamespacedKey('sandboxTrackIds')) || '[]');
    }
    function persistProfileCache(){
      if(!window.profileStore?.writeLocalProfileCache) return;
      window.profileStore.writeLocalProfileCache({
        uid: currentUser?.uid || ensureLocalDeviceId(),
        email: currentUser?.email || '',
        djName: currentUser?.djName || currentUser?.username || '',
        streamUrl: currentUser?.streamUrl || '',
        isLive: currentUser?.isLive === true,
        liveStartedAt: currentUser?.liveStartedAt || currentUser?.liveSince || null,
        setlist,
        genreOverrides,
        bandMembers
      });
    }
    function scheduleProfileCacheSync(){
      clearTimeout(profileSyncTimeout);
      profileSyncTimeout = setTimeout(async ()=>{
        if(currentUser){
          currentUser.setlist = setlist;
          currentUser.genreOverrides = genreOverrides;
          currentUser.bandMembers = bandMembers;
        }
        if(draftProfile){
          draftProfile.setlist = setlist;
          draftProfile.genreOverrides = genreOverrides;
          draftProfile.bandMembers = bandMembers;
        }
        persistProfileCache();
        const uid = firebaseAuth?.currentUser?.uid;
        if(uid && firebaseEnabled && firestore && navigator.onLine){
          try{
            await window.profileStore.writeCloudProfile(uid, {
              uid,
              email: firebaseAuth?.currentUser?.email || currentUser?.email || '',
              djName: currentUser?.djName || currentUser?.username || '',
              streamUrl: currentUser?.streamUrl || '',
              isLive: currentUser?.isLive === true,
              liveStartedAt: currentUser?.liveStartedAt || currentUser?.liveSince || null,
              setlist,
              genreOverrides,
              bandMembers
            });
          }catch(err){
            console.warn('[profile] cloud sync failed', err);
          }
        }
      }, 350);
    }
    function createPaginationState({ pageIndex = 0, pageSize = DEFAULT_PAGE_SIZE } = {}){
      return { pageIndex, pageSize, pageSizeOptions: PAGE_SIZE_OPTIONS };
    }
    function loadPaginationPreferences(pager){
      if(!pager) return;
      const storedSize = parseInt(localStorage.getItem(PAGE_SIZE_KEY) || '', 10);
      if(PAGE_SIZE_OPTIONS.includes(storedSize)) pager.pageSize = storedSize;
      const storedPage = parseInt(sessionStorage.getItem(CURRENT_PAGE_KEY) || '', 10);
      if(Number.isFinite(storedPage)){
        pager.pageIndex = storedPage > 0 ? storedPage - 1 : 0;
      }
    }
    function persistPageSizePreference(pager){
      if(!pager) return;
      localStorage.setItem(PAGE_SIZE_KEY, String(pager.pageSize));
    }
    function persistMainPagerState(){
      if(!mainPager) return;
      persistPageSizePreference(mainPager);
      sessionStorage.setItem(CURRENT_PAGE_KEY, String(mainPager.pageIndex + 1));
    }
    function paginate(list, pageIndex, pageSize){
      const totalItems = list.length;
      const totalPages = totalItems ? Math.ceil(totalItems / pageSize) : 0;
      const safePageIndex = totalPages ? Math.min(Math.max(pageIndex, 0), totalPages - 1) : 0;
      const startIndex = safePageIndex * pageSize;
      const pageItems = totalItems ? list.slice(startIndex, startIndex + pageSize) : [];
      const from = totalItems ? startIndex + 1 : 0;
      const to = totalItems ? Math.min(totalItems, startIndex + pageItems.length) : 0;
      return { pageItems, totalItems, totalPages, from, to, pageIndex: safePageIndex };
    }
    function setPageSize(pager, size){
      if(!pager) return;
      const nextSize = Number(size);
      if(!PAGE_SIZE_OPTIONS.includes(nextSize)) return;
      if(pager.pageSize === nextSize) return;
      pager.pageSize = nextSize;
      pager.pageIndex = 0;
    }
    function nextPage(pager, totalPages){
      if(!pager || totalPages <= 0) return;
      pager.pageIndex = Math.min(pager.pageIndex + 1, totalPages - 1);
    }
    function prevPage(pager){
      if(!pager) return;
      pager.pageIndex = Math.max(pager.pageIndex - 1, 0);
    }
    function resetPage(pager){
      if(!pager) return;
      pager.pageIndex = 0;
    }
    function renderPaginationBar(targetEl, paginationState, callbacks, meta){
      if(!targetEl || !paginationState || !meta) return;
      const { totalItems, totalPages, from, to } = meta;
      const pageIndex = paginationState.pageIndex;
      const isEmpty = totalItems === 0;
      const rangeLabel = isEmpty
        ? 'Showing 0 of 0 tracks'
        : `Showing ${from}â€“${to} of ${totalItems} tracks`;
      const pageLabelCurrent = isEmpty ? 0 : pageIndex + 1;
      const pageLabelTotal = isEmpty ? 0 : totalPages;
      const container = document.createElement('div');
      container.className = 'flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 mt-2 bg-black/30 border border-white/5 rounded-lg px-3 py-3';
      const left = document.createElement('div');
      left.className = 'flex flex-col sm:flex-row sm:items-center gap-2 text-sm text-gray-200';
      left.innerHTML = `<span class="font-semibold text-white">${rangeLabel}</span><span class="text-xs text-gray-400">Page ${pageLabelCurrent} of ${pageLabelTotal}</span>`;
      const middle = document.createElement('div');
      middle.className = 'flex flex-wrap items-center gap-3';
      const label = document.createElement('label');
      label.className = 'flex items-center gap-2 text-sm text-gray-200';
      const labelText = document.createElement('span');
      labelText.textContent = 'Page size';
      const select = document.createElement('select');
      select.className = 'pageSizeSelect bg-white/10 border border-white/10 rounded-lg px-3 py-2 min-h-[44px] text-white';
      select.disabled = isEmpty;
      paginationState.pageSizeOptions.forEach(size=>{
        const opt = document.createElement('option');
        opt.value = String(size);
        opt.textContent = `${size} / page`;
        if(paginationState.pageSize === size) opt.selected = true;
        select.appendChild(opt);
      });
      select.addEventListener('change', (e)=>{
        const target = getEventElement(e);
        if(!target) return;
        const nextSize = Number(target.value);
        if(callbacks?.onPageSizeChange) callbacks.onPageSizeChange(nextSize);
      });
      label.appendChild(labelText);
      label.appendChild(select);
      middle.appendChild(label);
      const controls = document.createElement('div');
      controls.className = 'flex items-center gap-2';
      const prevBtn = document.createElement('button');
      prevBtn.className = `px-4 min-h-[44px] py-2 rounded-lg bg-white/10 border border-white/10 text-sm font-semibold ${pageIndex===0 || isEmpty ? 'opacity-50 cursor-not-allowed' : ''}`;
      prevBtn.textContent = 'Previous';
      prevBtn.disabled = pageIndex === 0 || isEmpty;
      prevBtn.addEventListener('click', ()=>{
        if(callbacks?.onPageChange) callbacks.onPageChange(pageIndex - 1);
      });
      const pageInfo = document.createElement('div');
      pageInfo.className = 'text-sm font-semibold text-white px-2';
      pageInfo.textContent = `Page ${pageLabelCurrent} / ${pageLabelTotal}`;
      const nextBtn = document.createElement('button');
      nextBtn.className = `px-4 min-h-[44px] py-2 rounded-lg bg-white/10 border border-white/10 text-sm font-semibold ${pageIndex >= totalPages - 1 || isEmpty ? 'opacity-50 cursor-not-allowed' : ''}`;
      nextBtn.textContent = 'Next';
      nextBtn.disabled = pageIndex >= totalPages - 1 || isEmpty;
      nextBtn.addEventListener('click', ()=>{
        if(callbacks?.onPageChange) callbacks.onPageChange(pageIndex + 1);
      });
      controls.appendChild(prevBtn);
      controls.appendChild(pageInfo);
      controls.appendChild(nextBtn);
      middle.appendChild(controls);
      container.appendChild(left);
      container.appendChild(middle);
      targetEl.innerHTML = '';
      targetEl.appendChild(container);
    }
    mainPager = createPaginationState();
    profileOwnedPager = createPaginationState();
    loadPaginationPreferences(mainPager);
    profileOwnedPager.pageSize = mainPager.pageSize;
    function cloneProfile(profile){
      if(!profile) return null;
      try { return structuredClone(profile); } catch(_) { return JSON.parse(JSON.stringify(profile)); }
    }
    function refreshDraftProfileFromCurrentUser(){
      if(viewingProfile) return;
      draftProfile = currentUser ? cloneProfile(currentUser) : null;
    }
    function isAdmin(){
      return currentUser?.isAdmin === true;
    }

    function handleAdminMenuOutsideClick(e){
      if(!adminMenuOpen) return;
      const menu = document.getElementById('adminToolsMenu');
      const btn = document.getElementById('adminToolsBtn');
      const target = getEventElement(e);
      const clickInMenu = target ? menu?.contains(target) : false;
      const clickOnBtn = target ? btn?.contains(target) : false;
      if(menu && !clickInMenu && !clickOnBtn){
        toggleAdminTools(false);
      }
    }

    function handleAdminMenuKeydown(e){
      if(e.key === 'Escape'){
        closeHelp();
        if(adminMenuOpen) toggleAdminTools(false);
      }
    }

    function ensureAdminMenuListeners(){
      if(adminMenuListenersBound) return;
      document.addEventListener('click', safeOn('click', handleAdminMenuOutsideClick, { action: 'admin-menu-outside' }));
      document.addEventListener('keydown', safeOn('keydown', handleAdminMenuKeydown, { action: 'admin-menu-keydown' }));
      adminMenuListenersBound = true;
    }

    const toggleAdminTools = (force)=>{
      if(!isAdmin()) return;
      ensureAdminMenuListeners();
      const previous = adminMenuOpen;
      if(force === true) adminMenuOpen = true; else if(force === false) adminMenuOpen = false; else adminMenuOpen = !adminMenuOpen;
      if(adminMenuOpen !== previous){ console.debug('[admin] Admin menu state changed', { previous, next: adminMenuOpen }); }
      render();
      setupEventListeners();
    };

    function openAuditFromMenu(){
      if(!isAdmin()) return alert('Admin only');
      toggleAdminTools(false);
      switchView('audit');
    }

    // ---------------------- Community metrics -------------------
    function startCommunityStatGrace(key){
      clearTimeout(communityStatGraceTimers[key]);
      communityStatGraceTimers[key] = setTimeout(()=>{
        if(communityStats[key] === null || communityStats[key] === 'â€¦'){
          communityStats[key] = 'â€”';
          syncCommunityStatsUI();
        }
      }, COMMUNITY_STAT_GRACE_MS);
    }

    function formatStatValue(value){
      if(value === 'â€”' || value === 'â€¦') return value;
      if(typeof value === 'string') return value;
      if(typeof value === 'number' && !Number.isNaN(value)) return value.toLocaleString();
      return 'â€¦';
    }

    function syncCommunityStatsUI(){
      if(!FEATURE_SIGNIN_STATS) return;
      const mapping = {
        totalDjs: communityStats.totalDjs,
      };
      Object.entries(mapping).forEach(([key,val])=>{
        const el = document.querySelector(`[data-community-stat="${key}"]`);
        if(el) el.textContent = formatStatValue(val);
      });
    }

    function setCommunityStat(key, value){
      if(communityStats[key] === value) { syncCommunityStatsUI(); return; }
      communityStats[key] = value;
      if(value !== null && value !== 'â€¦'){
        clearTimeout(communityStatGraceTimers[key]);
      } else {
        startCommunityStatGrace(key);
      }
      syncCommunityStatsUI();
    }

    async function loadTotalDjs(force=false){
      const cachedTotal = Number(localStorage.getItem(COMMUNITY_TOTAL_DJS_CACHE_KEY) || '');
      if(Number.isFinite(cachedTotal)) setCommunityStat('totalDjs', cachedTotal);
      if(!force && communityStats.totalDjs !== 'â€¦' && communityStats.totalDjs !== 'â€”') return;
      try{
        const resp = await fetch('/api/total-djs');
        if(!resp.ok) throw new Error('Total DJs request failed');
        const data = await resp.json();
        const total = Number(data.totalDjs);
        if(Number.isFinite(total)){
          localStorage.setItem(COMMUNITY_TOTAL_DJS_CACHE_KEY, String(total));
          setCommunityStat('totalDjs', total);
          return;
        }
        throw new Error('Invalid total DJs value');
      } catch(err){
        console.error('Total DJs fetch failed', err);
        setCommunityStat('totalDjs', Number.isFinite(cachedTotal) ? cachedTotal : 'â€”');
      }
    }

    function initCommunityMetrics(){
      if(!FEATURE_SIGNIN_STATS) return;
      startCommunityStatGrace('totalDjs');
      loadTotalDjs();
    }

    // ---------------------- Offline helpers -----------------------
    function handleNetworkStatusChange(){
      isOffline = !navigator.onLine;
      const badges = document.querySelectorAll('[data-network-badge]');
      badges.forEach(el=>{
        el.textContent = isOffline ? 'Offline' : 'Online';
        el.className = isOffline
          ? 'inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold bg-red-600/30 border border-red-400/60 text-red-100'
          : 'inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold bg-emerald-600/30 border border-emerald-400/60 text-emerald-100';
      });
      render();
      setupEventListeners();
      if(!isOffline){
        flushOwnedLibraryPendingWrite().catch(err=>console.warn('[owned-library] pending flush failed', err));
      }
    }

    function isMobileViewport(){
      if(window.__forceMobileViewport === true) return true;
      if(mobileViewportQuery) return mobileViewportQuery.matches;
      return window.innerWidth < MOBILE_BREAKPOINT;
    }

    function updatePerformanceMode(){
      const prefersReducedMotion = reducedMotionQuery?.matches;
      const saveData = navigator?.connection?.saveData === true;
      isLowPowerMode = !!(prefersReducedMotion || saveData);
      document.documentElement.classList.toggle('reduced-effects', isLowPowerMode);
    }

    function updateMobileWindowState({ reset = false } = {}){
      if(reset){
        mobileWindowState = { start: 0, count: MOBILE_PAGE_CHUNK };
        return;
      }
      if(mobileWindowState.count < MOBILE_PAGE_CHUNK){
        mobileWindowState.count = MOBILE_PAGE_CHUNK;
      }
    }

    function openTrackDb(){
      return new Promise((resolve,reject)=>{
        if(!('indexedDB' in window)) return resolve(null);
        const req = indexedDB.open(TRACK_DB.name,1);
        req.onupgradeneeded = ()=>{ req.result.createObjectStore(TRACK_DB.store, { keyPath:'id' }); };
        req.onsuccess = ()=>resolve(req.result);
        req.onerror = ()=>resolve(null);
      });
    }

    async function cacheTracks(list){
      const db = await openTrackDb();
      if(!db) return;
      return new Promise(resolve=>{
        const tx = db.transaction(TRACK_DB.store,'readwrite');
        const store = tx.objectStore(TRACK_DB.store);
        list.forEach(t=>store.put(t));
        tx.oncomplete = ()=>resolve();
        tx.onerror = ()=>resolve();
      });
    }

    async function readCachedTracks(){
      const db = await openTrackDb();
      if(!db) return [];
      return new Promise(resolve=>{
        const tx = db.transaction(TRACK_DB.store,'readonly');
        const store = tx.objectStore(TRACK_DB.store);
        const req = store.getAll();
        req.onsuccess = ()=>resolve(req.result || []);
        req.onerror = ()=>resolve([]);
      });
    }

    // ---------------------- Utils & Scoring -----------------------
    function normalizeMode(mode,keyStr){
      const m=(mode||'').toLowerCase();
      if(m.includes('min')) return 'minor';
      if(m.includes('maj')) return 'major';
      const k=(keyStr||'').toLowerCase();
      if(/m$/.test(k) || k.includes('minor')) return 'minor';
      if(k.includes('major')) return 'major';
      return '';
    }
    function normalizeKeyName(raw){
      if(!raw) return '';
      let cleaned = (raw||'').replace(/major|minor/ig,'').replace(/maj|min/ig,'').trim();
      cleaned = cleaned.replace(/m$/i,'');
      cleaned = cleaned.replace(/[^a-g#b]/ig,'');
      if(!cleaned) return '';
      const first = cleaned[0].toUpperCase();
      const rest = cleaned.slice(1).replace(/b/,'b').replace(/#/,'#');
      return (first + rest);
    }
    const pitchClassMap = { C:0,'C#':1,Db:1,D:2,'D#':3,Eb:3,E:4,F:5,'F#':6,Gb:6,G:7,'G#':8,Ab:8,A:9,'A#':10,Bb:10,B:11 };
    function parseKey(keyStr, modeStr){
      const raw = (keyStr||'').trim();
      let mode = normalizeMode(modeStr||'', keyStr||'') || null;
      let root = null;
      let pitchClass = null;
      let label = raw || '';
      const explicitMatch = raw.match(/^([A-Ga-g][#b]?)(?:\s*(major|minor))?$/i);
      const shorthandMinor = raw.match(/^([A-Ga-g][#b]?)m$/i);
      if(shorthandMinor){
        root = normalizeKeyName(shorthandMinor[1]);
        mode = mode || 'minor';
      } else if(explicitMatch){
        root = normalizeKeyName(explicitMatch[1]);
        if(explicitMatch[2]) mode = explicitMatch[2].toLowerCase();
      } else if(raw){
        const simpleRoot = raw.match(/^([A-Ga-g][#b]?)/);
        if(simpleRoot){ root = normalizeKeyName(simpleRoot[1]); }
        if(/minor/i.test(raw)) mode = mode || 'minor';
        if(/major/i.test(raw)) mode = mode || 'major';
      }
      if(root && Object.prototype.hasOwnProperty.call(pitchClassMap, root)){
        pitchClass = pitchClassMap[root];
      }
      if(root){
        const modeLabel = mode ? (mode === 'minor' ? 'Minor' : 'Major') : '';
        label = modeLabel ? `${root} ${modeLabel}` : root;
      } else {
        label = label || '?';
      }
      return { root, pitchClass, mode, label };
    }
    function convertToCamelot(key, mode) {
      if (!key && !mode) return '?';
      const modeNormalized = normalizeMode(mode,key);
      const base = normalizeKeyName(key);
      const variants = [];
      const modeWord = modeNormalized === 'minor' ? 'Minor' : 'Major';
      if(base){
        if(modeNormalized){ variants.push(`${base} ${modeWord}`); variants.push(`${base}${modeNormalized==='minor'?'m':''}`); }
        variants.push(base);
      }
      for(const v of variants){ if(keyToCamelot[v]) return keyToCamelot[v]; }
      return '?';
    }
    function deriveCamelotForTrack(track){
      const baseKey = normalizeKeyName(track.mk || track.key || '');
      const mode = normalizeMode(track.mm || track.mode || '', track.mk || track.key || '');
      const fallbackMode = mode || (((track.key||'') + (track.mk||'')).toLowerCase().includes('m') ? 'minor' : 'major');
      const camelot = convertToCamelot(baseKey || track.mk || track.key || '', fallbackMode);
      const keyLabel = baseKey ? `${baseKey} ${fallbackMode}` : '?';
      return { camelot, keyLabel, mode: fallbackMode };
    }
    function semitoneDistance(aPc,bPc){ if(aPc===null||aPc===undefined||bPc===null||bPc===undefined) return null; const d=Math.abs(aPc-bPc)%12; return Math.min(d,12-d); }
    function signedSemitoneDelta(aPc,bPc){ if(aPc===null||aPc===undefined||bPc===null||bPc===undefined) return null; let diff=(bPc-aPc)%12; if(diff>6) diff-=12; if(diff<-6) diff+=12; return diff; }
    function scoreSemitoneKeyMatch(a,b,maxRange, allowOpposite=true){
      if(!a || !b || a.pitchClass===null || b.pitchClass===null) return { eligibleSameMode:false, eligibleOppMode:false, dist:null, scoreSameMode:0, scoreOppMode:0 };
      const dist = semitoneDistance(a.pitchClass,b.pitchClass);
      if(dist===null) return { eligibleSameMode:false, eligibleOppMode:false, dist:null, scoreSameMode:0, scoreOppMode:0 };
      const sameMode = a.mode && b.mode && a.mode === b.mode;
      const eligibleSameMode = !!(sameMode && dist <= maxRange);
      const eligibleOppMode = !!(!sameMode && allowOpposite && dist <= maxRange);
      const scoreSameMode = eligibleSameMode ? Math.max(0, 40 - (dist*4)) : 0;
      const scoreOppMode = eligibleOppMode ? Math.max(4, 10 - dist) : 0;
      return { eligibleSameMode, eligibleOppMode, dist, scoreSameMode, scoreOppMode };
    }
    function getCompatibleKeys(camelot) {
      if (!camelot || camelot === '?') return [];
      const matches = camelot.match(/^(\d+)([AB])$/);
      if (!matches) return [];
      const num = parseInt(matches[1]); const letter = matches[2];
      const compatible = [camelot, `${num}${letter==='A'?'B':'A'}`];
      const nextNum = num === 12 ? 1 : num + 1; const prevNum = num === 1 ? 12 : num - 1;
      compatible.push(`${nextNum}${letter}`); compatible.push(`${prevNum}${letter}`);
      return compatible;
    }
    function ensureKeyInfo(track){ if(!track) return { root:null, pitchClass:null, mode:null, label:'?' }; if(!track.keyInfo){ track.keyInfo = parseKey(track.rawKey || track.key || '', track.rawMode || track.mode || ''); } return track.keyInfo; }
    function isMixable(song1,song2){
      if(!song1||!song2) return false;
      if(keyMatchMode === 'semitone'){
        const aInfo = ensureKeyInfo(song1);
        const bInfo = ensureKeyInfo(song2);
        const match = scoreSemitoneKeyMatch(aInfo,bInfo,maxSemitoneRange, includeOppositeMode);
        return match.eligibleSameMode || match.eligibleOppMode;
      }
      const compatible = getCompatibleKeys(song1.camelot);
      return compatible.includes(song2.camelot);
    }
    function isMixableWithBpm(song1,song2){ if(!song1||!song2) return false; const bpmOk = Math.abs(song1.bpm - song2.bpm) <= 4; return bpmOk && isMixable(song1,song2); }

    function scoreKeyMatch(aCamelot,bCamelot){ if(!aCamelot||!bCamelot||aCamelot==='?'||bCamelot==='?') return 0; if(aCamelot===bCamelot) return 50; const ma=aCamelot.match(/^(\d+)([AB])$/), mb=bCamelot.match(/^(\d+)([AB])$/); if(!ma||!mb) return 0; const numA=parseInt(ma[1]), letterA=ma[2], numB=parseInt(mb[1]), letterB=mb[2]; const ringDiff=Math.min(Math.abs(numA-numB),12-Math.abs(numA-numB)); if(numA===numB&&letterA!==letterB) return 42; if(letterA===letterB&&ringDiff===1) return 38; if(letterA!==letterB&&ringDiff===1) return 30; if(letterA===letterB&&ringDiff===2) return 26; return 14 - Math.min(ringDiff,6); }
    function scoreBpmMatch(aBpm,bBpm){ const diff=Math.abs(aBpm-bBpm); if(diff<=1) return 35; if(diff<=3) return 32; if(diff<=6) return 26; if(diff<=10) return 16; if(diff<=15) return 10; return 0; }
    function scoreGenreMatch(aGenre,bGenre){ if(!aGenre||!bGenre) return 0; return aGenre===bGenre?15:5; }
    function camelotDistance(aCamelot,bCamelot){ if(!aCamelot||!bCamelot||aCamelot==='?'||bCamelot==='?') return 99; const ma=aCamelot.match(/^(\d+)([AB])$/), mb=bCamelot.match(/^(\d+)([AB])$/); if(!ma||!mb) return 99; const numA=parseInt(ma[1]), letterA=ma[2], numB=parseInt(mb[1]), letterB=mb[2]; const numDiff=Math.min(Math.abs(numA-numB),12-Math.abs(numA-numB)); const letterDiff = letterA===letterB ? 0 : 0.5; return numDiff + letterDiff; }
    function mashupCompatibility(a,b){
      let keyScore = 0;
      if(keyMatchMode === 'semitone'){
        const aInfo = ensureKeyInfo(a);
        const bInfo = ensureKeyInfo(b);
        const match = scoreSemitoneKeyMatch(aInfo,bInfo,maxSemitoneRange, includeOppositeMode);
        keyScore = match.eligibleSameMode ? match.scoreSameMode : (match.eligibleOppMode ? match.scoreOppMode : 0);
      } else {
        keyScore = scoreKeyMatch(a.camelot,b.camelot);
      }
      const bpm=scoreBpmMatch(a.bpm,b.bpm); const genre=scoreGenreMatch(a.genre,b.genre); const total=keyScore+bpm+genre; return {total,breakdown:{key:keyScore,bpm,genre}};
    }
    function getPriorityBoost(strength){ if(strength==='low') return 60; if(strength==='high') return 200; return 120; }
    function priorityRank(anchor, candidate, mode){
      const comp = mashupCompatibility(anchor, candidate);
      const bpmDiff = Math.abs(candidate.bpm - anchor.bpm);
      const semitoneMatch = keyMatchMode==='semitone' ? (()=>{ const aInfo=ensureKeyInfo(anchor); const bInfo=ensureKeyInfo(candidate); const base=scoreSemitoneKeyMatch(aInfo,bInfo,maxSemitoneRange, includeOppositeMode); return { ...base, signedDelta: signedSemitoneDelta(aInfo.pitchClass,bInfo.pitchClass) }; })() : null;
      const keyDist = keyMatchMode==='semitone' ? (semitoneMatch ? semitoneMatch.dist : null) : camelotDistance(anchor.camelot, candidate.camelot);
      const sameGenre = candidate.genre === anchor.genre;

      const bpmScore = Math.max(0, 1 - (bpmDiff / 10));
      const keyScore = keyMatchMode==='semitone'
        ? Math.max(0, 1 - ((keyDist ?? 6) / 6))
        : Math.max(0, 1 - (keyDist / 6));
      const genreScore = sameGenre ? 1 : 0;

      const boost = getPriorityBoost(priorityStrength);
      let rank = comp.total * 10;

      if(mode === 'bpm') rank += bpmScore * boost;
      if(mode === 'camelot') rank += keyScore * boost;
      if(mode === 'genre') rank += genreScore * boost;

      if(bpmDiff > 12) rank -= 40;
      if(keyDist !== null && keyDist !== undefined && keyDist > 4) rank -= 40;

      return { rank, comp, bpmDiff, keyDist, sameGenre, semitoneMatch };
    }
    function bpmShiftSuggestion(aBpm,bBpm){ const shift=Math.round(bBpm-aBpm); if(shift===0) return 'No change'; return (shift>0?'+':'')+shift+' BPM = Perfect Match'; }
    function normalizeTitleArtist(title,artist){
      return `${(title||'').toLowerCase()}|${(artist||'').toLowerCase()}`;
    }
    function applyCamelotOverride(track, derivedCamelot){
      const key = normalizeTitleArtist(track.title || track.tt, track.artist || track.an);
      const fromId = camelotOverridesStore.ids[track.id];
      const fromName = camelotOverridesStore.names[key];
      const finalCamelot = fromId || fromName || derivedCamelot;
      return { camelot: finalCamelot, overridden: !!(fromId || fromName) };
    }
    function applyBpmOverride(track, rawBpm){
      const key = normalizeTitleArtist(track.title || track.tt, track.artist || track.an);
      const fromId = bpmOverridesStore.ids[track.id];
      const fromName = bpmOverridesStore.names[key];
      const finalBpm = fromId ? Number(fromId) : (fromName ? Number(fromName) : rawBpm);
      return { bpm: isNaN(finalBpm) ? rawBpm : finalBpm, overridden: !!(fromId || fromName) };
    }
    function computeTrackFlags(track){
      const flags = [];
      if(!track.camelot || !/^\d{1,2}[AB]$/.test(track.camelot)) flags.push('INVALID_CAMELOT');
      const modeLower = (track.mode||'').toLowerCase();
      if(track.camelot && /^\d{1,2}[AB]$/.test(track.camelot)){
        const letter = track.camelot.slice(-1);
        if(modeLower==='major' && letter==='A') flags.push('MODE_MISMATCH');
        if(modeLower==='minor' && letter==='B') flags.push('MODE_MISMATCH');
      }
      if(!track.rawKey && !track.rawMode) flags.push('WEAK_PARSE');
      if(!track.bpm || isNaN(track.bpm)) flags.push('BPM_MISSING');
      if(track.bpm && (track.bpm < 60 || track.bpm > 220)) flags.push('BPM_OUTLIER');
      if(track.camelotOverridden) flags.push('OVERRIDDEN_CAMELOT');
      if(track.bpmOverridden) flags.push('OVERRIDDEN_BPM');
      return flags;
    }
    function refreshSongOverrides(track){
      const camelotData = deriveCamelotForTrack({ mk: track.rawKey, mm: track.rawMode, key: track.key, title: track.title, artist: track.artist });
      const camelotApplied = applyCamelotOverride(track, camelotData.camelot);
      const bpmApplied = applyBpmOverride(track, track.rawBpm || track.bpm);
      track.keyInfo = parseKey(track.rawKey || track.key || '', track.rawMode || track.mode || '');
      track.key = track.keyInfo.label || camelotData.keyLabel || track.key;
      track.camelot = camelotApplied.camelot;
      track.camelotOverridden = camelotApplied.overridden;
      track.bpm = bpmApplied.bpm;
      track.bpmOverridden = bpmApplied.overridden;
      track.derivedCamelot = camelotData.camelot;
      track.flags = computeTrackFlags(track);
    }
    function hydrateKeyInfo(track){
      if(!track) return;
      track.keyInfo = parseKey(track.rawKey || track.key || '', track.rawMode || track.mode || '');
      if(track.keyInfo.label) track.key = track.keyInfo.label;
    }
    // ----------------------- Genre detection -----------------------
    function detectGenre(artist, title){
      artist=(artist||'').toLowerCase(); title=(title||'').toLowerCase();
      for(const [genre,artists] of Object.entries(genreMap)){
        if(artists.some(a=>artist.includes(a) || (a.length>3 && artist.includes(a.split(' ')[0])))) return genre;
      }
      if(title.includes('rock')||title.includes('metal')) return 'Rock';
      if(title.includes('funk')||title.includes('disco')) return 'Disco/Funk';
      if(title.includes('blues')) return 'Blues';
      if(title.includes('jazz')) return 'Jazz';
      if(title.includes('country')) return 'Country';
      if(title.includes('reggae')) return 'Reggae';
      return 'Other';
    }

    // ----------------------- Storage helpers -----------------------
    function loadOverridesFromStorage(){
      try{
        camelotOverridesStore = JSON.parse(localStorage.getItem('camelotOverrides_v2') || '{"ids":{},"names":{}}');
      }catch(e){ camelotOverridesStore = { ids:{}, names:{} }; }
      try{
        bpmOverridesStore = JSON.parse(localStorage.getItem('bpmOverrides_v1') || '{"ids":{},"names":{}}');
      }catch(e){ bpmOverridesStore = { ids:{}, names:{} }; }
    }
    async function persistOverrides(){
      localStorage.setItem('camelotOverrides_v2', JSON.stringify(camelotOverridesStore));
      localStorage.setItem('bpmOverrides_v1', JSON.stringify(bpmOverridesStore));
      if(isAdmin() && firestore && firebaseAuth?.currentUser){
        try{
          const collection = getProfileCollection();
          if(!collection) return;
          await collection.doc(firebaseAuth.currentUser.uid).set({
            camelotOverrides: camelotOverridesStore,
            bpmOverrides: bpmOverridesStore
          },{merge:true});
        }catch(err){ console.warn('persist override firestore', err); }
      }
    }
    async function loadUserOverridesFromBackend(){
      if(isAdmin() && firestore && firebaseAuth?.currentUser){
        try{
          const collection = getProfileCollection();
          if(!collection) return;
          const doc = await collection.doc(firebaseAuth.currentUser.uid).get();
          if(doc.exists){
            const data = doc.data()||{};
            if(data.camelotOverrides) camelotOverridesStore = data.camelotOverrides;
            if(data.bpmOverrides) bpmOverridesStore = data.bpmOverrides;
          }
        }catch(err){ console.warn('load override firestore', err); }
      }
    }
    function normalizeOwnedList(ids){
      const arr = Array.isArray(ids) ? ids.filter(Boolean) : [];
      return Array.from(new Set(arr)).sort();
    }
    function buildOwnedLibrarySnapshot(trackIds, updatedAt = new Date().toISOString(), meta = null){
      const normalized = normalizeOwnedList(trackIds);
      const hash = window.profileStore?.computeOwnedTracksHash
        ? window.profileStore.computeOwnedTracksHash(normalized)
        : normalized.join('|');
      return {
        trackIds: normalized,
        count: normalized.length,
        schemaVersion: window.profileStore?.OWNED_LIBRARY_SCHEMA_VERSION || 1,
        updatedAt,
        hash,
        ...(meta ? { meta } : {})
      };
    }
    function readOwnedTracksCache(uid){
      if(!uid) return null;
      return window.profileStore?.readOwnedTracksCache?.(uid) || null;
    }
    function writeOwnedTracksCache(uid, trackIds, updatedAt = new Date().toISOString()){
      if(!uid) return null;
      const snapshot = buildOwnedLibrarySnapshot(trackIds, updatedAt);
      return window.profileStore?.writeOwnedTracksCache?.(uid, snapshot) || snapshot;
    }
    async function writeOwnedTracksCloud(uid, trackIds, meta = null){
      if(!uid) return null;
      if(!window.profileStore?.writeOwnedLibraryDoc) return null;
      const snapshot = buildOwnedLibrarySnapshot(trackIds, new Date().toISOString(), meta);
      return window.profileStore.writeOwnedLibraryDoc(uid, snapshot);
    }
    function setOwnedLibraryStatus({ phase = 'idle', source = 'none', message = '' } = {}){
      ownedLibraryState = { phase, source, message };
    }
    function resolveOwnedLibraryStatusMessage(){
      if(!ownedLibraryState?.message) return '';
      return ownedLibraryState.message;
    }
    async function flushOwnedLibraryPendingWrite(){
      if(!ownedLibraryPendingWrite) return;
      if(ownedLibraryRestoring) return;
      const uid = firebaseAuth?.currentUser?.uid;
      if(!uid || !firebaseEnabled || !firestore || !navigator.onLine) return;
      const payload = ownedLibraryPendingWrite;
      ownedLibraryPendingWrite = null;
      const meta = payload.reason === 'explicit_clear' ? { reason: payload.reason } : null;
      await writeOwnedTracksCloud(uid, payload.trackIds, meta);
      setOwnedLibraryStatus({
        phase: 'ready',
        source: 'cloud',
        message: 'Library loaded (Cloud)'
      });
    }
    async function saveOwnedTracksSafe(nextTrackIds, { reason = 'update', allowEmpty = false, skipCloud = false } = {}){
      const normalized = normalizeOwnedList(nextTrackIds);
      const explicitClear = reason === 'explicit_clear';
      const currentNormalized = normalizeOwnedList(ownedTracks);
      if(JSON.stringify(normalized) === JSON.stringify(currentNormalized)){
        return { skipped: true, reason: 'identical' };
      }
      if(normalized.length === 0 && !explicitClear && !allowEmpty){
        console.warn('[owned-library] blocked empty save', { reason });
        return { skipped: true, reason: 'empty_blocked' };
      }
      ownedTracks = normalized;
      const uid = firebaseAuth?.currentUser?.uid || currentUser?.uid;
      if(uid) writeOwnedTracksCache(uid, normalized);
      if(skipCloud || ownedLibraryRestoring){
        ownedLibraryPendingWrite = { trackIds: normalized, reason };
        return { savedLocal: true, queued: true };
      }
      if(uid && firebaseEnabled && firestore && navigator.onLine){
        const meta = explicitClear ? { reason } : null;
        await writeOwnedTracksCloud(uid, normalized, meta);
        return { savedCloud: true };
      }
      ownedLibraryPendingWrite = { trackIds: normalized, reason };
      return { savedLocal: true, queued: true };
    }
    async function restoreOwnedLibrary(uid, { legacyOwnedTracks = [] } = {}){
      if(!uid) return;
      ownedLibraryRestoring = true;
      const cachedSnapshot = readOwnedTracksCache(uid);
      const legacySnapshot = legacyOwnedTracks.length
        ? buildOwnedLibrarySnapshot(legacyOwnedTracks, new Date().toISOString())
        : null;
      let localSnapshot = cachedSnapshot || legacySnapshot || null;
      if(localSnapshot?.trackIds?.length){
        ownedTracks = normalizeOwnedList(localSnapshot.trackIds);
        setOwnedLibraryStatus({
          phase: 'restoring',
          source: 'cache',
          message: 'Restoring your libraryâ€¦ Using cached library.'
        });
        render();
        setupEventListeners();
      } else {
        setOwnedLibraryStatus({
          phase: 'restoring',
          source: 'none',
          message: 'Restoring your libraryâ€¦'
        });
        render();
        setupEventListeners();
      }
      if(!firebaseEnabled || !firestore || !navigator.onLine){
        if(localSnapshot && !cachedSnapshot){
          writeOwnedTracksCache(uid, localSnapshot.trackIds, localSnapshot.updatedAt);
        }
        ownedLibraryRestoring = false;
        setOwnedLibraryStatus({
          phase: 'ready',
          source: localSnapshot?.trackIds?.length ? 'cache' : 'local',
          message: localSnapshot?.trackIds?.length ? 'Library loaded (Cached)' : 'Library loaded (Local)'
        });
        return;
      }
      try{
        let cloudSnapshot = null;
        try{
          cloudSnapshot = await window.profileStore.readOwnedLibraryDoc(uid);
        }catch(err){
          console.warn('[owned-library] cloud read failed', err);
        }
        const plan = window.profileStore.buildOwnedLibraryPlan({ cache: localSnapshot, cloud: cloudSnapshot });
        if(plan?.chosen?.trackIds){
          ownedTracks = normalizeOwnedList(plan.chosen.trackIds);
        }
        if(plan.shouldUpdateCache){
          writeOwnedTracksCache(uid, plan.chosen.trackIds, plan.chosen.updatedAt || new Date().toISOString());
        }
        if(plan.shouldSeedCloud || plan.shouldWriteCloud){
          if(plan.chosen.trackIds.length){
            await writeOwnedTracksCloud(uid, plan.chosen.trackIds, { reason: plan.shouldSeedCloud ? 'seed_cache' : 'reconcile_cache' });
          }
        }
        const sourceLabel = plan.source === 'cloud' ? 'Cloud' : plan.source === 'cache' ? 'Cached' : 'Local';
        setOwnedLibraryStatus({
          phase: 'ready',
          source: plan.source,
          message: `Library loaded (${sourceLabel})`
        });
        await flushOwnedLibraryPendingWrite();
      } catch(err){
        console.warn('[owned-library] reconcile failed', err);
        setOwnedLibraryStatus({
          phase: 'ready',
          source: localSnapshot?.trackIds?.length ? 'cache' : 'local',
          message: localSnapshot?.trackIds?.length ? 'Library loaded (Cached)' : 'Library loaded (Local)'
        });
      } finally {
        ownedLibraryRestoring = false;
      }
    }
    function normalizeSetlistIds(ids){
      if(!Array.isArray(ids)) return [];
      const list = ids.map(item => (typeof item === 'string' ? item : item?.id)).filter(Boolean);
      return Array.from(new Set(list));
    }
    function getTourProfileDone(profile){
      if(!profile?.tour) return false;
      const version = Number(profile.tour.version || 0);
      return profile.tour.done === true && version >= TOUR_VERSION;
    }
    function isTourDone(){
      if(localStorage.getItem(TOUR_STORAGE_KEY) === '1') return true;
      return getTourProfileDone(currentUser);
    }
    function markTourDone(){
      localStorage.setItem(TOUR_STORAGE_KEY, '1');
      if(currentUser && !viewingProfile){
        const tourData = { done: true, version: TOUR_VERSION, completedAt: new Date().toISOString() };
        currentUser = { ...currentUser, tour: tourData };
        if(draftProfile) draftProfile.tour = tourData;
        if(!isPersistingProfile){
          persistCurrentUserProfile().catch(err=>console.warn('[tour] profile persist failed', err));
        }
      }
    }
    function getTourElements(){
      return {
        overlay: document.getElementById('tourOverlay'),
        highlight: document.getElementById('tourHighlight'),
        tooltip: document.getElementById('tourTooltip'),
        title: document.getElementById('tourTitle'),
        copy: document.getElementById('tourCopy'),
        hint: document.getElementById('tourHint'),
        backBtn: document.getElementById('tourBackBtn'),
        routeBtn: document.getElementById('tourRouteBtn'),
        skipBtn: document.getElementById('tourSkipBtn'),
        nextBtn: document.getElementById('tourNextBtn')
      };
    }
    function openTourOverlay(){
      const { overlay } = getTourElements();
      if(!overlay) return;
      overlay.dataset.open = 'true';
      overlay.setAttribute('aria-hidden','false');
    }
    function closeTourOverlay(){
      const { overlay } = getTourElements();
      if(!overlay) return;
      overlay.dataset.open = 'false';
      overlay.setAttribute('aria-hidden','true');
    }
    function focusTour(){
      const { tooltip } = getTourElements();
      if(!tooltip) return;
      const focusables = tooltip.querySelectorAll('button,[href],[tabindex]:not([tabindex="-1"])');
      const first = focusables[0];
      if(first) first.focus();
    }
    function trapTourFocus(e){
      if(!tourState.isOpen || e.key !== 'Tab') return;
      const { tooltip } = getTourElements();
      if(!tooltip) return;
      const focusables = Array.from(tooltip.querySelectorAll('button,[href],[tabindex]:not([tabindex="-1"])'));
      if(!focusables.length) return;
      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      if(e.shiftKey && document.activeElement === first){
        e.preventDefault();
        last.focus();
      } else if(!e.shiftKey && document.activeElement === last){
        e.preventDefault();
        first.focus();
      }
    }
    function scrollTargetIntoView(targetEl){
      if(!targetEl) return;
      try{
        targetEl.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
      }catch(_){}
    }
    function positionTourElements(step){
      const { highlight, tooltip, hint, routeBtn, nextBtn } = getTourElements();
      if(!highlight || !tooltip) return;
      const routeMismatch = step.route && view !== step.route;
      const targetEl = routeMismatch ? null : document.querySelector(step.selector);
      const rect = targetEl?.getBoundingClientRect();
      const hasTarget = rect && rect.width > 0 && rect.height > 0;
      if(hasTarget){
        const padding = 6;
        highlight.style.display = 'block';
        highlight.style.top = `${Math.max(0, rect.top - padding)}px`;
        highlight.style.left = `${Math.max(0, rect.left - padding)}px`;
        highlight.style.width = `${rect.width + padding * 2}px`;
        highlight.style.height = `${rect.height + padding * 2}px`;
      } else {
        highlight.style.display = 'none';
      }
      if(hint){
        if(routeMismatch){
          hint.textContent = step.route === 'profile' ? 'Open Profile to continue.' : 'Open Browse to continue.';
          hint.style.display = 'block';
        } else if(!hasTarget){
          hint.textContent = 'Go to the next screen to continue.';
          hint.style.display = 'block';
        } else {
          hint.style.display = 'none';
        }
      }
      if(routeBtn){
        routeBtn.style.display = routeMismatch ? 'inline-flex' : 'none';
        routeBtn.textContent = step.routeLabel || (step.route === 'profile' ? 'Go to Profile' : 'Go to Browse');
      }
      if(nextBtn){
        nextBtn.disabled = routeMismatch;
      }
      if(!hasTarget){
        tooltip.style.top = '50%';
        tooltip.style.left = '50%';
        tooltip.style.transform = 'translate(-50%, -50%)';
        return;
      }
      tooltip.style.transform = 'translate(0, 0)';
      const tooltipRect = tooltip.getBoundingClientRect();
      const spacing = 12;
      let top = rect.bottom + spacing;
      if(top + tooltipRect.height > window.innerHeight - 12){
        top = rect.top - spacing - tooltipRect.height;
      }
      let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
      left = Math.max(12, Math.min(left, window.innerWidth - tooltipRect.width - 12));
      if(top < 12 || top + tooltipRect.height > window.innerHeight - 12){
        top = Math.max(12, Math.min(rect.bottom + spacing, window.innerHeight - tooltipRect.height - 12));
      }
      tooltip.style.top = `${top}px`;
      tooltip.style.left = `${left}px`;
      scrollTargetIntoView(targetEl);
    }
    function updateTourUI(){
      if(!tourState.isOpen) return;
      const step = tourState.steps[tourState.stepIndex];
      const { title, copy, backBtn, nextBtn } = getTourElements();
      if(title) title.textContent = step.title;
      if(copy) copy.textContent = step.copy;
      if(backBtn) backBtn.style.display = tourState.stepIndex === 0 ? 'none' : 'inline-flex';
      if(nextBtn) nextBtn.textContent = tourState.stepIndex === tourState.steps.length - 1 ? 'Done' : 'Next';
      requestAnimationFrame(()=> positionTourElements(step));
    }
    function startTour(source = 'auto', options = {}){
      if(tourState.isOpen) return;
      if(!options.force && isTourDone()) return;
      tourState.isOpen = true;
      tourState.stepIndex = 0;
      tourState.source = source;
      tourState.lastFocused = document.activeElement;
      bindTourEvents();
      const helpModal = document.getElementById('helpModal');
      if(helpModal && helpModal.style.display === 'flex'){
        closeHelp();
      }
      openTourOverlay();
      updateTourUI();
      focusTour();
    }
    function nextTourStep(){
      if(!tourState.isOpen) return;
      if(tourState.stepIndex >= tourState.steps.length - 1){
        finishTour();
        return;
      }
      tourState.stepIndex += 1;
      updateTourUI();
      focusTour();
    }
    function prevTourStep(){
      if(!tourState.isOpen) return;
      if(tourState.stepIndex === 0) return;
      tourState.stepIndex -= 1;
      updateTourUI();
      focusTour();
    }
    function skipTour(){
      if(!tourState.isOpen) return;
      tourState.isOpen = false;
      closeTourOverlay();
      markTourDone();
      if(tourState.lastFocused && typeof tourState.lastFocused.focus === 'function'){
        tourState.lastFocused.focus();
      }
    }
    function finishTour(){
      if(!tourState.isOpen) return;
      tourState.isOpen = false;
      closeTourOverlay();
      markTourDone();
      if(tourState.lastFocused && typeof tourState.lastFocused.focus === 'function'){
        tourState.lastFocused.focus();
      }
    }
    function goToTourRoute(route){
      if(!route) return;
      if(typeof window.switchView === 'function'){
        window.switchView(route);
      }
      updateTourUI();
    }
    function bindTourEvents(){
      const { backBtn, nextBtn, skipBtn, routeBtn } = getTourElements();
      if(backBtn && !backBtn.dataset.bound){
        backBtn.dataset.bound = 'true';
        backBtn.addEventListener('click', prevTourStep);
      }
      if(nextBtn && !nextBtn.dataset.bound){
        nextBtn.dataset.bound = 'true';
        nextBtn.addEventListener('click', nextTourStep);
      }
      if(skipBtn && !skipBtn.dataset.bound){
        skipBtn.dataset.bound = 'true';
        skipBtn.addEventListener('click', skipTour);
      }
      if(routeBtn && !routeBtn.dataset.bound){
        routeBtn.dataset.bound = 'true';
        routeBtn.addEventListener('click', ()=>{
          const step = tourState.steps[tourState.stepIndex];
          goToTourRoute(step.route);
        });
      }
    }
    function maybeAutoStartTour(){
      if(isTourDone()) return;
      if(tourState.isOpen) return;
      setTimeout(()=>{
        if(tourState.isOpen || isTourDone()) return;
        startTour('auto');
      }, 300);
    }
    async function persistCurrentUserProfile(){
      console.debug('[profile] save clicked', { draftProfile, currentUser });
      if(viewingProfile) throw new Error('Cannot save while viewing another profile');
      if(!currentUser?.username) throw new Error('No current user to persist');
      const adminApplied = applyAdminFlag(currentUser);
      await persistAdminFlagIfNeeded(currentUser, adminApplied);
      currentUser = adminApplied;
      isPersistingProfile = true;
      try{
        syncPreferencesIntoProfile();
        const normalizedStreamUrl = normalizeStreamUrlInput(currentUser.streamUrl || '');
        const streamUrlValid = isValidStreamUrl(normalizedStreamUrl);
        const usernameLower = normalizeUsernameLower(currentUser.username);
        const djNameLower = normalizeUsernameLower(currentUser.djName || currentUser.username);
        const displayNameLower = normalizeUsernameLower(currentUser.djName || currentUser.username);
        const searchNameLower = usernameLower;
        const persona = ensurePersona(currentUser);
        persistPersonaToStorage(persona);
        const bio = (currentUser.bio || '').slice(0, PROFILE_BIO_MAX);
        const themeAccent = currentUser.themeAccent || THEME_ACCENTS[0].id;
        const isPublic = currentUser.isPublic !== false;
        const allowFriendRequests = currentUser.allowFriendRequests !== false;
        const rulesAccepted = currentUser.rulesAccepted === true;
        const rulesAcceptedAt = currentUser.rulesAcceptedAt || null;
        const { ownedTracks: currentOwnedTracks, ownedMap: currentOwnedMap, ...currentUserRest } = currentUser || {};
        const mergedProfile = {
          ...currentUserRest,
          uid: firebaseAuth?.currentUser?.uid || currentUser.uid,
          username: currentUser.username,
          djName: (currentUser.djName || currentUser.username || '').trim() || currentUser.username,
          usernameLower,
          djNameLower,
          displayNameLower,
          searchNameLower,
          searchTokens: buildSearchTokens(usernameLower),
          bio,
          themeAccent,
          personaId: persona.personaId,
          personaTheme: persona.personaTheme,
          personaSeed: persona.personaSeed,
          isPublic,
          allowFriendRequests,
          rulesAccepted,
          rulesAcceptedAt,
          setlist: setlist || [],
          bandMembers,
          genreOverrides,
          streamUrl: normalizedStreamUrl,
          isLive: streamUrlValid ? currentUser.isLive === true : false,
          liveStartedAt: streamUrlValid ? (currentUser.liveStartedAt || currentUser.liveSince || null) : null,
          oauth: currentUser.oauth || {},
          tour: currentUser.tour || {},
          preferences: {
            keyMatchMode,
            maxSemitoneRange,
            includeOppositeMode,
            priorityStrength
          }
        };
        console.debug('[profile] currentUser before persist', currentUser);
        currentUser = mergedProfile;
        console.debug('[profile] currentUser after merge', currentUser);
        refreshDraftProfileFromCurrentUser();
        persistProfileCache();
        persistKeyMatchSettings();
        const profileKey = currentUser.uid || currentUser.username;
        if(profileKey) localStorage.setItem('currentUser', profileKey);
        const profiles = JSON.parse(localStorage.getItem('userProfiles')||'{}');
        if (currentUser.username) profiles[currentUser.username] = { ...(profiles[currentUser.username]||{}), ...mergedProfile };
        if (currentUser.uid) profiles[currentUser.uid] = { ...(profiles[currentUser.uid]||{}), ...mergedProfile };
        localStorage.setItem('userProfiles', JSON.stringify(profiles));
        console.debug('[profile] local save ok');
        const backendOk = await saveUserProfileToBackend(mergedProfile);
        console[backendOk ? 'debug' : 'warn'](backendOk ? '[profile] backend save ok' : '[profile] backend save failed');
        const verifyProfile = await loadUserProfile(currentUser.uid || currentUser.username);
        const prefMatch = JSON.stringify(verifyProfile?.preferences || {}) === JSON.stringify(mergedProfile.preferences || {});
        const genreMatch = JSON.stringify(verifyProfile?.genreOverrides || {}) === JSON.stringify(mergedProfile.genreOverrides || {});
        const djMatch = (verifyProfile?.djName || '').trim() === (mergedProfile.djName || '').trim();
        const verified = !!verifyProfile && djMatch && prefMatch && genreMatch;
        if(!verified){
          console.error('[profile] save verification failed', { mergedProfile, verifyProfile });
          throw new Error('Save verification failed');
        }
        currentUser = verifyProfile;
        applyPreferencesFromProfile(currentUser);
        refreshDraftProfileFromCurrentUser();
        console.debug('[profile] save verified', { verifyProfile });
        return { backendOk, verifyProfile };
      } finally {
        isPersistingProfile = false;
      }
    }
    async function loadUserProfile(username){
      if(!username && !firebaseAuth?.currentUser) return null;
      const firebaseUser = firebaseAuth?.currentUser;
      if(firestore && (firebaseUser || username)){
        try{
          const collection = getProfileCollection();
          const legacyCollection = getLegacyProfileCollection();
          const lookupId = firebaseUser?.uid || username;
          const isLikelyUid = typeof lookupId === 'string' && (lookupId.startsWith('local:') || lookupId.length >= 20);
          if(collection && isLikelyUid){
            const doc = await collection.doc(lookupId).get();
            if(doc.exists) return normalizeProfileShape(doc.data(), lookupId);
          }
          if(legacyCollection && isLikelyUid){
            const legacyId = firebaseUser?.uid || username;
            const legacyDoc = await legacyCollection.doc(legacyId).get();
            if(legacyDoc.exists) return normalizeProfileShape(legacyDoc.data(), legacyId);
          }
          if(username && collection){
            const query = await collection.where('usernameLower','==', normalizeUsernameLower(username)).limit(1).get();
            const match = query.docs[0];
            if(match?.exists) return normalizeProfileShape({ ...match.data(), uid: match.id }, match.id);
          }
        }catch(e){ console.warn('Firestore load failed',e); }
      }
      const profiles = JSON.parse(localStorage.getItem('userProfiles')||'{}');
      if(firebaseUser?.uid && profiles[firebaseUser.uid]) return normalizeProfileShape(profiles[firebaseUser.uid], firebaseUser.uid);
      return normalizeProfileShape(profiles[username], username) || null;
    }

    async function loadProfileForViewing(username){
      if(!username) return null;
      const profile = await loadUserProfileFromBackend(username) || await loadUserProfile(username);
      if(profile?.isPublic === false){
        const ownerId = firebaseAuth?.currentUser?.uid || currentUser?.uid || currentUser?.username;
        if(ownerId !== profile.uid && ownerId !== profile.username){
          return null;
        }
      }
      if(profile?.uid && firebaseEnabled && firestore && navigator.onLine){
        try{
          const ownedSnapshot = await window.profileStore.readOwnedLibraryDoc(profile.uid);
          if(ownedSnapshot?.trackIds){
            profile.ownedTracks = ownedSnapshot.trackIds;
          }
        }catch(err){
          console.warn('[profile] owned library fetch failed', err);
        }
      }
      viewingProfile = profile || null;
      return viewingProfile;
    }

    async function fetchProfilesByField(field, value, { publicOnly = true } = {}){
      if(!firestore || !value) return [];
      try{
        const collection = getProfileCollection();
        if(!collection) return [];
        let query = collection.where(field,'==',value);
        if(publicOnly) query = query.where('isPublic','==',true);
        const snap = await query.get();
        return snap.docs.map(doc=> normalizeProfileShape({ ...doc.data(), uid: doc.id }, doc.id));
      }catch(err){ console.warn('profile lookup failed', err); return []; }
    }

    function getFriendsOnlineStatus(){
      const firebaseReady = firebaseEnabled && !!firestore;
      const signedIn = !!firebaseAuth?.currentUser;
      const offline = !navigator.onLine || isOffline;
      const online = firebaseReady && signedIn && !offline;
      return { firebaseReady, signedIn, offline, online };
    }

    function getFriendsGateMessage(status){
      if(!status) return '';
      if(status.offline) return 'Friends require Online mode.';
      if(!status.firebaseReady) return 'Friends require Firebase online mode.';
      if(!status.signedIn) return 'Sign in to search friends.';
      return '';
    }

    function isOnlineProfileMode(){
      return getFriendsOnlineStatus().online;
    }

    function setFriendSearchNotice(message, tone = 'info'){
      socialFriendSearchNotice = message;
      socialFriendSearchNoticeTone = tone;
    }

    function getFriendSearchQuery(){
      const input = document.getElementById('socialFriendSearchInput');
      const raw = input?.value || '';
      const trimmed = raw.trim();
      socialFriendSearchTerm = raw;
      socialFriendSearchQuery = trimmed;
      return trimmed;
    }

    function logFriendSearchClick(){
      const q = getFriendSearchQuery();
      console.debug('[friends] search click', { q });
    }

    function handleFriendSearch(event, { explicit = true } = {}){
      if(event?.preventDefault) event.preventDefault();
      if(viewingProfile) return;
      const query = getFriendSearchQuery();
      socialFriendSearchError = '';
      if(!query){
        if(explicit){
          socialFriendSearchResults = [];
          socialFriendSearchLoading = false;
          setFriendSearchNotice('Type a DJ name.', 'warn');
          renderProfile();
          setupEventListeners();
        }
        return;
      }
      const status = getFriendsOnlineStatus();
      const gateMessage = getFriendsGateMessage(status);
      if(gateMessage){
        socialFriendSearchResults = [];
        socialFriendSearchLoading = false;
        setFriendSearchNotice(gateMessage, 'warn');
        renderProfile();
        setupEventListeners();
        return;
      }
      setFriendSearchNotice('');
      searchProfilesForFriends();
    }

    async function fetchProfilesByUids(uids){
      const collection = getProfileCollection();
      if(!collection) return {};
      const unique = Array.from(new Set(uids)).filter(Boolean);
      const results = await Promise.all(unique.map(async (uid)=>{
        try{
          const doc = await collection.doc(uid).get();
          if(doc.exists) return [uid, normalizeProfileShape({ ...doc.data(), uid }, uid)];
        }catch(err){ console.warn('profile fetch failed', err); }
        return [uid, null];
      }));
      return results.reduce((acc, [uid, profile])=>{
        if(profile) acc[uid] = profile;
        return acc;
      }, {});
    }

    async function refreshFriendsData(force=false){
      if(!isOnlineProfileMode() || viewingProfile || friendsLoading) return;
      const now = Date.now();
      if(!force && now - friendsLoadedAt < 20000) return;
      friendsLoading = true;
      friendsError = '';
      try{
        const uid = firebaseAuth.currentUser.uid;
        const requestsRef = firestore.collection('friendRequests');
        const incomingSnap = await requestsRef.where('toUid','==',uid).where('status','==','pending').get();
        const outgoingSnap = await requestsRef.where('fromUid','==',uid).where('status','==','pending').get();
        const friendsSnap = await firestore.collection('friends').doc(uid).collection('list').get();
        const incoming = incomingSnap.docs.map(doc=>({ id: doc.id, ...doc.data() }));
        const outgoing = outgoingSnap.docs.map(doc=>({ id: doc.id, ...doc.data() }));
        const friendDocs = friendsSnap.docs.map(doc=>({ id: doc.id, ...doc.data() }));
        const profileMap = await fetchProfilesByUids([
          ...incoming.map(req=>req.fromUid),
          ...outgoing.map(req=>req.toUid),
          ...friendDocs.map(doc=>doc.friendUid || doc.id)
        ]);
        friendRequestsIncoming = incoming.map(req=>({ ...req, fromProfile: profileMap[req.fromUid] || null }));
        friendRequestsOutgoing = outgoing.map(req=>({ ...req, toProfile: profileMap[req.toUid] || null }));
        friendsList = friendDocs.map(doc=>({
          friendUid: doc.friendUid || doc.id,
          createdAt: doc.createdAt || null,
          profile: profileMap[doc.friendUid || doc.id] || null
        }));
        friendsLoadedAt = now;
      }catch(err){
        console.warn('friends refresh failed', err);
        friendsError = 'Unable to load friends right now.';
      } finally {
        friendsLoading = false;
        if(!viewingProfile){
          renderProfile();
          setupEventListeners();
        }
      }
    }

    function getFriendStatus(currentUid, otherUid){
      if(!currentUid || !otherUid) return 'none';
      if(currentUid === otherUid) return 'self';
      if(friendsList.some(item=> item.friendUid === otherUid)) return 'friends';
      if(friendRequestsIncoming.some(req=> req.fromUid === otherUid)) return 'incoming_pending';
      if(friendRequestsOutgoing.some(req=> req.toUid === otherUid)) return 'outgoing_pending';
      return 'none';
    }

    async function searchProfilesForFriends(){
      if(viewingProfile) return;
      const queryRaw = (socialFriendSearchQuery || socialFriendSearchTerm || '').trim();
      socialFriendSearchQuery = queryRaw;
      socialFriendSearchError = '';
      socialFriendSearchResults = [];
      if(!queryRaw){
        socialFriendSearchLoading = false;
        renderProfile();
        setupEventListeners();
        return;
      }
      socialFriendSearchLoading = true;
      setFriendSearchNotice('');
      renderProfile();
      setupEventListeners();
      try{
        const queryLower = normalizeUsernameLower(queryRaw);
        const collection = getProfileCollection();
        if(!collection) throw new Error('Profile collection unavailable');
        const resultsMap = {};
        const prefixQuery = async (field)=>{
          const snap = await collection
            .where(field, '>=', queryLower)
            .where(field, '<=', queryLower + '\uf8ff')
            .where('isPublic', '==', true)
            .limit(20)
            .get();
          snap.docs.forEach(doc=>{ resultsMap[doc.id] = normalizeProfileShape({ ...doc.data(), uid: doc.id }, doc.id); });
        };
        await Promise.all([
          prefixQuery('displayNameLower'),
          prefixQuery('usernameLower'),
          prefixQuery('djNameLower'),
          prefixQuery('searchNameLower')
        ]);
        const currentUid = firebaseAuth.currentUser.uid;
        socialFriendSearchResults = Object.values(resultsMap)
          .filter(profile=> profile?.uid !== currentUid)
          .slice(0, 20);
      }catch(err){
        console.error('[friends] search failed', err);
        socialFriendSearchError = 'Search failed. Try again later.';
      } finally {
        socialFriendSearchLoading = false;
        renderProfile();
        setupEventListeners();
      }
    }

    function getEditableDraftProfile(){
      if(viewingProfile) return null;
      draftProfile = draftProfile || cloneProfile(currentUser) || {};
      return draftProfile;
    }

    function updateDraftProfile(patch){
      const draft = getEditableDraftProfile();
      if(!draft) return null;
      Object.assign(draft, patch);
      return draft;
    }

    function updateDraftPersona(patch){
      const draft = getEditableDraftProfile();
      if(!draft) return null;
      const persona = ensurePersona(draft);
      const next = { ...persona, ...patch };
      draft.personaId = next.personaId;
      draft.personaTheme = next.personaTheme;
      draft.personaSeed = next.personaSeed;
      return next;
    }

    function persistPersonaSelection(persona){
      if(!persona || viewingProfile) return;
      persistPersonaToStorage(persona);
      const updated = { ...(currentUser || {}), ...persona };
      currentUser = updated;
      if(draftProfile) Object.assign(draftProfile, persona);
      saveUserProfileToBackend(updated).catch(err => console.warn('persona save failed', err));
    }

    function updatePersonaPreview(persona){
      const resolved = persona || ensurePersona(draftProfile || currentUser || {});
      const energy = (PERSONAS[resolved.personaId] || PERSONAS.turntablist).energy || 'âš¡';
      const preview = document.getElementById('profilePersonaPreview');
      if(preview) preview.innerHTML = `
        ${renderPersonaSVG({
          personaId: resolved.personaId,
          themeId: resolved.personaTheme,
          seed: resolved.personaSeed,
          size: 96
        })}
        <span class="persona-energy">${energy}</span>
      `;
      const builderPreview = document.getElementById('personaBuilderPreview');
      if(builderPreview) builderPreview.innerHTML = renderPersonaSVG({
        personaId: resolved.personaId,
        themeId: resolved.personaTheme,
        seed: resolved.personaSeed,
        size: 80
      });
      const seedLabel = document.getElementById('personaSeedLabel');
      if(seedLabel) seedLabel.textContent = resolved.personaSeed;
      const themeLabel = document.getElementById('profilePersonaThemeLabel');
      if(themeLabel){
        const themeName = getPersonaTheme(resolved.personaTheme).label;
        themeLabel.textContent = `Energy: ${themeName}`;
      }
    }

    function updatePersonaSelection(selector, activeValue, dataAttr){
      document.querySelectorAll(selector).forEach(btn=>{
        const key = dataAttr ? btn.dataset[dataAttr] : (btn.dataset.personaTheme || btn.dataset.personaId || btn.dataset.themeAccent);
        const isActive = key === activeValue;
        btn.classList.toggle('active', isActive);
      });
    }

    function applyThemeAccentPreview(accentId){
      const color = resolveThemeAccent(accentId);
      const root = document.querySelector('#profileView > div');
      if(root){
        root.style.setProperty('--profile-accent', color);
        root.style.setProperty('--profile-accent-glow', hexToRgba(color, 0.45));
      }
    }

    function updateBioCounter(text){
      const counter = document.getElementById('profileBioCounter');
      if(counter) counter.textContent = `${text.length}/${PROFILE_BIO_MAX}`;
    }

    function updateProfileErrorBanner(){
      const banner = document.getElementById('profileErrorBanner');
      if(!banner) return;
      banner.style.display = profileScriptError ? 'block' : 'none';
    }

    function notifyProfileScriptError(message, detail){
      if(profileScriptError) return;
      profileScriptError = { message, detail };
      console.error('[profile] script error', message, detail);
      updateProfileErrorBanner();
    }

    function bindUiDebugging(){
      if(!DEBUG_UI || debugUiBound) return;
      debugUiBound = true;
      document.addEventListener('click', safeOn('click', (e)=>{
        const target = getEventElement(e) || e.target;
        console.log('[debug][ui] CLICK', target);
        const probe = document.elementFromPoint(e.clientX, e.clientY);
        if(probe){
          const style = getComputedStyle(probe);
          console.log('[debug][ui] top element', probe, {
            pointerEvents: style.pointerEvents,
            zIndex: style.zIndex,
            position: style.position
          });
          let node = probe;
          while(node && node !== document.body){
            const nodeStyle = getComputedStyle(node);
            const zIndex = nodeStyle.zIndex;
            if(nodeStyle.pointerEvents === 'none' || (zIndex !== 'auto' && Number(zIndex) >= 1000)){
              console.log('[debug][ui] ancestor check', node, {
                pointerEvents: nodeStyle.pointerEvents,
                zIndex,
                position: nodeStyle.position
              });
            }
            node = node.parentElement;
          }
        }
      }, { action: 'ui-debug-click' }), true);
    }

    function openProfileEditor(){
      if(viewingProfile){
        view = 'profile';
        render();
        setupEventListeners();
        renderProfile();
        debugProfileLog('profile editor open blocked (view-only)');
        return;
      }
      profileEditMode = true;
      view = 'profile';
      render();
      setupEventListeners();
      renderProfile();
      debugProfileLog('profile editor opened');
    }
    window.openProfileEditor = openProfileEditor;

    function bindProfileHandlers(){
      if(profileHandlersBound || window.__profileEventsBound) return;
      const app = document.getElementById('app');
      if(!app) return;
      if(DEBUG_UI) console.log('[debug][profile] bindProfileHandlers');
      window.__profileEventsBound = true;
      app.addEventListener('click', safeOn('click', (e)=>{
        const toggle = closestFromEvent(e, '[data-profile-action="toggle-edit"]', { within: app });
        if(toggle){
          if(viewingProfile) return;
          profileEditMode = !profileEditMode;
          renderProfile();
          setupEventListeners();
          return;
        }
        const editTrigger = closestFromEvent(e, '[data-action="open-profile-editor"]', { within: app });
        if(editTrigger){
          debugProfileLog('persona edit click detected');
          openProfileEditor();
        }
      }, { action: 'profile-click' }));
      app.addEventListener('keydown', safeOn('keydown', (e)=>{
        if(e.key !== 'Enter' && e.key !== ' ') return;
        const trigger = closestFromEvent(e, '[data-action="open-profile-editor"]', { within: app });
        if(!trigger) return;
        e.preventDefault();
        debugProfileLog('persona edit keydown detected', { key: e.key });
        openProfileEditor();
      }, { action: 'profile-keydown' }));
      profileHandlersBound = true;
    }

    window.setPersonaTheme = (themeId)=>{
      const persona = updateDraftPersona({ personaTheme: themeId });
      if(!persona) return;
      updatePersonaPreview();
      updatePersonaSelection('[data-persona-theme]', themeId, 'personaTheme');
      persistPersonaSelection(persona);
      console.debug('[persona] set', { personaId: persona.personaId, theme: persona.personaTheme, seed: persona.personaSeed });
      renderProfile();
      setupEventListeners();
    };

    window.setPersonaId = (personaId)=>{
      const persona = updateDraftPersona({ personaId });
      if(!persona) return;
      updatePersonaPreview();
      updatePersonaSelection('[data-persona-id]', personaId, 'personaId');
      persistPersonaSelection(persona);
      console.debug('[persona] set', { personaId: persona.personaId, theme: persona.personaTheme, seed: persona.personaSeed });
    };

    window.randomizePersonaSeed = ()=>{
      const seed = Math.random().toString(36).slice(2, 10);
      const persona = updateDraftPersona({ personaSeed: seed });
      if(!persona) return;
      updatePersonaPreview();
      persistPersonaSelection(persona);
      console.debug('[persona] set', { personaId: persona.personaId, theme: persona.personaTheme, seed: persona.personaSeed });
    };

    window.setThemeAccent = (accentId)=>{
      updateDraftProfile({ themeAccent: accentId });
      applyThemeAccentPreview(accentId);
      updatePersonaSelection('[data-theme-accent]', accentId, 'themeAccent');
      const label = THEME_ACCENTS.find(item=>item.id === accentId)?.label || 'Custom';
      const labelEl = document.getElementById('profileThemeLabel');
      if(labelEl) labelEl.textContent = `Theme: ${label}`;
    };

    window.searchFriends = ()=>{
      handleFriendSearch(null, { explicit: true });
    };

    window.setFriendPanelTab = (tab)=>{
      friendPanelTab = tab === 'requests' ? 'requests' : 'friends';
      renderProfile();
      setupEventListeners();
    };

    window.sendFriendRequest = async (toUid)=>{
      if(!isOnlineProfileMode() || !toUid) return;
      const fromUid = firebaseAuth.currentUser.uid;
      if(fromUid === toUid) return;
      try{
        const requestId = `${fromUid}_${toUid}`;
        const serverTimestamp = firebase?.firestore?.FieldValue?.serverTimestamp;
        const reciprocalId = `${toUid}_${fromUid}`;
        const reciprocalRef = firestore.collection('friendRequests').doc(reciprocalId);
        const reciprocalSnap = await reciprocalRef.get();
        if(reciprocalSnap.exists && reciprocalSnap.data()?.status === 'pending'){
          await acceptFriendRequest(reciprocalId, toUid);
          return;
        }
        await firestore.collection('friendRequests').doc(requestId).set({
          fromUid,
          toUid,
          status: 'pending',
          createdAt: serverTimestamp ? serverTimestamp() : new Date().toISOString()
        }, { merge: true });
        await refreshFriendsData(true);
        await searchProfilesForFriends();
      }catch(err){
        console.warn('friend request failed', err);
        socialFriendSearchError = 'Friend request failed.';
        renderProfile(); setupEventListeners();
      }
    };

    window.acceptFriendRequest = async (requestId, fromUid)=>{
      if(!isOnlineProfileMode()) return;
      try{
        const uid = firebaseAuth.currentUser.uid;
        const serverTimestamp = firebase?.firestore?.FieldValue?.serverTimestamp;
        const batch = firestore.batch();
        const requestRef = firestore.collection('friendRequests').doc(requestId);
        batch.update(requestRef, { status: 'accepted' });
        const reciprocalId = `${uid}_${fromUid}`;
        const reciprocalRef = firestore.collection('friendRequests').doc(reciprocalId);
        const reciprocalSnap = await reciprocalRef.get();
        if(reciprocalSnap.exists && reciprocalSnap.data()?.status === 'pending'){
          batch.update(reciprocalRef, { status: 'accepted' });
        }
        const myFriendRef = firestore.collection('friends').doc(uid).collection('list').doc(fromUid);
        const theirFriendRef = firestore.collection('friends').doc(fromUid).collection('list').doc(uid);
        batch.set(myFriendRef, { friendUid: fromUid, createdAt: serverTimestamp ? serverTimestamp() : new Date().toISOString() }, { merge: true });
        batch.set(theirFriendRef, { friendUid: uid, createdAt: serverTimestamp ? serverTimestamp() : new Date().toISOString() }, { merge: true });
        await batch.commit();
        await refreshFriendsData(true);
        renderProfile(); setupEventListeners();
      }catch(err){
        console.warn('accept request failed', err);
        friendsError = 'Unable to accept request.';
        renderProfile(); setupEventListeners();
      }
    };

    window.rejectFriendRequest = async (requestId)=>{
      if(!isOnlineProfileMode()) return;
      try{
        await firestore.collection('friendRequests').doc(requestId).set({ status: 'declined' }, { merge: true });
        await refreshFriendsData(true);
        renderProfile(); setupEventListeners();
      }catch(err){
        console.warn('reject request failed', err);
        friendsError = 'Unable to reject request.';
        renderProfile(); setupEventListeners();
      }
    };

    window.cancelFriendRequest = async (requestId)=>{
      if(!isOnlineProfileMode()) return;
      try{
        await firestore.collection('friendRequests').doc(requestId).set({ status: 'canceled' }, { merge: true });
        await refreshFriendsData(true);
        renderProfile(); setupEventListeners();
      }catch(err){
        console.warn('cancel request failed', err);
        friendsError = 'Unable to cancel request.';
        renderProfile(); setupEventListeners();
      }
    };

    window.removeFriend = async (friendUid)=>{
      if(!isOnlineProfileMode() || !friendUid) return;
      try{
        const uid = firebaseAuth.currentUser.uid;
        const batch = firestore.batch();
        const myFriendRef = firestore.collection('friends').doc(uid).collection('list').doc(friendUid);
        const theirFriendRef = firestore.collection('friends').doc(friendUid).collection('list').doc(uid);
        batch.delete(myFriendRef);
        batch.delete(theirFriendRef);
        await batch.commit();
        await refreshFriendsData(true);
        renderProfile(); setupEventListeners();
      }catch(err){
        console.warn('remove friend failed', err);
        friendsError = 'Unable to remove friend.';
        renderProfile(); setupEventListeners();
      }
    };

    async function refreshLiveNowUsers(){
      if(liveNowLoading) return;
      liveNowLoading = true;
      liveNowError = '';
      try{
        liveNowUsers = await getLiveUsers();
        liveNowLoadedAt = Date.now();
      }catch(err){
        liveNowError = 'Unable to load live profiles right now.';
      }finally{
        liveNowLoading = false;
        renderProfile();
        setupEventListeners();
      }
    }

    function ensureLiveNowLoaded(){
      const stale = Date.now() - liveNowLoadedAt > 30000;
      if((!liveNowLoadedAt || stale) && !liveNowLoading){
        refreshLiveNowUsers();
      }
    }

    async function ensureRatingLoaded(streamerUid){
      if(!streamerUid || ratingLoadedFor === streamerUid || ratingLoading) return;
      ratingLoadedFor = streamerUid;
      ratingLoading = true;
      ratingDraft = { stars: 0, tags: [], comment: '', hasExisting: false };
      if(!currentUser){
        ratingLoading = false;
        return;
      }
      try{
        const existing = await getExistingRating(streamerUid, currentUser.uid || currentUser.username);
        if(existing){
          ratingDraft = {
            stars: Number(existing.stars) || 0,
            tags: Array.isArray(existing.tags) ? existing.tags : [],
            comment: existing.comment || '',
            hasExisting: true
          };
        }
      }catch(err){
        console.warn('rating preload failed', err);
      }finally{
        ratingLoading = false;
        renderProfile();
        setupEventListeners();
      }
    }

    function updateRatingStarsUI(){
      const starRow = document.getElementById('ratingStarRow');
      if(!starRow) return;
      starRow.querySelectorAll('[data-star]').forEach(btn=>{
        const starVal = Number(btn.dataset.star);
        if(starVal <= ratingDraft.stars){
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
        btn.textContent = starVal <= ratingDraft.stars ? 'â˜…' : 'â˜†';
      });
    }

    function updateRatingTagsUI(){
      const tagRow = document.getElementById('ratingTagRow');
      if(!tagRow) return;
      tagRow.querySelectorAll('[data-tag]').forEach(btn=>{
        const tag = btn.dataset.tag;
        if(ratingDraft.tags.includes(tag)){
          btn.classList.add('border-emerald-400/60','bg-emerald-500/20','text-emerald-100');
          btn.classList.remove('border-white/10','bg-white/5','text-gray-200');
        } else {
          btn.classList.remove('border-emerald-400/60','bg-emerald-500/20','text-emerald-100');
          btn.classList.add('border-white/10','bg-white/5','text-gray-200');
        }
      });
    }

    window.setRatingStar = (value)=>{
      ratingDraft.stars = Number(value) || 0;
      updateRatingStarsUI();
    };

    window.toggleRatingTag = (tag)=>{
      if(!RATING_TAGS.includes(tag)) return;
      if(ratingDraft.tags.includes(tag)){
        ratingDraft.tags = ratingDraft.tags.filter(t=> t !== tag);
      } else {
        ratingDraft.tags = [...ratingDraft.tags, tag];
      }
      updateRatingTagsUI();
    };

    function openFriendProfile(profile){
      if(!profile) return;
      viewingProfile = normalizeProfileShape(profile, profile.uid || profile.username || '');
      profileOwnedSearch = '';
      resetPage(profileOwnedPager);
      setProfileQueryParam(viewingProfile?.username || viewingProfile?.uid || '');
      friendLookupResults = [];
      friendLookupError = '';
      ratingStatusMessage = '';
      ratingStatusTone = 'info';
      ratingLoadedFor = '';
      ratingDraft = { stars: 0, tags: [], comment: '', hasExisting: false };
      view = 'profile';
      render();
      setupEventListeners();
      updateOwnedCount();
    }

    window.selectFriendProfile = (username)=>{
      const pick = friendLookupResults.find(p=>p.username === username || p.uid === username);
      if(!pick){ friendLookupError = 'Profile not available anymore.'; renderProfile(); setupEventListeners(); return; }
      openFriendProfile(pick);
    };

    async function viewFriendProfile(){
      const input = (document.getElementById('friendSearchInput')?.value || '').trim();
      friendSearchTerm = input;
      friendLookupError = '';
      friendLookupResults = [];
      if(!firebaseAuth?.currentUser){
        friendLookupError = 'Sign in required to view other profiles.';
        renderProfile(); setupEventListeners(); return;
      }
      if(!input){ friendLookupError = 'Enter a DJ name or username to view.'; renderProfile(); setupEventListeners(); return; }
      const normalizedInput = normalizeUsernameLower(input);
      const tryMatches = async (field, value)=> await fetchProfilesByField(field, value);
      try{
        const usernameHits = await tryMatches('usernameLower', normalizedInput);
        if(usernameHits.length === 1) return openFriendProfile(usernameHits[0]);
        if(usernameHits.length > 1){ friendLookupResults = usernameHits; renderProfile(); setupEventListeners(); return; }

        const djHits = await tryMatches('djNameLower', normalizedInput);
        if(djHits.length === 1) return openFriendProfile(djHits[0]);
        if(djHits.length > 1){ friendLookupResults = djHits; renderProfile(); setupEventListeners(); return; }

        if(input.includes('@')){
          const emailHits = await tryMatches('email');
          if(emailHits.length === 1) return openFriendProfile(emailHits[0]);
          if(emailHits.length > 1){ friendLookupResults = emailHits; renderProfile(); setupEventListeners(); return; }
        }
        friendLookupError = `No profile found for â€˜${input}â€™`;
      }catch(err){
        friendLookupError = 'Lookup failed. Please try again.';
      }
      renderProfile();
      setupEventListeners();
    }

    window.viewLiveProfile = async (username)=>{
      if(!username) return;
      if(!firebaseAuth?.currentUser){
        friendLookupError = 'Sign in required to view other profiles.';
        renderProfile(); setupEventListeners(); return;
      }
      const profile = await loadProfileForViewing(username);
      if(profile){
        openFriendProfile(profile);
      } else {
        friendLookupError = `No profile found for â€˜${username}â€™`;
        renderProfile(); setupEventListeners();
      }
    };

    window.submitRating = async ()=>{
      ratingStatusMessage = '';
      ratingStatusTone = 'info';
      if(!currentUser){
        ratingStatusMessage = 'Sign in required to rate this DJ.';
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      if(!viewingProfile){
        ratingStatusMessage = 'Open a profile to rate.';
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      const streamerUid = viewingProfile.uid || viewingProfile.username;
      if(!streamerUid){
        ratingStatusMessage = 'Missing streamer profile.';
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      const raterUid = currentUser.uid || currentUser.username;
      const stars = Number(ratingDraft.stars) || 0;
      if(stars < 1 || stars > 5){
        ratingStatusMessage = 'Select a 1â€“5 star rating.';
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      const comment = (ratingDraft.comment || '').trim();
      if(comment.length > RATING_MAX_COMMENT){
        ratingStatusMessage = `Comment too long. Max ${RATING_MAX_COMMENT} characters.`;
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      const tags = Array.isArray(ratingDraft.tags) ? ratingDraft.tags.filter(tag=> RATING_TAGS.includes(tag)) : [];
      if(tags.length !== (ratingDraft.tags || []).length){
        ratingStatusMessage = 'Remove invalid tags before submitting.';
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      const rateCheck = checkRatingUpdateLimit(streamerUid, raterUid);
      if(!rateCheck.allowed){
        const minutes = Math.ceil((rateCheck.retryAt - Date.now()) / 60000);
        ratingStatusMessage = `Too many updates. Try again in ${minutes} min.`;
        ratingStatusTone = 'error';
        renderProfile(); setupEventListeners(); return;
      }
      ratingSubmitting = true;
      renderProfile(); setupEventListeners();
      try{
        const previousRating = await getExistingRating(streamerUid, raterUid);
        const updatedAt = new Date().toISOString();
        const ratingPayload = { stars, tags, comment, updatedAt };
        if(firestore){
          const serverTimestamp = firebase?.firestore?.FieldValue?.serverTimestamp;
          const collection = getProfileCollection();
          if(!collection) throw new Error('Profile collection unavailable');
          await collection.doc(streamerUid).collection('ratings').doc(raterUid)
            .set({ ...ratingPayload, updatedAt: serverTimestamp ? serverTimestamp() : updatedAt }, { merge: true });
          const profileDoc = await collection.doc(streamerUid).get();
          const baseProfile = profileDoc.exists ? normalizeProfileShape(profileDoc.data(), streamerUid) : viewingProfile;
          const aggregates = updateAggregatesWithRating(baseProfile || {}, previousRating?.stars, stars);
          await collection.doc(streamerUid).set(aggregates, { merge: true });
          viewingProfile = viewingProfile && (viewingProfile.username === streamerUid || viewingProfile.uid === streamerUid)
            ? { ...viewingProfile, ...aggregates }
            : viewingProfile;
        } else {
          const ratings = getLocalRatings();
          ratings[streamerUid] = ratings[streamerUid] || {};
          ratings[streamerUid][raterUid] = ratingPayload;
          saveLocalRatings(ratings);
          const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');
          const existingProfile = normalizeProfileShape(profiles[streamerUid] || viewingProfile || { username: streamerUid }, streamerUid);
          const aggregates = updateAggregatesWithRating(existingProfile || {}, previousRating?.stars, stars);
          const mergedProfile = { ...(profiles[streamerUid] || {}), ...existingProfile, ...aggregates };
          profiles[streamerUid] = mergedProfile;
          localStorage.setItem('userProfiles', JSON.stringify(profiles));
          if(viewingProfile && (viewingProfile.username === streamerUid || viewingProfile.uid === streamerUid)){
            viewingProfile = { ...viewingProfile, ...aggregates };
          }
        }
        recordRatingUpdate(streamerUid, raterUid, rateCheck.updates || [], rateCheck.logs || {});
        ratingDraft.hasExisting = true;
        ratingStatusMessage = 'Rating saved!';
        ratingStatusTone = 'success';
        refreshLiveNowUsers();
      }catch(err){
        console.error('rating submit failed', err);
        ratingStatusMessage = 'Rating failed. Please try again.';
        ratingStatusTone = 'error';
      }finally{
        ratingSubmitting = false;
        renderProfile();
        setupEventListeners();
      }
    };

    function setProfileQueryParam(value){
      const params = new URLSearchParams(window.location.search);
      if(value) params.set('profile', value); else params.delete('profile');
      const query = params.toString();
      const newUrl = `${location.pathname}${query ? `?${query}` : ''}${location.hash}`;
      window.history.replaceState({}, '', newUrl);
    }
    function clearViewedProfile(){
      viewingProfile = null;
      profileOwnedSearch = '';
      resetPage(profileOwnedPager);
      profileOwnedPagerOwnerKey = '';
      friendLookupResults = [];
      friendLookupError = '';
      friendSearchTerm = '';
      ratingStatusMessage = '';
      ratingStatusTone = 'info';
      ratingLoadedFor = '';
      ratingDraft = { stars: 0, tags: [], comment: '', hasExisting: false };
      setProfileQueryParam(null);
    }

    // --------------------- UI: Landing / Auth ------------------------
    function showLandingPage(){
      document.getElementById('app').innerHTML = `
        <div class="min-h-screen py-12 px-6">
          <div class="max-w-6xl mx-auto">
            <div class="text-center mb-16">
              <div class="flex justify-center mb-6">
                <div class="w-32 h-32 bg-gradient-to-br from-pink-500 via-purple-500 to-cyan-500 rounded-full flex items-center justify-center text-6xl vinyl-spin">ðŸŽ§</div>
              </div>
              <h1 class="text-5xl md:text-6xl font-bold text-white graffiti-text mb-4">${BRAND.APP_NAME.toUpperCase()}</h1>
              <p class="text-xl md:text-2xl text-cyan-300 mb-6">Create Epic Mashups & DJ Like a Pro on the Jam Stage!</p>
              <div class="mt-6">
                <button onclick="hideLanding()" class="px-8 py-4 bg-gradient-to-r from-pink-500 via-purple-500 to-cyan-500 rounded-xl font-bold text-white text-xl md:text-2xl bounce-icon shadow-lg">ðŸŽµ START MIXING NOW</button>
              </div>
            </div>
            <div class="bg-black/60 backdrop-blur-xl border border-pink-500/30 rounded-2xl p-6 md:p-8 mb-12">
              <div class="flex flex-col lg:flex-row items-center gap-8">
                <div class="flex-shrink-0">
                  <div class="w-28 h-28 camelot-wheel rounded-full" style="background: conic-gradient(from 0deg,#FF6B9D 0deg 30deg,#FFA07A 30deg 60deg,#FFD700 60deg 90deg,#98D8C8 90deg 120deg,#6BCB77 120deg 150deg,#4D96FF 150deg 180deg,#9D4EDD 180deg 210deg,#E84A5F 210deg 240deg,#00D9FF 240deg 270deg,#FFA400 270deg 300deg,#FE6D73 300deg 330deg,#A8E6CF 330deg 360deg); width:140px;height:140px;border-radius:50%;box-shadow:0 0 40px rgba(0,217,255,0.2)"></div>
                  <p class="text-center text-xs text-cyan-300 mt-4">The Camelot Wheel in Action</p>
                </div>
                <div class="flex-1">
                  <h2 class="text-2xl md:text-3xl font-bold text-white mb-4 graffiti-text">ðŸŽ›ï¸ The Secret: The Camelot Wheel</h2>
                  <p class="text-gray-300 mb-4 text-base md:text-lg">Professional DJs use the Camelot Wheel to create seamless mashups. It's a color-coded system that shows which songs are harmonically compatible.</p>
                  <div class="space-y-3 text-gray-300 text-sm md:text-base">
                    <div class="flex items-start gap-3"><span class="text-2xl">âœ…</span><div><strong class="text-cyan-300">Same Number = Perfect Match!</strong><br/><span class="text-sm">Example: 8B â†’ 8B</span></div></div>
                    <div class="flex items-start gap-3"><span class="text-2xl">âœ…</span><div><strong class="text-cyan-300">A/B Switch = Energy Shift</strong><br/><span class="text-sm">Example: 8B â†’ 8A</span></div></div>
                    <div class="flex items-start gap-3"><span class="text-2xl">âœ…</span><div><strong class="text-cyan-300">Â±1 Number = Smooth Blend</strong><br/><span class="text-sm">Example: 8B â†’ 9B or 7B</span></div></div>
                  </div>
                </div>
              </div>
            </div>

            <div class="text-center">
              <button onclick="hideLanding()" class="px-8 md:px-12 py-4 md:py-5 bg-gradient-to-r from-pink-500 via-purple-500 to-cyan-500 rounded-xl font-bold text-white text-2xl md:text-3xl shadow-2xl">ðŸŽµ LET'S MIX!</button>
            </div>
          </div>
        </div>
      `;
    }
    window.hideLanding = () => { localStorage.setItem('hasSeenLanding','true'); checkAuth(); };

    // -------------------- Login / Profile handlers ---------------------
    function showLoginScreen(){
      // default auth mode
      setTimeout(()=>{ try{ if(window.setAuthMode) window.setAuthMode('signin'); }catch(e){} }, 50);

      document.getElementById('app').innerHTML = `
        <div class="min-h-screen flex items-center justify-center p-6">
          <div class="max-w-md w-full">
            <div class="text-center mb-8">
              <div class="w-24 h-24 bg-gradient-to-br from-pink-500 via-purple-500 to-cyan-500 rounded-full flex items-center justify-center text-5xl mx-auto mb-4 vinyl-spin">ðŸŽ§</div>
              <h1 class="text-4xl font-bold text-white graffiti-text mb-2">${BRAND.APP_NAME.toUpperCase()}</h1>
              <p class="text-cyan-300">Your Personal DJ Profile</p>
            </div>

            <div class="bg-black/60 backdrop-blur-xl border border-cyan-500/30 rounded-2xl p-8 shadow-2xl">
              <h2 class="text-2xl font-bold text-white mb-6 text-center">Sign In / Create Profile</h2>
              ${!firebaseEnabled ? `<div class="mb-4 p-3 rounded-lg bg-yellow-500/20 border border-yellow-500/50 text-yellow-100 text-sm text-center">Firebase not configured â€” using local profiles.</div>` : ''}

              ${firebaseEnabled ? `
                <div class="mb-5">
                  <div class="flex gap-2 bg-black/30 p-1 rounded-xl border border-cyan-500/20">
                    <button type="button" id="tabSignIn" onclick="setAuthMode('signin')" class="flex-1 px-3 py-2 rounded-lg font-bold text-white bg-white/10">Already a member</button>
                    <button type="button" id="tabSignUp" onclick="setAuthMode('signup')" class="flex-1 px-3 py-2 rounded-lg font-bold text-white opacity-80">Sign up</button>
                  </div>
                  <p class="text-xs text-gray-300 mt-3 text-center">
                    Cloud sync works after you create an account once. Sign in to access your profile and owned songs.
                  </p>
                </div>

                <form onsubmit="handleFirebaseAuth(event)" class="space-y-4" autocomplete="on">
                  <input type="hidden" id="authMode" value="signin" />

                  <div>
                    <label class="block text-sm text-gray-300 mb-2">Email</label>
                    <input id="email" type="email" required placeholder="you@example.com"
                      class="w-full px-4 py-3 bg-black/40 border border-gray-600 rounded-lg text-white" />
                  </div>

                  <div>
                    <label class="block text-sm text-gray-300 mb-2">Password</label>
                    <input id="password" type="password" required minlength="6" placeholder="password"
                      class="w-full px-4 py-3 bg-black/40 border border-gray-600 rounded-lg text-white" />
                  </div>

                  <div id="confirmWrap" style="display:none">
                    <label class="block text-sm text-gray-300 mb-2">Confirm Password</label>
                    <input id="passwordConfirm" type="password" placeholder="confirm password"
                      class="w-full px-4 py-3 bg-black/40 border border-gray-600 rounded-lg text-white" />
                    <p class="text-xs text-gray-400 mt-2">Tip: use at least 6 characters.</p>
                  </div>

                  <div>
                    <button type="submit" id="authSubmit"
                      class="w-full px-4 py-3 bg-gradient-to-r from-pink-500 to-purple-500 rounded-lg font-bold text-white">
                      Sign In
                    </button>
                  </div>

                  <div class="text-center">
                    <button type="button" onclick="forgotPassword()" class="text-xs text-cyan-300 hover:underline">Forgot password?</button>
                  </div>
                  <div id="authError" class="mt-3 text-sm text-red-200 bg-red-900/50 border border-red-500/60 rounded-lg p-3" style="display:none"></div>
                </form>
              ` : `
                <form id="localAuthForm" class="space-y-4" autocomplete="off">
                  <div><label class="block text-sm text-gray-300 mb-2">Username</label><input id="username" type="text" required minlength="2" maxlength="24" placeholder="Enter your username" class="w-full px-4 py-3 bg-black/40 border border-gray-600 rounded-lg text-white" /></div>
                  <div><label class="block text-sm text-gray-300 mb-2">DJ Name (optional)</label><input id="djName" type="text" maxlength="32" placeholder="e.g., DJ Spinner" class="w-full px-4 py-3 bg-black/40 border border-gray-600 rounded-lg text-white" /></div>
                  <button type="submit" id="enterMixBtn" class="w-full px-6 py-3 bg-gradient-to-r from-pink-500 via-purple-500 to-cyan-500 rounded-lg font-bold text-white text-lg">ðŸŽµ Enter the Mix</button>
                  <div id="localAuthError" class="mt-3 text-sm text-red-200 bg-red-900/50 border border-red-500/60 rounded-lg p-3" style="display:none"></div>
                </form>
              `}
              <div class="mt-6 pt-6 border-t border-gray-700">
                <p class="text-xs text-gray-400 text-center">âš ï¸ Epic Games doesn't share inventory; mark songs you own manually.</p>
              </div>
            </div>
          </div>
        </div>
      `;
      const localForm = document.getElementById('localAuthForm');
      if(localForm && !localForm.dataset.bound){
        localForm.dataset.bound = 'true';
        localForm.addEventListener('submit', onEnterMixSubmit);
      }
    }

      // -------------------- Firebase Auth UI helpers ---------------------
    window.setAuthMode = (mode) => {
      const m = (mode === 'signup') ? 'signup' : 'signin';
      const authMode = document.getElementById('authMode');
      if (!authMode) return;
      authMode.value = m;

      const tabIn = document.getElementById('tabSignIn');
      const tabUp = document.getElementById('tabSignUp');
      const confirmWrap = document.getElementById('confirmWrap');
      const submit = document.getElementById('authSubmit');
      const confirmInput = document.getElementById('passwordConfirm');

      if (m === 'signup') {
        if (tabUp) { tabUp.classList.add('bg-white/10'); tabUp.classList.remove('opacity-80'); }
        if (tabIn) { tabIn.classList.remove('bg-white/10'); tabIn.classList.add('opacity-80'); }
        if (confirmWrap) confirmWrap.style.display = 'block';
        if (submit) submit.textContent = 'Create Account';
        if (confirmInput) { confirmInput.required = true; confirmInput.setAttribute('minlength','6'); confirmInput.value = ''; }
      } else {
        if (tabIn) { tabIn.classList.add('bg-white/10'); tabIn.classList.remove('opacity-80'); }
        if (tabUp) { tabUp.classList.remove('bg-white/10'); tabUp.classList.add('opacity-80'); }
        if (confirmWrap) confirmWrap.style.display = 'none';
        if (submit) submit.textContent = 'Sign In';
        if (confirmInput) { confirmInput.required = false; confirmInput.value = ''; }
      }
    };

    function getLocalDeviceId(){
      let localId = localStorage.getItem('localDeviceUserId');
      if(!localId){
        localId = 'local_' + Math.random().toString(36).slice(2,10);
        localStorage.setItem('localDeviceUserId', localId);
      }
      return localId;
    }

    function slugifyLocalUsername(value){
      return (value || '')
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9 _-]+/g,'')
        .replace(/\s+/g,'-')
        .replace(/-+/g,'-')
        .replace(/^[-_]+|[-_]+$/g,'');
    }

    function getActiveProfile(){
      if(currentUser) return currentUser;
      const activeUid = localStorage.getItem('activeProfileUid');
      const cachedProfile = window.profileStore?.readLocalProfileCache?.() || null;
      if(cachedProfile && window.profileStore?.hasMeaningfulProfileData?.(cachedProfile)){
        const ownedCache = cachedProfile.uid ? readOwnedTracksCache(cachedProfile.uid) : null;
        if(ownedCache?.trackIds?.length){
          cachedProfile.ownedTracks = ownedCache.trackIds;
        }
        const fallbackUid = cachedProfile.uid || activeUid || getLocalDeviceId();
        return normalizeProfileShape({
          ...cachedProfile,
          uid: fallbackUid,
          username: cachedProfile.username || cachedProfile.djName || 'Guest',
          djName: cachedProfile.djName || cachedProfile.username || 'Guest'
        }, fallbackUid);
      }
      const localProfileRaw = localStorage.getItem('localProfile');
      if(localProfileRaw){
        try{
          const parsed = JSON.parse(localProfileRaw);
          const normalized = normalizeProfileShape(parsed, parsed?.uid || activeUid);
          if(normalized && (!activeUid || normalized.uid === activeUid)) return normalized;
        }catch(err){ console.warn('[auth] localProfile parse failed', err); }
      }
      const savedId = activeUid || localStorage.getItem('currentUser');
      if(!savedId) return null;
      try{
        const profiles = JSON.parse(localStorage.getItem('userProfiles')||'{}');
        if(profiles[savedId]) return normalizeProfileShape(profiles[savedId], savedId);
      }catch(err){ console.warn('[auth] stored profiles parse failed', err); }
      return null;
    }

    async function enterAppWithProfile(profile, { loadEpic = false, loadOverrides = false, skipPersist = false } = {}){
      if(!profile) return;
      currentUser = applyAdminFlag(profile);
      justEnteredProfile = true;
      await persistAdminFlagIfNeeded(profile, currentUser);
      applyPreferencesFromProfile(currentUser);
      loadSandboxState();
      loadOverridesFromStorage();
      if(loadOverrides){
        await loadUserOverridesFromBackend();
      }
      const incomingOwned = normalizeOwnedList(currentUser.ownedTracks || []);
      if(incomingOwned.length){
        ownedTracks = incomingOwned;
      } else if(!ownedTracks.length) {
        ownedTracks = [];
      }
      if(!firebaseAuth?.currentUser && ownedLibraryState.phase === 'idle'){
        setOwnedLibraryStatus({
          phase: 'ready',
          source: ownedTracks.length ? 'cache' : 'local',
          message: ownedTracks.length ? 'Library loaded (Cached)' : 'Library loaded (Local)'
        });
      }
      setlist = normalizeSetlistIds(currentUser.setlist || currentUser.setlistIds || currentUser.setlists || []);
      bandMembers = currentUser.bandMembers || [];
      genreOverrides = currentUser.genreOverrides || {};
      refreshDraftProfileFromCurrentUser();
      if(loadEpic){
        await fetchEpicLinkStatus();
      }
      if(currentUser?.uid || currentUser?.username){
        const profileKey = currentUser.uid || currentUser.username;
        localStorage.setItem('currentUser', profileKey);
      }
      if(currentUser?.mode === 'local' || currentUser?.uid?.startsWith('local:')){
        localStorage.setItem('localProfile', JSON.stringify(currentUser));
        localStorage.setItem('activeProfileUid', currentUser.uid);
        localStorage.setItem('isAuthed', 'true');
      }
      const profiles = JSON.parse(localStorage.getItem('userProfiles')||'{}');
      if(currentUser.username) profiles[currentUser.username] = { ...(profiles[currentUser.username]||{}), ...currentUser };
      if(currentUser.uid) profiles[currentUser.uid] = { ...(profiles[currentUser.uid]||{}), ...currentUser };
      localStorage.setItem('userProfiles', JSON.stringify(profiles));
      view = 'browser';
      if(!skipPersist){
        await persistCurrentUserProfile();
      }
      await maybeLoadSharedProfile();
      loadSongs();
      await loadRemoteConfig();
    }

    function setLocalAuthError(message){
      const errorBox = document.getElementById('localAuthError');
      if(errorBox){
        errorBox.textContent = message;
        errorBox.style.display = message ? 'block' : 'none';
      }
    }

    async function onEnterMixSubmit(event){
      event.preventDefault();
      console.debug('[auth] Enter Mix clicked');
      const submitBtn = document.getElementById('enterMixBtn');
      const originalLabel = submitBtn?.textContent || 'ðŸŽµ Enter the Mix';
      if(submitBtn){
        submitBtn.disabled = true;
        submitBtn.classList.add('opacity-70');
        submitBtn.textContent = 'Entering...';
      }
      const buttonTimeout = setTimeout(() => {
        if(submitBtn){
          submitBtn.disabled = false;
          submitBtn.classList.remove('opacity-70');
          submitBtn.textContent = originalLabel;
        }
      }, 300);
      setLocalAuthError('');
      try{
        const usernameInput = document.getElementById('username');
        const djNameInput = document.getElementById('djName');
        const username = (usernameInput?.value || '').trim();
        const djNameRaw = (djNameInput?.value || '').trim();
        if(username.length < 2){
          setLocalAuthError('Username must be at least 2 characters.');
          return;
        }
        if(username.length > 24){
          setLocalAuthError('Username must be 24 characters or fewer.');
          return;
        }
        if(!/^[A-Za-z0-9 _-]+$/.test(username)){
          setLocalAuthError('Username can only use letters, numbers, spaces, underscores, or hyphens.');
          return;
        }
        if(djNameRaw.length > 32){
          setLocalAuthError('DJ Name must be 32 characters or fewer.');
          return;
        }
        const slug = slugifyLocalUsername(username);
        if(!slug){
          setLocalAuthError('Choose a username with letters or numbers.');
          return;
        }
        const existingProfile = await loadUserProfile(username);
        const baseProfile = existingProfile || {
          ownedTracks: [],
          setlist: [],
          bandMembers: [],
          genreOverrides: {},
          streamUrl: '',
          isLive: false,
          liveStartedAt: null,
          avgRating: 0,
          ratingCount: 0,
          ratingBreakdown: { 1:0, 2:0, 3:0, 4:0, 5:0 },
          bio: '',
          themeAccent: THEME_ACCENTS[0].id,
          personaId: 'turntablist',
          personaTheme: 'neonPop',
          personaSeed: username,
          isPublic: true,
          allowFriendRequests: true,
          usernameLower: normalizeUsernameLower(username),
          djNameLower: normalizeUsernameLower(djNameRaw || username),
          searchNameLower: normalizeUsernameLower(username),
          searchTokens: buildSearchTokens(username),
          isAdmin: false,
          tour: {}
        };
        const now = Date.now();
        const profile = {
          ...baseProfile,
          uid: baseProfile.uid || `local:${slug}`,
          username,
          djName: djNameRaw || username,
          createdAt: baseProfile.createdAt || now,
          updatedAt: now,
          mode: 'local'
        };
        await enterAppWithProfile(profile);
      }catch(err){
        console.error('[auth] enter failed', err);
        setLocalAuthError('Couldnâ€™t enter the mix. Check console for details.');
      }finally{
        clearTimeout(buttonTimeout);
        if(submitBtn){
          submitBtn.disabled = false;
          submitBtn.classList.remove('opacity-70');
          submitBtn.textContent = originalLabel;
        }
      }
    }

    window.continueOffline = async () => {
      if(firebaseEnabled){
        alert('Sign in is required while cloud sync is enabled.');
        return;
      }
      const username = getLocalDeviceId();
        const offlineProfile = {
          username,
          djName: username,
          ownedTracks: ownedTracks || [],
          setlist: [],
        bandMembers: bandMembers || [],
        genreOverrides: genreOverrides || {},
        streamUrl: '',
        isLive: false,
        liveStartedAt: null,
        avgRating: 0,
        ratingCount: 0,
        ratingBreakdown: { 1:0, 2:0, 3:0, 4:0, 5:0 },
        bio: '',
        themeAccent: THEME_ACCENTS[0].id,
        personaId: 'turntablist',
        personaTheme: 'neonPop',
        personaSeed: username,
        isPublic: true,
        allowFriendRequests: true,
        usernameLower: normalizeUsernameLower(username),
        djNameLower: normalizeUsernameLower(username),
        searchNameLower: normalizeUsernameLower(username),
        searchTokens: buildSearchTokens(username),
        isAdmin: false
      };
      currentUser = applyAdminFlag(offlineProfile);
      await persistAdminFlagIfNeeded(offlineProfile, currentUser);
      localStorage.setItem('currentUser', currentUser.username);
      refreshDraftProfileFromCurrentUser();
      try { await persistCurrentUserProfile(); } catch(err){ console.warn('offline profile save failed', err); }
      loadSongs();
    };

    window.forgotPassword = async () => {
      if (!firebaseAuth) return alert('Firebase not ready yet.');
      const email = (document.getElementById('email')?.value || '').trim();
      if (!email) return alert('Type your email first, then click "Forgot password?"');
      try {
        await firebaseAuth.sendPasswordResetEmail(email);
        alert('Password reset email sent (check inbox/spam).');
      } catch (e) {
        alert('Could not send reset email: ' + (e.message || e));
      }
    };

    function getOAuthCallbackUrl(provider){
      if(provider === 'epic') return `${window.location.origin}/oauth-callback.html?oauth=epic`;
      return window.location.origin;
    }

    function cacheEpicLink(linkData){
      if(!firebaseAuth?.currentUser) return;
      try{
        const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');
        const uid = firebaseAuth.currentUser.uid;
        const existing = profiles[uid] || {};
        if(linkData){
          profiles[uid] = { ...existing, oauth: { ...(existing.oauth || {}), epic: linkData } };
        } else if(existing.oauth && existing.oauth.epic){
          delete existing.oauth.epic;
          profiles[uid] = { ...existing, oauth: { ...(existing.oauth || {}) } };
        }
        localStorage.setItem('userProfiles', JSON.stringify(profiles));
      }catch(e){ /* non-fatal cache failure */ }
    }

    async function fetchEpicLinkStatus(){
      if(!firebaseAuth?.currentUser) return null;
      let idToken;
      try{ idToken = await firebaseAuth.currentUser.getIdToken(); } catch(e){ return null; }
      try{
        const resp = await fetch('/api/oauth/epic/status', {
          headers: { 'Authorization': `Bearer ${idToken}` },
          credentials: 'include'
        });
        if(resp.status === 401){
          currentUser = currentUser || {};
          if(currentUser.oauth?.epic){ delete currentUser.oauth.epic; cacheEpicLink(null); }
          return { linked: false, error: 'Authentication required' };
        }
        if(!resp.ok) return null;
        const data = await resp.json();
        currentUser = currentUser || {};
        currentUser.oauth = currentUser.oauth || {};
        if(data.linked){
          const epicData = {
            linked: true,
            epicAccountId: data.epicAccountId || null,
            displayName: data.displayName || null,
            linkedAt: data.linkedAt || Date.now(),
            lastValidatedAt: data.lastValidatedAt || Date.now()
          };
          currentUser.oauth.epic = epicData;
          cacheEpicLink(epicData);
        } else if(currentUser.oauth.epic){
          delete currentUser.oauth.epic;
          cacheEpicLink(null);
        }
        return data;
      }catch(e){ console.warn('Epic status fetch failed', e); return null; }
    }

    window.startOAuth = (provider) => {
      if(!firebaseAuth?.currentUser){ alert('Sign in first to link accounts.'); return; }
      if(provider === 'epic'){
        const redirect = encodeURIComponent(getOAuthCallbackUrl(provider));
        window.location.href = `/api/oauth/epic/start?redirect_uri=${redirect}`;
        return;
      }
      alert('Unsupported OAuth provider.');
    };

    window.unlinkOAuth = async (provider) => {
      if(provider !== 'epic') return alert('Unsupported OAuth provider.');
      if(!firebaseAuth?.currentUser){ alert('Sign in first to unlink.'); return; }
      try{
        const token = await firebaseAuth.currentUser.getIdToken();
        const resp = await fetch('/api/oauth/epic/unlink', {
          method:'POST',
          headers:{ 'Authorization': `Bearer ${token}` },
          credentials: 'include'
        });
        if(!resp.ok){
          alert('Could not unlink Epic right now.');
          return;
        }
        await fetchEpicLinkStatus();
        await persistCurrentUserProfile();
        alert('Epic account unlinked.');
        renderProfile(); setupEventListeners();
      }catch(err){
        console.warn('Unlink epic failed', err);
        alert('Could not unlink Epic right now.');
      }
    };

    function hasMeaningfulData(profile){
      if(!profile) return false;
      return (profile.ownedTracks && profile.ownedTracks.length) ||
        (profile.setlist && profile.setlist.length) ||
        (profile.genreOverrides && Object.keys(profile.genreOverrides).length) ||
        (profile.bandMembers && profile.bandMembers.length);
    }

    async function promptLocalImport(firebaseUsername){
      const localOwned = JSON.parse(localStorage.getItem('ownedTracks') || '[]');
      const legacyLocalSet = JSON.parse(localStorage.getItem('setlist') || '[]');
      const localSetIds = normalizeSetlistIds(JSON.parse(localStorage.getItem('setlistIds') || '[]'));
      const localSet = localSetIds.length ? localSetIds : normalizeSetlistIds(legacyLocalSet);
      const localGenre = JSON.parse(localStorage.getItem('genreOverrides') || '{}');
      const profiles = JSON.parse(localStorage.getItem('userProfiles') || '{}');

      const candidateProfiles = Object.entries(profiles)
        .filter(([name, data]) => name && name !== firebaseUsername && hasMeaningfulData(data));
      const deviceDataAvailable = (localOwned && localOwned.length) || (localSet && localSet.length) || (localGenre && Object.keys(localGenre).length);
      if(!candidateProfiles.length && !deviceDataAvailable) return null;

      return await new Promise((resolve)=>{
        const modal = document.createElement('div');
        modal.id = 'importModal';
        modal.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:30000;backdrop-filter:blur(6px);padding:12px;';
        const optionsHtml = candidateProfiles.length ?
          `<label class="block text-sm text-gray-200 mb-2">Import from saved profile</label>
            <select id="importProfileSelect" class="w-full px-3 py-2 rounded-lg bg-black/60 border border-cyan-500/30 text-white mb-3">
              ${candidateProfiles.map(([name])=>`<option value="${name}">${name}</option>`).join('')}
            </select>` : '';
        modal.innerHTML = `
          <div class="w-full max-w-md bg-gradient-to-b from-black/85 to-black/90 border border-cyan-500/30 rounded-2xl p-6 text-white shadow-2xl">
            <h3 class="text-xl font-bold mb-2">Import your local data?</h3>
            <p class="text-sm text-gray-200 mb-4">We found local data on this device. Import into this account?</p>
            ${optionsHtml || ''}
            ${deviceDataAvailable ? '<p class="text-xs text-gray-300 mb-4">Tip: If you used this app offline, choose Import to keep your owned songs and setlists.</p>' : ''}
            <div class="flex gap-2 justify-end">
              <button id="importSkip" class="px-4 py-2 rounded-lg bg-gray-700 text-white">Skip</button>
              <button id="importConfirm" class="px-4 py-2 rounded-lg bg-gradient-to-r from-pink-500 to-cyan-500 text-white font-bold">Import</button>
            </div>
          </div>`;
        document.body.appendChild(modal);
        const cleanup = ()=>{ modal.remove(); };
        modal.querySelector('#importSkip').onclick = ()=>{ cleanup(); resolve(null); };
        modal.querySelector('#importConfirm').onclick = ()=>{
          const choice = modal.querySelector('#importProfileSelect')?.value || null;
          cleanup();
          if(choice && profiles[choice]) return resolve(profiles[choice]);
          if(deviceDataAvailable){
            return resolve({
              ownedTracks: localOwned,
              setlist: localSet,
              genreOverrides: localGenre
            });
          }
          resolve(null);
        };
      });
    }

    async function hydrateFromLocalCacheOnly(){
      const cached = window.profileStore?.readLocalProfileCache?.() || {};
      const fallbackUid = cached.uid || getLocalDeviceId();
      const fallbackName = cached.djName || cached.email || 'Guest';
      const ownedCache = readOwnedTracksCache(fallbackUid);
      const hydrated = normalizeProfileShape({
        ...cached,
        uid: fallbackUid,
        username: cached.username || fallbackName,
        djName: cached.djName || fallbackName,
        ownedTracks: ownedCache?.trackIds || cached.ownedTracks || []
      }, fallbackUid);
      if(window.profileStore?.hasMeaningfulProfileData?.(hydrated)) return hydrated;
      return null;
    }

    function getLegacyProfileForMigration(uid){
      if(localStorage.getItem(PROFILE_MIGRATION_KEY) === uid){
        return { legacyProfile: {}, usedLegacy: false };
      }
      const legacyProfile = readLegacyLocalProfile();
      const usedLegacyProfile = window.profileStore?.hasMeaningfulProfileData
        ? window.profileStore.hasMeaningfulProfileData(legacyProfile)
        : hasMeaningfulData(legacyProfile);
      const usedLegacy = usedLegacyProfile || (legacyProfile.ownedTracks && legacyProfile.ownedTracks.length);
      return { legacyProfile, usedLegacy };
    }

    function resolveOwnedTracksFromCacheCandidates(candidates){
      const uniqueCandidates = Array.from(new Set((candidates || []).filter(Boolean)));
      let best = null;
      uniqueCandidates.forEach((candidate)=>{
        const snapshot = readOwnedTracksCache(candidate);
        if(snapshot?.trackIds?.length && (!best || snapshot.trackIds.length > best.trackIds.length)){
          best = snapshot;
        }
      });
      return best?.trackIds || [];
    }

    async function hydrateProfileFromCloudThenMergeLocal(uid, email){
      profileSyncState = { syncing: true, message: 'Syncing your profileâ€¦' };
      const localCache = window.profileStore?.readLocalProfileCache?.() || {};
      const { legacyProfile, usedLegacy } = getLegacyProfileForMigration(uid);
      const { ownedTracks: legacyOwnedTracks = [], ...legacyProfileFields } = legacyProfile || {};
      const cachedOwnedTracks = resolveOwnedTracksFromCacheCandidates([
        uid,
        localCache.uid,
        localStorage.getItem('activeProfileUid'),
        getLocalDeviceId()
      ]);
      const localProfile = {
        ...localCache,
        ...legacyProfileFields,
        uid,
        email: email || localCache.email || '',
        djName: localCache.djName || currentUser?.djName || '',
        ownedTracks: normalizeOwnedList([...(localCache.ownedTracks || []), ...cachedOwnedTracks])
      };
      setlist = normalizeSetlistIds(localProfile.setlist || []);
      genreOverrides = localProfile.genreOverrides || {};
      bandMembers = localProfile.bandMembers || [];
      render(); setupEventListeners();
      await restoreOwnedLibrary(uid, { legacyOwnedTracks });
      const cloudProfile = await window.profileStore.readCloudProfile(uid);
      const plan = window.profileStore.buildSyncPlan({ cloud: cloudProfile, local: localProfile });
      const defaultProfile = {
        uid,
        email: email || '',
        setlist: [],
        genreOverrides: {},
        bandMembers: []
      };
      let merged = { ...defaultProfile, ...(plan.merged || {}) };
      merged.uid = uid;
      merged.email = email || merged.email || '';
      if(plan.shouldWriteCloud){
        const serverTimestamp = firebase?.firestore?.FieldValue?.serverTimestamp;
        const migrating = plan.cloudEmpty && plan.localHasData;
        const patch = {
          ...merged,
          migratedFromLocalAt: migrating
            ? (serverTimestamp ? serverTimestamp() : new Date().toISOString())
            : merged.migratedFromLocalAt ?? null
        };
        await window.profileStore.writeCloudProfile(uid, patch);
      }
      window.profileStore.writeLocalProfileCache(merged);
      if(usedLegacy){
        localStorage.setItem(PROFILE_MIGRATION_KEY, uid);
        ['ownedTracks','setlist','setlistIds','genreOverrides'].forEach((key)=>localStorage.removeItem(key));
      }
      return merged;
    }

    function renderSignedOutState(){
      if(currentUser){
        render();
        setupEventListeners();
        return;
      }
      showLoginScreen();
    }

    function renderSignedInState(){
      render();
      setupEventListeners();
    }

    function setupFirebaseAuthListener() {
      if (!firebaseAuth || firebaseAuthUnsub) return;
      firebaseAuthUnsub = firebaseAuth.onAuthStateChanged(async (user) => {
        if (!user) {
          authSettledUser = null;
          if(userProfileUnsub){
            userProfileUnsub();
            userProfileUnsub = null;
          }
          const localProfile = await hydrateFromLocalCacheOnly();
          if(localProfile){
            await enterAppWithProfile(localProfile, { loadOverrides: false, skipPersist: true });
          } else {
            currentUser = null;
          }
          profileSyncState = { syncing: false, message: '' };
          renderSignedOutState();
          return;
        }
        if (authSettledUser === user.uid) return;
        authSettledUser = user.uid;
        profileSyncState = { syncing: true, message: 'Syncing your profileâ€¦' };
        render(); setupEventListeners();
        try {
          const mergedProfile = await hydrateProfileFromCloudThenMergeLocal(user.uid, user.email || '');
          const defaultUsername = user.displayName || (user.email ? user.email.split('@')[0] : `user_${user.uid.slice(0,6)}`);
          const profile = normalizeProfileShape({
            ...mergedProfile,
            uid: user.uid,
            email: user.email || mergedProfile.email || '',
            username: mergedProfile.username || defaultUsername,
            djName: mergedProfile.djName || defaultUsername
          }, user.uid);
          await enterAppWithProfile(profile, { loadEpic: true, loadOverrides: true, skipPersist: true });
          logEvent('auth_success', { uid: user.uid });
          renderSignedInState();
        } finally {
          profileSyncState = { syncing: false, message: '' };
          render(); setupEventListeners();
        }
      });
    }

    async function handleFirebaseAuth(e){
      e.preventDefault();
      const errorBox = document.getElementById('authError');
      if(!firebaseEnabled || !firebaseAuth){
        if(errorBox){ errorBox.textContent = 'Firebase not configured â€” using local profiles.'; errorBox.style.display = 'block'; }
        logEvent('auth_fail', { reason: 'config_missing' });
        return;
      }
      const mode = document.getElementById('authMode')?.value || 'signin';
      const email = (document.getElementById('email')?.value || '').trim();
      const password = (document.getElementById('password')?.value || '').trim();
      const passwordConfirm = document.getElementById('passwordConfirm')?.value || '';

      if(authInFlight) return;
      if(!email || !password){ if(errorBox){ errorBox.textContent = 'Enter email & password.'; errorBox.style.display = 'block'; } return; }
      if(password.length < 6 && mode === 'signup'){ if(errorBox){ errorBox.textContent = 'Password must be at least 6 characters.'; errorBox.style.display = 'block'; } return; }

      const submitBtn = document.getElementById('authSubmit');
      const disableAuthUi = (disabled) => {
        if(submitBtn){ submitBtn.disabled = disabled; submitBtn.classList.toggle('opacity-70', disabled); }
      };
      const mapErrorCode = (code, message)=>{
        if(code === 'auth/invalid-credential' || code === 'auth/wrong-password') return 'Email/password incorrect';
        if(code === 'auth/user-not-found') return 'No account found â€” click Register';
        if(code === 'auth/network-request-failed') return 'Network blocked/unstable. Try again or disable VPN.';
        if(code === 'auth/too-many-requests') return 'Too many attempts â€” wait a moment';
        return message || 'Sign-in failed';
      };
      authInFlight = true;
      disableAuthUi(true);
      if(errorBox){ errorBox.textContent = ''; errorBox.style.display = 'none'; }
      logEvent('auth_attempt', { mode, email });
      try{
        if(mode === 'signup'){
          if(password !== passwordConfirm){ if(errorBox){ errorBox.textContent = 'Passwords do not match.'; errorBox.style.display = 'block'; } return; }
          await firebaseAuth.createUserWithEmailAndPassword(email,password);
        } else {
          await firebaseAuth.signInWithEmailAndPassword(email,password);
        }

        setupFirebaseAuthListener();

      } catch(err){
        console.error(err);
        const message = mapErrorCode(err?.code || '', err?.message);
        if(errorBox){ errorBox.textContent = message; errorBox.style.display = 'block'; }
        logEvent('auth_fail', { code: err?.code, message: err?.message });
      } finally {
        authInFlight = false;
        disableAuthUi(false);
      }
    }
    window.handleFirebaseAuth = handleFirebaseAuth;


    async function logoutUser(){
      try { await persistCurrentUserProfile(); } catch(err){ console.warn('save before logout failed', err); }
      if(firebaseAuth){ try{ await firebaseAuth.signOut(); } catch(e){ console.warn('signout',e); } }
      authSettledUser = null; authProcessing = false;
      currentUser = null; draftProfile = null; ownedTracks = []; setlist = []; bandMembers = []; viewingProfile = null; genreOverrides = {};
      ownedLibraryState = { phase: 'idle', source: 'none', message: '' };
      ownedLibraryRestoring = false;
      ownedLibraryPendingWrite = null;
      localStorage.removeItem('currentUser');
    }

    // -------------------- Songs loading -----------------------
    async function loadSongs(){
      if(songsLoaded){
        return;
      }
      console.log('Loading tracks...');
      loadSongsStartTime = performance.now();
      firstListRenderLogged = false;
      maxCardsLogged = false;
      maxMobileCardsRendered = 0;
      logEvent('songs_fetch_start', { online: navigator.onLine });
      trackLoadState = { status: 'loading', loaded: 0, total: 0, message: 'Loading tracksâ€¦' };
      trackLoadNotice = '';
      render(); setupEventListeners();
      const cachedTracks = await readCachedTracks();
      const endpoints=[ 'https://api.allorigins.win/raw?url=https://fortnitecontent-website-prod07.ol.epicgames.com/content/api/pages/fortnite-game/spark-tracks', 'https://corsproxy.io/?https://fortnitecontent-website-prod07.ol.epicgames.com/content/api/pages/fortnite-game/spark-tracks' ];
      const canFetch = navigator.onLine;
      if(cachedTracks.length){
        console.warn('Using cached track data');
        songs = cachedTracks;
        songs.forEach(hydrateKeyInfo);
        songsById = Object.fromEntries(songs.map(s => [s.id, s]));
        trackSource = 'cache';
        songsLoaded = true;
        trackLoadState = { status: 'refreshing', loaded: 0, total: 0, message: 'Refreshing tracksâ€¦' };
        logEvent('songs_fetch_success', { source: trackSource, count: songs.length });
        render(); setupEventListeners();
        maybeAutoStartTour();
      }
      if(canFetch){
        for(let i=0;i<endpoints.length;i++){
          try{
            const res = await fetch(endpoints[i]);
            if(!res.ok) continue;
            const data = await res.json();
            const entries = Object.entries(data).filter(([k])=>!k.startsWith('_'));
            const nextSongs = [];
            trackLoadState = { status: 'loading', loaded: 0, total: entries.length, message: 'Loading tracksâ€¦' };
            updateTrackLoadProgressUI();
            for(let idx=0; idx<entries.length; idx+=1){
              const [id,item] = entries[idx];
              const track = item?.track || {};
              if(!track?.tt) continue;
              const detectedGenre = detectGenre(track.an||'', track.tt);
              const finalGenre = genreOverrides[id] || detectedGenre;
              const rawBpm = Number(track.mt) || 0;
              const camelotData = deriveCamelotForTrack({ ...track, id });
              const camelotApplied = applyCamelotOverride({ ...track, id, title: track.tt, artist: track.an }, camelotData.camelot);
              const bpmApplied = applyBpmOverride({ ...track, id, title: track.tt, artist: track.an }, rawBpm);
              const keyInfo = parseKey(track.mk || camelotData.keyLabel || track.key || '', track.mm || camelotData.mode || track.mode || '');
              const enriched = { id, title: track.tt, artist: track.an || 'Unknown', bpm: bpmApplied.bpm, rawBpm, key: keyInfo.label || camelotData.keyLabel || (track.mk || '?'), rawKey: track.mk || '', rawMode: track.mm || '', mode: camelotData.mode || (track.mm||''), camelot: camelotApplied.camelot, derivedCamelot: camelotData.camelot, duration: Number(track.dn)||0, albumArt: track.au||'', genre: finalGenre, camelotOverridden: camelotApplied.overridden, bpmOverridden: bpmApplied.overridden, keyInfo };
              enriched.flags = computeTrackFlags(enriched);
              if(enriched.bpm>0) nextSongs.push(enriched);
              trackLoadState.loaded = idx + 1;
              if(idx % 120 === 0) updateTrackLoadProgressUI();
            }
            nextSongs.sort((a,b)=>a.title.localeCompare(b.title));
            if(nextSongs.length>0){
              songs = nextSongs;
              songsById = Object.fromEntries(songs.map(s => [s.id, s]));
              regressionWarnings = knownCorrections.filter(kc=>{
                const track = songs.find(s=>s.id===kc.id);
                return track && track.camelot !== kc.expectedCamelot;
              });
              if(regressionWarnings.length) console.warn('Regression warnings', regressionWarnings);
              trackSource = 'network';
              songsLoaded = true;
              trackLoadState = { status: 'idle', loaded: 0, total: 0, message: '' };
              logEvent('songs_fetch_success', { source: trackSource, count: songs.length });
              cacheTracks(songs);
              render(); setupEventListeners();
              maybeAutoStartTour();
              return;
            }
          }catch(e){ console.warn('endpoint err',e); logEvent('songs_fetch_fail', { message: e?.message, step: 'network' }); }
        }
      }
      if(cachedTracks.length){
        trackLoadState = { status: 'idle', loaded: 0, total: 0, message: '' };
        return;
      }
      console.warn('endpoints failed, using fallback sample');
      songs = SAMPLE_TRACKS;
      songs.forEach(hydrateKeyInfo);
      songsById = Object.fromEntries(songs.map(s => [s.id, s]));
      trackSource = 'fallback';
      songsLoaded = true;
      trackLoadNotice = 'Online source unavailableâ€”showing sample tracks.';
      trackLoadState = { status: 'idle', loaded: 0, total: 0, message: '' };
      logEvent('songs_fetch_fail', { message: 'network+cache miss; using fallback' });
      render(); setupEventListeners();
      maybeAutoStartTour();
    }

    function refreshRegressionWarnings(){
      regressionWarnings = knownCorrections.filter(kc=>{
        const track = songs.find(s=>s.id===kc.id);
        return track && track.camelot !== kc.expectedCamelot;
      });
    }

    function resetMainPagination(){
      resetPage(mainPager);
      persistMainPagerState();
    }

    const setCamelotOverride = async (trackId,value)=>{
      if(!isAdmin()) return alert('Admin only');
      camelotOverridesStore.ids[trackId] = value;
      await persistOverrides();
      const track = songs.find(s=>s.id===trackId);
      if(track){ refreshSongOverrides(track); }
      refreshRegressionWarnings();
      renderAuditView();
      renderSongList();
    };
    const setBpmOverride = async (trackId,value)=>{
      if(!isAdmin()) return alert('Admin only');
      bpmOverridesStore.ids[trackId] = Number(value);
      await persistOverrides();
      const track = songs.find(s=>s.id===trackId);
      if(track){ refreshSongOverrides(track); }
      renderAuditView();
      renderSongList();
    };
    const clearOverrides = async (trackId)=>{
      if(!isAdmin()) return alert('Admin only');
      delete camelotOverridesStore.ids[trackId];
      delete bpmOverridesStore.ids[trackId];
      await persistOverrides();
      const track = songs.find(s=>s.id===trackId);
      if(track){ refreshSongOverrides(track); }
      refreshRegressionWarnings();
      renderAuditView();
      renderSongList();
    };

    // ---------------------- Render list & setlist -----------------------
    function formatDuration(sec){ const m=Math.floor(sec/60); const s=sec%60; return `${m}:${s.toString().padStart(2,'0')}`; }
    function updateOwnedCount(){ const el=document.getElementById('ownedCount'); if(el){ const displayTracks = viewingProfile ? viewingProfile.ownedTracks || [] : ownedTracks; const ownerLabel = viewingProfile ? (viewingProfile.djName || viewingProfile.username || 'Profile') : 'You'; el.textContent = `${ownerLabel} own ${displayTracks.length}/${songs.length} tracks`; } }

    function scrollSongListToTop(){
      const list = document.getElementById('songList');
      if(!list) return;
      if(list.scrollHeight > list.clientHeight){
        list.scrollTo({ top: 0, behavior: 'smooth' });
      } else {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    }

    function scheduleSongListRender(reason='', options = {}){
      const { scrollToTop = false } = options || {};
      songListRenderReason = reason;
      if(songListRenderScheduled) return;
      songListRenderScheduled = true;
      requestAnimationFrame(()=>{
        songListRenderScheduled = false;
        renderSongList();
        if(scrollToTop){
          requestAnimationFrame(scrollSongListToTop);
        }
      });
    }

    function buildSelectedSongCriteria(song){
      if(!song) return null;
      const bpmMin = song.bpm - 4;
      const bpmMax = song.bpm + 4;
      if(keyMatchMode === 'semitone'){
        const info = ensureKeyInfo(song);
        return { mode: 'semitone', bpmMin, bpmMax, info };
      }
      return { mode: 'camelot', bpmMin, bpmMax, compatibleKeys: getCompatibleKeys(song.camelot) };
    }

    function refreshSelectedSongCriteria(){
      selectedSongCriteria = selectedSong ? buildSelectedSongCriteria(selectedSong) : null;
    }

    function isMixableWithCriteria(criteria, candidate){
      if(!criteria || !candidate) return false;
      if(candidate.bpm < criteria.bpmMin || candidate.bpm > criteria.bpmMax) return false;
      if(criteria.mode === 'semitone'){
        const match = scoreSemitoneKeyMatch(criteria.info, ensureKeyInfo(candidate), maxSemitoneRange, includeOppositeMode);
        return match.eligibleSameMode || match.eligibleOppMode;
      }
      return criteria.compatibleKeys.includes(candidate.camelot);
    }

    function updateTrackLoadProgressUI(){
      const el = document.getElementById('trackLoadProgress');
      if(el && trackLoadState.total){
        el.textContent = `Loaded ${trackLoadState.loaded}/${trackLoadState.total}`;
      }
    }

    function updateSongCardOwnedState(songId){
      const card = document.querySelector(`.song-card[data-song-id="${songId}"]`);
      if(!card) return;
      const displayTracks = viewingProfile ? viewingProfile.ownedTracks || [] : ownedTracks;
      const isOwned = displayTracks.includes(songId);
      const star = card.querySelector('[data-owned-star]');
      if(star) star.style.display = isOwned ? 'block' : 'none';
      const button = card.querySelector('[data-song-action="toggle-owned"]');
      if(button){
        button.textContent = isOwned ? 'âœ“ Owned' : 'Mark Owned';
        button.className = `px-3 py-2 ${isOwned ? 'bg-green-500 hover:bg-green-600' : 'bg-gray-700 hover:bg-gray-600'} rounded-lg text-sm font-medium transition`;
      }
    }

    function updateSongCardSetlistState(songId){
      const card = document.querySelector(`.song-card[data-song-id="${songId}"]`);
      if(!card) return;
      const isInSetlist = setlist.includes(songId);
      const button = card.querySelector('[data-song-action="toggle-setlist"]');
      if(button){
        button.textContent = isInSetlist ? 'âœ“ In Setlist' : '+ Set';
        button.className = `addSetBtn px-4 py-2 ${isInSetlist ? 'bg-emerald-500/40 hover:bg-emerald-500/50' : 'bg-gradient-to-r from-purple-500 to-pink-500'} rounded-lg text-sm font-medium transition`;
      }
    }

    function setMixableInlineNotice(message){
      mixableInlineNotice = message;
      if(mixableInlineTimer) clearTimeout(mixableInlineTimer);
      mixableInlineTimer = setTimeout(()=>{
        mixableInlineNotice = '';
        const banner = document.getElementById('mixableInlineNotice');
        if(banner) banner.style.display = 'none';
      }, 2200);
      const banner = document.getElementById('mixableInlineNotice');
      if(banner){
        banner.textContent = mixableInlineNotice;
        banner.style.display = mixableInlineNotice ? 'block' : 'none';
      }
    }

    function getStickyCtaConfig(){
      if(view !== 'browser') return { visible: false };
      if(viewingProfile) return { visible: false };
      if(!isMobileViewport()) return { visible: false };
      if(stickyCtaDismissed) return { visible: false };
      if(isSearchFocused) return { visible: false };
      const hasOwned = ownedTracks.length > 0;
      const hasSelected = !!selectedSong;
      if(hasOwned && hasSelected){
        stickyCtaDismissed = true;
        localStorage.setItem('jamMixer.stickyCtaDismissed', 'true');
        return { visible: false };
      }
      if(showMixableOnly && !selectedSong){
        return { visible: true, text: 'Select a Song First', action: 'mixable-warning' };
      }
      if(!hasOwned){
        return { visible: true, text: 'Start: Pick Songs You Own', action: 'open-quickstart' };
      }
      return { visible: true, text: 'Next: Choose a Song to Mix', action: 'scroll-to-list' };
    }

    function updateStickyCTA(){
      const config = getStickyCtaConfig();
      const bar = document.getElementById('stickyCtaBar');
      const button = document.getElementById('stickyCtaButton');
      const copy = document.getElementById('stickyCtaCopy');
      const appRoot = document.getElementById('appRoot');
      if(appRoot){
        appRoot.classList.toggle('sticky-cta-active', !!config.visible);
      }
      if(!bar || !button) return;
      if(!config.visible){
        bar.classList.add('hidden');
        return;
      }
      bar.classList.remove('hidden');
      button.textContent = config.text || '';
      button.dataset.stickyAction = config.action || '';
      if(copy){
        copy.textContent = config.action === 'open-quickstart'
          ? 'Tap to pick a starter set in seconds.'
          : config.action === 'scroll-to-list'
            ? 'Jump to the song list and pick a starter track.'
            : 'Mixable matches need a selected song first.';
      }
    }

    function shiftMobileWindow(direction){
      if(!isMobileViewport()) return;
      const delta = direction * MOBILE_PAGE_CHUNK;
      const maxStart = Math.max(0, lastFilteredCount - MOBILE_MAX_CARDS);
      mobileWindowState.start = Math.min(maxStart, Math.max(0, mobileWindowState.start + delta));
      mobileWindowState.count = Math.min(MOBILE_MAX_CARDS, Math.max(MOBILE_PAGE_CHUNK, mobileWindowState.count));
      scheduleSongListRender('mobile-window-shift');
      const list = document.getElementById('songList');
      if(list) list.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    const QUICK_START_PRESETS = {
      casual: {
        title: 'Casual',
        copy: 'Mark a starter set of 15 popular tracks.',
        count: 15
      },
      new: {
        title: 'New Player',
        copy: 'Mark 5 starter tracks so you can mix fast.',
        count: 5
      }
    };
    const QUICK_START_CURATED_TITLES = [
      'Bad Guy',
      'Blinding Lights',
      'Go With The Flow',
      'Seven Nation Army',
      'Believer',
      'Levitating',
      'One Dance',
      'Uptown Funk',
      'Wake Me Up',
      'Counting Stars',
      'Mr. Brightside',
      'Viva La Vida',
      'Heat Waves',
      'Dance Monkey',
      'Starboy',
      'Lose Yourself',
      'Take On Me',
      'Happier',
      'Bad Romance',
      'Blame It On The Boogie'
    ];

    function resolveQuickStartTrackIds(limit){
      const ids = [];
      QUICK_START_CURATED_TITLES.forEach((title)=>{
        const match = songs.find(s=>s.title?.toLowerCase() === title.toLowerCase());
        if(match && !ids.includes(match.id)) ids.push(match.id);
      });
      if(ids.length < limit){
        songs.slice(0, limit).forEach((song)=>{
          if(!ids.includes(song.id)) ids.push(song.id);
        });
      }
      return ids.slice(0, limit);
    }

    function getQuickStartRecommendations(){
      const preferred = resolveQuickStartTrackIds(6);
      return preferred.map(id => songsById[id]).filter(Boolean);
    }

    function openQuickStart(){
      if(quickStartDone) return;
      quickStartState.open = true;
      quickStartState.step = 0;
      quickStartState.preset = null;
      const modal = document.getElementById('quickStartModal');
      if(modal){
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden','false');
      }
      renderQuickStartStep();
    }

    function closeQuickStart(){
      quickStartState.open = false;
      const modal = document.getElementById('quickStartModal');
      if(modal){
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden','true');
      }
    }

    function maybeAutoOpenQuickStart(){
      if(quickStartDone || quickStartPrompted || quickStartState.open) return;
      if(!currentUser || !justEnteredProfile) return;
      if(ownedTracks.length === 0){
        quickStartPrompted = true;
        openQuickStart();
      }
      justEnteredProfile = false;
    }

    function moveQuickStartStep(delta){
      const next = Math.max(0, Math.min(1, quickStartState.step + delta));
      quickStartState.step = next;
      renderQuickStartStep();
    }

    function completeQuickStart({ skipped = false } = {}){
      quickStartDone = true;
      localStorage.setItem('jamMixer.quickStartDone', 'true');
      closeQuickStart();
      if(skipped){
        stickyCtaDismissed = false;
        updateStickyCTA();
      }
      updateStickyCTA();
    }

    async function applyQuickStartPreset(preset){
      let nextOwned = [];
      if(preset === 'completionist'){
        const confirmed = confirm('âš ï¸ This will mark every track as owned. This cannot be undone easily. Continue?');
        if(!confirmed) return false;
        nextOwned = songs.map(s=>s.id);
      } else {
        const config = QUICK_START_PRESETS[preset];
        if(!config) return false;
        nextOwned = resolveQuickStartTrackIds(config.count);
      }
      await saveOwnedTracksSafe(nextOwned, { reason: 'quickstart' });
      updateOwnedCount();
      updateMobileWindowState({ reset: true });
      scheduleSongListRender('quick-start-owned');
      updateStickyCTA();
      return true;
    }

    function renderQuickStartStep(){
      const body = document.getElementById('quickStartBody');
      const title = document.getElementById('quickStartTitle');
      const subtitle = document.getElementById('quickStartSubtitle');
      if(!body || !title || !subtitle) return;
      if(quickStartState.step === 0){
        title.textContent = 'Quick Start';
        subtitle.textContent = 'Pick your style to mark owned tracks.';
        body.innerHTML = `
          <button class="quickstart-option" data-action="quickStartPreset" data-preset="casual">
            <strong>Casual</strong>
            <span class="text-xs text-gray-300">${QUICK_START_PRESETS.casual.copy}</span>
          </button>
          <button class="quickstart-option" data-action="quickStartPreset" data-preset="new">
            <strong>New Player</strong>
            <span class="text-xs text-gray-300">${QUICK_START_PRESETS.new.copy}</span>
          </button>
          <button class="quickstart-option" data-action="quickStartPreset" data-preset="completionist">
            <strong>Completionist</strong>
            <span class="text-xs text-red-200">Marks ALL tracks owned (big library).</span>
          </button>
        `;
      } else {
        title.textContent = 'Choose a starter track';
        subtitle.textContent = 'Tap one to see instant mixable matches.';
        const picks = getQuickStartRecommendations();
        body.innerHTML = picks.length ? picks.map(track=>`
          <div class="quickstart-track" data-action="quickStartPickTrack" data-song-id="${track.id}">
            <div class="w-10 h-10 rounded-lg flex items-center justify-center text-sm font-bold" style="background:${camelotColors[track.camelot] || '#0ea5e9'}">${track.camelot}</div>
            <div style="flex:1">
              <div class="font-semibold text-white">${track.title}</div>
              <div class="text-xs text-gray-300">${track.artist}</div>
            </div>
            <span class="text-xs text-cyan-200 font-semibold">${track.bpm} BPM</span>
          </div>
        `).join('') : '<div class="text-sm text-gray-300">Tracks are still loading â€” give it a second.</div>';
      }
      const backBtn = document.querySelector('[data-action="quickStartBack"]');
      if(backBtn) backBtn.style.visibility = quickStartState.step === 0 ? 'hidden' : 'visible';
    }

    function renderSongList(){
      listRenderCount += 1;
      const displayTracks = viewingProfile ? viewingProfile.ownedTracks || [] : ownedTracks;
      const isMobile = isMobileViewport();
      if(!isMobile && mobileListObserver){
        mobileListObserver.disconnect();
        mobileListObserver = null;
      }
      const filtered = songs.filter(s=>{
        const isSelected = selectedSong && s.id === selectedSong.id;
        const matchesSearch = !searchTerm || s.title.toLowerCase().includes(searchTerm.toLowerCase()) || s.artist.toLowerCase().includes(searchTerm.toLowerCase());
        const matchesOwned = !showOwnedOnly || displayTracks.includes(s.id);
        const matchesMixable = isSelected || !showMixableOnly || !selectedSong || isMixableWithCriteria(selectedSongCriteria, s);
        const matchesGenre = selectedGenre === 'All' || s.genre === selectedGenre;
        return matchesSearch && matchesOwned && matchesMixable && matchesGenre;
      });

      const scored = filtered.map(song=>{
        if(!selectedSong){
          return { song, comp: null, rank: 0, bpmDiff: null, keyDist: null, sameGenre: false };
        }
        const rankData = priorityRank(selectedSong, song, sortMode);
        return { song, ...rankData };
      });

      if(selectedSong){
        if(keyMatchMode === 'semitone'){
          scored.sort((a,b)=>{
            const aMatch = a.semitoneMatch || {};
            const bMatch = b.semitoneMatch || {};
            const aSame = aMatch.eligibleSameMode ? 1 : 0;
            const bSame = bMatch.eligibleSameMode ? 1 : 0;
            if(aSame !== bSame) return bSame - aSame;
            const aOpp = aMatch.eligibleOppMode ? 1 : 0;
            const bOpp = bMatch.eligibleOppMode ? 1 : 0;
            if(aSame===0 && bSame===0 && aOpp !== bOpp) return bOpp - aOpp;
            const aDist = (aMatch.eligibleSameMode || aMatch.eligibleOppMode) ? aMatch.dist ?? Infinity : Infinity;
            const bDist = (bMatch.eligibleSameMode || bMatch.eligibleOppMode) ? bMatch.dist ?? Infinity : Infinity;
            if(aDist !== bDist) return aDist - bDist;
            const aBpm = a.bpmDiff ?? Infinity;
            const bBpm = b.bpmDiff ?? Infinity;
            if(aBpm !== bBpm) return aBpm - bBpm;
            return a.song.title.localeCompare(b.song.title);
          });
        } else {
          scored.sort((a,b)=>{
            const scoreDiff = (b.rank ?? 0) - (a.rank ?? 0);
            if(scoreDiff !== 0) return scoreDiff;
            return a.song.title.localeCompare(b.song.title);
          });
        }
      } else {
        scored.sort((a,b)=> a.song.title.localeCompare(b.song.title));
      }
      lastFilteredCount = scored.length;

      const songListEl = document.getElementById('songList'); if(!songListEl) return;
      let pageEntries = scored;
      let showingStart = scored.length ? 1 : 0;
      let showingEnd = scored.length;
      let totalPages = 1;
      let mobileControls = '';
      if(isMobile){
        updateMobileWindowState();
        const start = Math.max(0, mobileWindowState.start);
        const count = Math.min(mobileWindowState.count, MOBILE_MAX_CARDS);
        pageEntries = scored.slice(start, start + count);
        showingStart = pageEntries.length ? start + 1 : 0;
        showingEnd = pageEntries.length ? start + pageEntries.length : 0;
        const hasMore = start + count < scored.length;
        const canAutoLoad = hasMore && count < MOBILE_MAX_CARDS;
        const canStep = hasMore && count >= MOBILE_MAX_CARDS;
        const hasPrev = start > 0;
        mobileControls = `
          <div class="mt-3 flex flex-col gap-2">
            <div class="text-xs text-gray-300">Showing ${showingStart}â€“${showingEnd} of ${scored.length} tracks</div>
            ${canAutoLoad ? `<div id="songListSentinel" class="text-xs text-cyan-200">Loading more tracksâ€¦</div>` : ''}
            ${canStep || hasPrev ? `<div class="flex items-center gap-2">
              ${hasPrev ? `<button data-action="mobilePrevWindow" class="px-3 py-2 rounded-lg bg-white/10 border border-white/10 text-sm">Previous</button>` : ''}
              ${canStep ? `<button data-action="mobileNextWindow" class="px-3 py-2 rounded-lg bg-white/10 border border-white/10 text-sm">Next</button>` : ''}
            </div>` : ''}
          </div>`;
        if(pageEntries.length > maxMobileCardsRendered) maxMobileCardsRendered = pageEntries.length;
      } else {
        const pagination = paginate(scored, mainPager.pageIndex, mainPager.pageSize);
        if(pagination.pageIndex !== mainPager.pageIndex) mainPager.pageIndex = pagination.pageIndex;
        persistMainPagerState();
        pageEntries = pagination.pageItems;
        showingStart = pagination.from;
        showingEnd = pagination.to;
        totalPages = pagination.totalPages;
      }

      const priorityNames = { bpm:'Tempo', camelot:'Camelot', genre:'Genre' };
      const priorityDescriptions = {
        bpm: 'Priority: Tempo â€” closest BPM results are boosted within compatible matches.',
        camelot: 'Priority: Camelot â€” harmonic neighbors rise to the top within the best matches.',
        genre: 'Priority: Genre â€” same-genre blends are boosted while keeping top compatibility first.'
      };
      const priorityHeader = selectedSong ? `
        <div class="mb-3 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-1">
          <div class="text-lg font-bold text-white">Top Matches (Priority: ${priorityNames[sortMode] || 'Tempo'})</div>
          <div class="text-xs text-cyan-200 font-semibold">Strength: ${priorityStrength==='low'?'Low':priorityStrength==='high'?'High':'Medium'}</div>
        </div>
        <div class="text-xs text-gray-300 mb-4">${priorityDescriptions[sortMode] || priorityDescriptions.bpm} Top matches are sorted by compatibility first, then the priority boost (showing strongest ~10 results up top).</div>
      ` : '';

      const adminUser = isAdmin();
      const reducedEffects = isLowPowerMode;
      const cardGrid = pageEntries.map(entry=>{
        const song = entry.song;
        const isSelected = selectedSong && song.id === selectedSong.id;
        const isOwned = displayTracks.includes(song.id);
        const isInSetlist = setlist.includes(song.id);
        const comp = entry.comp;
        const pct = comp ? Math.min(100, Math.max(0, Math.round(comp.total))) : null;
        const hasOverride = genreOverrides[song.id];
        const glowClass = reducedEffects ? '' : (pct>=80 ? 'glow-perfect' : pct>=60 ? 'glow-good' : (pct!==null ? 'glow-bad' : ''));
        const priorityLabel = selectedSong ? (()=>{
          if(keyMatchMode === 'semitone'){
            const distVal = entry.semitoneMatch?.dist ?? 'â€”';
            const modeLabel = entry.semitoneMatch?.eligibleSameMode ? 'same mode' : entry.semitoneMatch?.eligibleOppMode ? 'opposite mode' : 'out of range';
            return `ðŸŽ¶ Semitone priority (Î”${distVal}, ${modeLabel})`;
          }
          if(sortMode === 'bpm'){
            const delta = entry.bpmDiff !== null && entry.bpmDiff !== undefined ? Math.round(entry.bpmDiff) : 'â€”';
            return `ðŸ”¥ Closest BPM match (Î”${delta})`;
          }
          if(sortMode === 'camelot'){
            const distVal = entry.keyDist !== null && entry.keyDist !== undefined ? (Number.isInteger(entry.keyDist) ? entry.keyDist : entry.keyDist.toFixed(1)) : 'â€”';
            return `ðŸŽ¼ Harmonic neighbor (distance ${distVal})`;
          }
          if(sortMode === 'genre'){
            return entry.sameGenre ? 'ðŸŽ­ Same genre boost' : 'ðŸŽ­ Genre priority (different genre)';
          }
          return '';
        })() : '';
        const semitoneBadge = (selectedSong && keyMatchMode==='semitone') ? (()=>{
          const match = entry.semitoneMatch;
          if(!match || match.dist===null || match.dist===undefined) return '';
          const deltaLabel = match.signedDelta===null || match.signedDelta===undefined ? `Î”Key: ${match.dist}` : `Î”Key: ${match.signedDelta>=0?'+':''}${match.signedDelta}`;
          const modeLabel = match.eligibleSameMode ? 'Same Mode' : (match.eligibleOppMode ? 'Opp Mode' : 'Not in range');
          return `<span class="px-2 py-1 bg-blue-500/20 border border-blue-400/40 rounded text-xs text-blue-100 font-semibold">${deltaLabel} â€¢ ${modeLabel}</span>`;
        })() : '';
        if(showMixableOnly && selectedSong){ if(!isMixableWithCriteria(selectedSongCriteria, song)) return ''; }
        const selectedStyles = isSelected ? 'selected-card' : '';
        const genrePill = adminUser
          ? `<button data-genre-tag="${song.id}" data-song-id-genre="${song.id}" class="px-2 py-1 ${hasOverride ? 'bg-green-500/30 border-green-500/50' : 'bg-orange-500/30 border-orange-500/50'} border rounded text-xs cursor-pointer hover:border-cyan-400/60" title="Click to edit genre">${song.genre}${hasOverride ? ' âœ“' : ''}</button>`
          : `<span class="px-2 py-1 ${hasOverride ? 'bg-green-500/30 border-green-500/50' : 'bg-orange-500/30 border-orange-500/50'} border rounded text-xs cursor-default">${song.genre}${hasOverride ? ' âœ“' : ''}</span>`;
        return `
          <div class="song-card panel p-4 relative hover:border-cyan-400 transition-all ${selectedStyles}" data-song-id="${song.id}" draggable="true">
            <div class="star-icon absolute top-2 right-2 text-xl" data-owned-star style="display:${isOwned?'block':'none'}">â­</div>
            ${isSelected ? `<button class="selected-badge absolute top-2 left-2 flex items-center gap-1" data-song-action="clear-selection">SELECTED <span class="font-normal text-[10px] opacity-90">(tap to clear)</span></button>` : (selectedSong && isMixable(selectedSong,song) ? `<div class="absolute top-2 left-2 text-xl">ðŸŽ§</div>` : '')}
            <div class="flex gap-4 mb-3">
              ${song.albumArt ? `<img src="${song.albumArt}" class="w-20 h-20 rounded-lg cursor-pointer hover:scale-110 transition-transform" data-song-action="select" data-song-id="${song.id}"/>` : `<div class="w-20 h-20 bg-gradient-to-br from-purple-500 to-pink-500 rounded-lg"></div>`}
              <div class="flex-1 cursor-pointer" data-song-action="select" data-song-id="${song.id}">
                <div class="font-bold text-lg mb-1 text-white">${song.title}</div>
                <div class="text-gray-300 mb-2 text-sm">${song.artist}</div>
                <div class="flex items-center gap-2 text-sm flex-wrap">
                  ${genrePill}
                  <span class="px-3 py-1 rounded-lg font-mono font-bold text-white" style="background:${camelotColors[song.camelot] || '#666'}">${song.camelot}</span>
                  <span class="px-2 py-1 bg-gray-700 rounded text-xs">${song.key}</span>
                  <span class="font-semibold text-cyan-300">${song.bpm} BPM</span>
                  ${semitoneBadge}
                  ${selectedSong && isMixable(selectedSong,song) ? `<span class="px-2 py-1 bg-purple-600/40 border border-purple-400/40 rounded text-xs text-purple-200 font-bold">Â±${Math.abs(song.bpm - selectedSong.bpm)} BPM</span>` : ''}
                  <span class="text-gray-400">${formatDuration(song.duration)}</span>
                </div>
                ${priorityLabel ? `<div class="text-xs text-cyan-200 mt-1">${priorityLabel}</div>` : ''}
              </div>
            </div>
            <div class="flex flex-wrap gap-2 items-center">
              <button data-song-action="select" data-song-id="${song.id}" class="px-3 py-2 rounded-lg text-sm font-semibold border ${isSelected?'border-cyan-400 bg-cyan-500/20 text-cyan-100':'border-white/10 bg-white/5 text-gray-200'}">Select</button>
              <button class="previewBtn px-3 py-2 bg-white/10 hover:bg-white/20 rounded-lg text-sm" data-song-action="preview" data-song-id="${song.id}">Preview</button>
              <button data-song-action="toggle-owned" data-song-id="${song.id}" class="px-3 py-2 ${isOwned ? 'bg-green-500 hover:bg-green-600' : 'bg-gray-700 hover:bg-gray-600'} rounded-lg text-sm font-medium transition" ${viewingProfile ? 'disabled style="opacity:0.5;cursor:not-allowed;"' : ''}>${isOwned ? 'âœ“ Owned' : 'Mark Owned'}</button>
              <button data-song-action="toggle-setlist" data-song-id="${song.id}" class="addSetBtn px-4 py-2 ${isInSetlist ? 'bg-emerald-500/40 hover:bg-emerald-500/50' : 'bg-gradient-to-r from-purple-500 to-pink-500'} rounded-lg text-sm font-medium transition" ${viewingProfile ? 'disabled style="opacity:0.5;cursor:not-allowed;"' : ''}>${isInSetlist ? 'âœ“ In Setlist' : '+ Set'}</button>
              <button data-song-action="add-sandbox" data-song-id="${song.id}" class="px-3 py-2 bg-blue-600/30 hover:bg-blue-600/50 border border-blue-400/40 rounded-lg text-sm font-medium transition" ${sandboxTracks.find(t=>t.id===song.id) ? 'disabled style="opacity:0.5;cursor:not-allowed;"' : ''}>+ Sandbox</button>
              ${selectedSong ? `<div class="${pct!==null?glowClass:''} ml-2 px-3 py-2 score-badge">${pct!==null?pct+'%':'â€”'}</div>` : ''}
            </div>
          </div>
        `;
      }).join('');

      const loadingSkeleton = Array.from({ length: 10 }).map(()=>`
        <div class="skeleton-card">
          <div class="skeleton-line long"></div>
          <div class="skeleton-line medium"></div>
          <div class="skeleton-line short"></div>
        </div>
      `).join('');
      const loadingBlock = trackLoadState.status === 'loading' && !songs.length
        ? `<div class="space-y-3">
            <div class="inline-banner">Loading tracksâ€¦ <span id="trackLoadProgress">${trackLoadState.total ? `Loaded ${trackLoadState.loaded}/${trackLoadState.total}` : ''}</span></div>
            <div class="song-grid grid gap-4">${loadingSkeleton}</div>
          </div>`
        : '';
      const refreshBanner = trackLoadState.status === 'refreshing'
        ? `<div class="inline-banner">Refreshing tracks in the backgroundâ€¦</div>`
        : '';
      const emptyOwnedCallout = (!viewingProfile && ownedTracks.length === 0 && !quickStartDone)
        ? `<div class="panel p-4 bg-cyan-500/10 border border-cyan-400/30 text-sm text-cyan-100 space-y-2">
            <div class="font-semibold text-white">Step 1: Mark songs you own (start small)</div>
            <div class="text-xs text-cyan-200">Quick Start marks a starter set so you can see mixes fast.</div>
            <button data-action="openQuickStart" class="px-4 py-2 rounded-lg bg-cyan-500/20 border border-cyan-400/40 text-white font-semibold">Quick Start</button>
          </div>`
        : '';
      const matchHint = matchHintMessage ? `<div class="inline-banner">${matchHintMessage}</div>` : '';
      const listContent = loadingBlock || (scored.length
        ? `<div id="mainPaginationTop"></div>${refreshBanner}${trackLoadNotice ? `<div class="inline-banner">${trackLoadNotice}</div>` : ''}${emptyOwnedCallout}${matchHint}<div class="song-grid grid gap-4">${cardGrid}</div>${mobileControls}<div id="mainPaginationBottom"></div>`
        : `<div class="panel p-6 text-center text-gray-300 space-y-3"><div>No songs match your filters yet.</div><button data-action="clearFilters" class="px-4 py-2 rounded-lg bg-white/10 border border-white/20 text-sm text-white">Clear filters</button></div>`);

      songListEl.innerHTML = priorityHeader + listContent;
      if(scored.length && !isMobile){
        const renderPagination = (targetId)=>{
          const targetEl = document.getElementById(targetId);
          renderPaginationBar(targetEl, mainPager, {
            onPageChange: (nextIndex)=>{
              mainPager.pageIndex = Math.max(0, nextIndex);
              persistMainPagerState();
              scheduleSongListRender('page-change', { scrollToTop: true });
            },
            onPageSizeChange: (nextSize)=>{
              setPageSize(mainPager, nextSize);
              persistMainPagerState();
              scheduleSongListRender('page-size', { scrollToTop: true });
            }
          }, { totalItems: scored.length, totalPages, from: showingStart, to: showingEnd });
        };
        renderPagination('mainPaginationTop');
        renderPagination('mainPaginationBottom');
      }
      if(trackLoadState.status === 'loading') updateTrackLoadProgressUI();
      if(!firstListRenderLogged && songsLoaded && loadSongsStartTime){
        const elapsed = Math.round(performance.now() - loadSongsStartTime);
        console.log(`[perf] First list render in ${elapsed}ms (source: ${trackSource})`);
        firstListRenderLogged = true;
      }
      if(isMobile){
        const sentinel = document.getElementById('songListSentinel');
        if(mobileListObserver){
          mobileListObserver.disconnect();
          mobileListObserver = null;
        }
        if(sentinel){
          mobileListObserver = new IntersectionObserver((entries) => {
            if(entries.some(entry=>entry.isIntersecting)){
              if(mobileWindowState.count < MOBILE_MAX_CARDS){
                mobileWindowState.count = Math.min(MOBILE_MAX_CARDS, mobileWindowState.count + MOBILE_PAGE_CHUNK);
                scheduleSongListRender('mobile-load-more');
              }
            }
          }, { rootMargin: '200px' });
          mobileListObserver.observe(sentinel);
        }
        if(songsLoaded && !maxCardsLogged && maxMobileCardsRendered){
          console.log(`[perf] Mobile max cards rendered at once: ${maxMobileCardsRendered}`);
          maxCardsLogged = true;
        }
      }
    }

    function renderSetlist(){
      const setlistEl = document.getElementById('setlistContent'); if(!setlistEl) return;
      if(setlist.length===0){
        setlistEl.innerHTML = `<div class="text-center py-12"><div class="text-6xl mb-4">ðŸŽµ</div><p class="text-xl mb-4 text-white">Your setlist is empty</p><button data-action="switchView" data-view="browser" class="px-6 py-3 bg-gradient-to-r from-purple-500 to-pink-500 rounded-lg font-bold">Browse Tracks</button></div>`;
        return;
      }
      if(!songsById || Object.keys(songsById).length === 0){
        setlistEl.innerHTML = `<div class="text-center py-12 text-white space-y-3">
          <div class="text-4xl">â³</div>
          <p class="text-lg font-semibold">Loading tracksâ€¦</p>
          <p class="text-sm text-gray-300">Setlist will appear in a moment.</p>
        </div>`;
        return;
      }
      const setlistRows = setlist.map((id, i)=>{
        const song = songsById[id];
        if(!song){
          return `<div class="bg-black/40 backdrop-blur-sm border border-red-500/40 rounded-xl p-4 flex items-center gap-4 hover:border-red-400 transition">
            <div class="text-2xl font-bold text-pink-400">${i+1}</div>
            <div class="flex-1">
              <div class="font-bold text-lg text-white">Missing track (unavailable)</div>
              <div class="text-gray-300 text-sm">Track ID: <span class="font-mono text-orange-300">${id}</span></div>
            </div>
            <button data-action="removeSet" data-id="${id}" class="p-2 hover:bg-red-500/20 rounded text-red-400 text-xl">âœ•</button>
          </div>`;
        }
        return `<div class="bg-black/40 backdrop-blur-sm border border-gray-700 rounded-xl p-4 flex items-center gap-4 hover:border-cyan-400 transition">
          <div class="text-2xl font-bold text-pink-400">${i+1}</div>
          ${song.albumArt?`<img src="${song.albumArt}" class="w-16 h-16 rounded-lg"/>`:''}
          <div class="flex-1">
            <div class="font-bold text-lg text-white">${song.title}</div>
            <div class="text-gray-300">${song.artist}</div>
            <div class="text-xs text-orange-300">${song.genre}</div>
          </div>
          <div class="text-xl font-mono font-bold" style="color:${camelotColors[song.camelot]}">${song.camelot}</div>
          <button data-action="removeSet" data-id="${song.id}" class="p-2 hover:bg-red-500/20 rounded text-red-400 text-xl">âœ•</button>
        </div>`;
      }).join('');
      setlistEl.innerHTML = `<div class="space-y-4">${setlistRows}</div>`;
    }

    function renderProfile(){
      const profileEl = document.getElementById('profileView'); if(!profileEl) return;
      if(DEBUG_UI) console.log('[debug][profile] renderProfile');
      bindUiDebugging();
      bindProfileHandlers();
      const viewOnly = !!viewingProfile;
      if(!viewOnly && (!draftProfile || (currentUser?.username && draftProfile.username !== currentUser.username))){
        refreshDraftProfileFromCurrentUser();
      }
      const profileEditable = !viewOnly && profileEditMode;
      const profileOwner = viewingProfile || currentUser || {};
      const editableProfile = viewOnly ? profileOwner : (draftProfile || profileOwner);
      const email = (firebaseAuth && firebaseAuth.currentUser && firebaseAuth.currentUser.email) ? firebaseAuth.currentUser.email : (viewingProfile ? 'Shared profile view' : 'Offline mode (local storage)');
      const usernameVal = editableProfile?.username || '';
      const djVal = editableProfile?.djName || usernameVal;
      const persona = ensurePersona(editableProfile);
      const bio = (editableProfile?.bio || '').slice(0, PROFILE_BIO_MAX);
      const themeAccentId = editableProfile?.themeAccent || THEME_ACCENTS[0].id;
      const accentColor = resolveThemeAccent(themeAccentId);
      const accentGlow = hexToRgba(accentColor, 0.45);
      const themeLabel = THEME_ACCENTS.find(item=>item.id === themeAccentId)?.label || 'Custom';
      const isPublicProfile = editableProfile?.isPublic !== false;
      const allowFriendRequests = editableProfile?.allowFriendRequests !== false;
      const profileAccentStyle = `--profile-accent:${accentColor}; --profile-accent-glow:${accentGlow};`;
      const friendsAccess = getFriendsOnlineStatus();
      const friendsEnabled = friendsAccess.online && !viewOnly;
      const friendsGateMessage = !viewOnly ? getFriendsGateMessage(friendsAccess) : '';
      const personaTheme = getPersonaTheme(persona.personaTheme);
      const editDisabledAttr = profileEditable ? '' : 'disabled';
      const editDisabledClass = profileEditable ? '' : 'opacity-60 cursor-not-allowed';
      const editBadgeLabel = profileEditable ? 'On' : 'Off';
      const editBadgeClass = profileEditable
        ? 'bg-cyan-500/20 border border-cyan-400/40 text-cyan-100'
        : 'bg-gray-600/20 border border-gray-400/40 text-gray-200';
      const streamUrlValue = editableProfile?.streamUrl || '';
      const normalizedStreamUrl = normalizeStreamUrlInput(streamUrlValue);
      const streamUrlValid = isValidStreamUrl(normalizedStreamUrl);
      const liveActive = streamUrlValid && profileOwner?.isLive === true;
      let liveSinceLabel = '';
      if(profileOwner?.liveStartedAt){
        const liveDate = new Date(profileOwner.liveStartedAt);
        if(!Number.isNaN(liveDate.getTime())) liveSinceLabel = liveDate.toLocaleString();
      }
      if(!viewOnly){
        ensureLiveNowLoaded();
        if(friendsEnabled) refreshFriendsData();
      }
      const profileOwnerKey = profileOwner?.uid || profileOwner?.username || '';
      if(profileOwnerKey && profileOwnedPagerOwnerKey !== profileOwnerKey){
        profileOwnedPagerOwnerKey = profileOwnerKey;
        resetPage(profileOwnedPager);
      }
      if(viewOnly && profileOwnerKey){
        ensureRatingLoaded(profileOwnerKey);
      }
      const ownedIds = profileOwner?.ownedTracks || [];
      const epicLink = profileOwner?.oauth?.epic || null;
      const epicLinked = !!epicLink?.linked;
      const epicDisplay = epicLink?.displayName || epicLink?.epicAccountId || '';
      const showConnectedAccounts = !!firebaseAuth?.currentUser && !viewOnly;
      const friendError = friendLookupError ? `<div class="text-sm text-red-200 bg-red-500/10 border border-red-500/40 rounded px-3 py-2">${friendLookupError}</div>` : '';
      const friendList = friendLookupResults.length ? `<div class="space-y-2">
        <div class="text-xs text-gray-300">Multiple matches found. Pick one:</div>
        ${friendLookupResults.map(p=>`<button onclick="selectFriendProfile('${p.username || p.uid || ''}')" class="w-full text-left px-3 py-2 bg-white/5 hover:bg-white/10 border border-white/10 rounded flex items-center justify-between"><span class="font-semibold text-white">${p.djName || p.username || 'DJ'}</span><span class="text-xs text-gray-400">${p.username || 'unknown'}</span></button>`).join('')}
      </div>` : '';
      const ownedFiltered = songs
        .filter(s=>ownedIds.includes(s.id))
        .filter(s=>{
          const term = (profileOwnedSearch||'').toLowerCase();
          return !term || s.title.toLowerCase().includes(term) || s.artist.toLowerCase().includes(term);
        })
        .sort((a,b)=> a.title.localeCompare(b.title));
      const ownedPagination = paginate(ownedFiltered, profileOwnedPager.pageIndex, profileOwnedPager.pageSize);
      if(ownedPagination.pageIndex !== profileOwnedPager.pageIndex) profileOwnedPager.pageIndex = ownedPagination.pageIndex;
      const ownedCards = ownedPagination.pageItems.map(song=>{
        const camelotColor = camelotColors[song.camelot] || '#4b5563';
        return `<div class="flex gap-3 bg-black/40 border border-white/10 rounded-xl p-3 hover:border-cyan-500/40 transition">
          ${song.albumArt ? `<img src="${song.albumArt}" class="w-16 h-16 rounded-lg object-cover" alt="${song.title} cover"/>` : `<div class="w-16 h-16 rounded-lg bg-white/5 flex items-center justify-center text-xl">ðŸŽµ</div>`}
          <div class="flex-1 space-y-1">
            <div class="font-bold text-white">${song.title}</div>
            <div class="text-sm text-gray-300">${song.artist}</div>
            <div class="flex flex-wrap gap-2 items-center text-xs">
              <span class="px-2 py-1 rounded font-mono font-semibold text-white" style="background:${camelotColor};">${song.camelot}</span>
              <span class="px-2 py-1 bg-white/10 border border-white/10 rounded text-white">${song.bpm} BPM</span>
              <span class="px-2 py-1 bg-emerald-500/20 border border-emerald-400/40 rounded text-emerald-100">${song.genre}</span>
            </div>
          </div>
        </div>`;
      }).join('');
      const ownedEmpty = `<div class="text-sm text-gray-400">${profileOwnedSearch ? 'No owned songs match your search.' : 'No owned songs yet.'}</div>`;
      const livePill = liveActive
        ? `<a id="liveStatusPill" href="${normalizedStreamUrl}" target="_blank" rel="noopener noreferrer" class="px-3 py-1 rounded-full text-xs font-bold bg-green-400 text-black border border-green-200/80" style="box-shadow: 0 0 14px rgba(34,197,94,0.8);">LIVE</a>`
        : `<span id="liveStatusPill" class="px-3 py-1 rounded-full text-xs font-semibold bg-gray-600/60 text-gray-100 border border-gray-500/70">OFFLINE</span>`;
      const liveToggleLabel = liveActive ? 'End Live' : 'Go Live';
      const streamHelperText = streamUrlValid ? '' : (viewOnly ? 'Stream link not provided.' : 'Add a valid stream link to enable Live.');
      const ratingBreakdown = normalizeRatingBreakdown(profileOwner?.ratingBreakdown);
      const ratingDisplay = getProfileRatingDisplay(profileOwner);
      const ratingCountLabel = ratingDisplay.ratingCount === 1 ? '1 rating' : `${ratingDisplay.ratingCount} ratings`;
      const ratingStatusClass = ratingStatusTone === 'error'
        ? 'bg-red-500/20 border-red-400/50 text-red-100'
        : ratingStatusTone === 'success'
          ? 'bg-emerald-500/20 border-emerald-400/50 text-emerald-100'
          : 'bg-white/10 border-white/20 text-gray-200';
      const ratingSummaryBlock = `
          <div class="flex items-center justify-between gap-4 flex-wrap">
            <div>
              <div class="text-lg font-bold text-white">Ratings</div>
              <p class="text-sm text-gray-300">Community feedback for this DJ</p>
            </div>
            <div class="text-right">
              <div class="text-2xl font-bold text-white">${ratingDisplay.avgRating ? ratingDisplay.avgRating.toFixed(1) : '0.0'}</div>
              <div class="text-xs text-gray-400">${ratingCountLabel}</div>
            </div>
          </div>
          <div class="text-xl rating-star-display">${ratingDisplay.stars}</div>
          ${ratingDisplay.ratingCount ? renderRatingBreakdownBars(ratingBreakdown, ratingDisplay.ratingCount) : `<div class="text-sm text-gray-400">No ratings yet.</div>`}
      `;
      const ratingInputBlock = viewOnly ? `
          <div class="mt-4 border-t border-white/10 pt-4 space-y-3">
            <div class="flex items-center justify-between flex-wrap gap-2">
              <div class="text-base font-semibold text-white">Rate this DJ</div>
              ${ratingLoading ? `<div class="text-xs text-gray-400">Loading your ratingâ€¦</div>` : ''}
            </div>
            ${currentUser ? `
              <div id="ratingStarRow" class="flex items-center gap-2">
                ${[1,2,3,4,5].map(star=>`
                  <button type="button" data-star="${star}" onclick="setRatingStar(${star})" class="rating-star text-2xl ${ratingDraft.stars >= star ? 'active' : ''}" aria-label="${star} star">${star <= ratingDraft.stars ? 'â˜…' : 'â˜†'}</button>
                `).join('')}
              </div>
              <div id="ratingTagRow" class="flex flex-wrap gap-2">
                ${RATING_TAGS.map(tag=>`
                  <button type="button" data-tag="${tag}" onclick="toggleRatingTag('${tag}')" class="px-3 py-1 rounded-full border text-xs font-semibold ${ratingDraft.tags.includes(tag) ? 'border-emerald-400/60 bg-emerald-500/20 text-emerald-100' : 'border-white/10 bg-white/5 text-gray-200'}">${tag}</button>
                `).join('')}
              </div>
              <div>
                <textarea id="ratingCommentInput" maxlength="${RATING_MAX_COMMENT}" rows="3" class="w-full px-3 py-2 rounded-lg bg-black/40 border border-white/10 text-white" placeholder="Optional comment (max ${RATING_MAX_COMMENT} chars)">${ratingDraft.comment || ''}</textarea>
                <div class="text-xs text-gray-400 text-right mt-1" id="ratingCommentCount">${(ratingDraft.comment || '').length}/${RATING_MAX_COMMENT}</div>
              </div>
              <div class="flex items-center gap-3 flex-wrap">
                <button type="button" onclick="submitRating()" class="px-4 py-2 rounded-lg font-semibold ${ratingSubmitting ? 'bg-gray-600/40 text-gray-200 cursor-not-allowed' : 'bg-amber-500/30 border border-amber-400/50 text-amber-100'}" ${ratingSubmitting ? 'disabled' : ''}>${ratingDraft.hasExisting ? 'Update Rating' : 'Submit Rating'}</button>
                ${ratingStatusMessage ? `<div class="text-sm px-3 py-2 rounded-lg border ${ratingStatusClass}">${ratingStatusMessage}</div>` : ''}
              </div>
            ` : `<div class="text-sm text-gray-300">Sign in to rate this DJ.</div>`}
          </div>
      ` : '';
      const liveNowCards = liveNowUsers.map(profile=>{
        const username = profile?.username || profile?.uid || '';
        const djName = profile?.djName || username || 'DJ';
        const platform = getStreamPlatformInfo(profile.streamUrl);
        const rating = getProfileRatingDisplay(profile);
        return `<div onclick="viewLiveProfile('${username}')" class="min-w-[240px] cursor-pointer bg-black/40 border border-white/10 rounded-xl p-4 hover:border-emerald-400/60 transition">
          <div class="flex items-center gap-3">
            ${renderPersonaBadge(profile, 48)}
            <div class="flex-1">
              <div class="font-bold text-white">${djName}</div>
              <div class="text-xs text-gray-400">@${username}</div>
            </div>
            <span class="px-2 py-1 rounded-full text-[10px] font-bold bg-green-400 text-black border border-green-200/80 glow-perfect">LIVE</span>
          </div>
          <div class="mt-3 flex items-center justify-between text-xs text-gray-300">
            <span class="px-2 py-1 rounded-full border border-white/10 bg-white/5">${platform.icon} ${platform.label}</span>
            <span class="text-amber-200 font-semibold">${rating.avgRating ? rating.avgRating.toFixed(1) : '0.0'}â˜… (${rating.ratingCount})</span>
          </div>
          <button type="button" onclick="viewLiveProfile('${username}')" class="mt-3 w-full px-3 py-2 rounded-lg bg-white/10 hover:bg-white/20 text-sm font-semibold">View Profile</button>
        </div>`;
      }).join('');
      const liveNowPanel = !viewOnly ? `
          <div class="panel space-y-3">
            <div class="flex items-center justify-between gap-2 flex-wrap">
              <div class="flex items-center gap-2">
                <div class="text-lg font-bold text-white">ðŸ”´ Live Now</div>
                <span class="px-2 py-1 rounded-full text-xs font-semibold bg-white/10 border border-white/20 text-gray-200">(${liveNowUsers.length})</span>
              </div>
              <button type="button" onclick="refreshLiveNowUsers()" class="px-3 py-1 rounded-lg bg-white/10 hover:bg-white/20 text-xs">Refresh</button>
            </div>
            ${liveNowLoading ? `<div class="text-sm text-gray-300">Loading live profilesâ€¦</div>` : ''}
            ${liveNowError ? `<div class="text-sm text-red-200">${liveNowError}</div>` : ''}
            ${!liveNowLoading && !liveNowUsers.length
              ? `<div class="text-sm text-gray-400">No one is live right now. Add your stream link and go live!</div>`
              : `<div id="liveNowCarousel" class="live-carousel flex gap-3 overflow-x-auto pb-2 cursor-grab">
                ${liveNowCards}
              </div>`}
          </div>
      ` : '';
      const ratingPanel = `
          <div class="panel space-y-3">
            ${ratingSummaryBlock}
            ${ratingInputBlock}
          </div>
      `;
      const bioDisplay = bio
        ? `<p class="text-sm text-gray-200">${escapeHtml(bio)}</p>`
        : `<p class="text-sm text-gray-400">Add a short bio to show your vibe.</p>`;
      const personaThemeButtons = PERSONA_THEMES.map(item=>`
        <button type="button" onclick="setPersonaTheme('${item.id}')" data-persona-theme="${item.id}" ${profileEditable ? '' : 'disabled'} class="persona-option px-3 py-2 rounded-full text-xs font-semibold ${persona.personaTheme === item.id ? 'active' : ''} ${profileEditable ? '' : 'opacity-60 cursor-not-allowed'}">
          ${item.label}
        </button>
      `).join('');
      const personaButtons = PERSONA_LIST.map(item=>`
        <button type="button" onclick="setPersonaId('${item.id}')" data-persona-id="${item.id}" ${profileEditable ? '' : 'disabled'} class="persona-option persona-card w-20 h-20 rounded-2xl flex flex-col items-center justify-center gap-1 text-xs font-semibold ${persona.personaId === item.id ? 'active' : ''} ${profileEditable ? '' : 'opacity-60 cursor-not-allowed'}">
          ${renderPersonaSVG({ personaId: item.id, themeId: persona.personaTheme, seed: persona.personaSeed, size: 48 })}
          <span>${item.name}</span>
        </button>
      `).join('');
      const themeButtons = THEME_ACCENTS.map(item=>`
        <button type="button" onclick="setThemeAccent('${item.id}')" data-theme-accent="${item.id}" ${profileEditable ? '' : 'disabled'} class="persona-option px-3 py-2 rounded-full text-xs font-semibold ${themeAccentId === item.id ? 'active' : ''} ${profileEditable ? '' : 'opacity-60 cursor-not-allowed'}">
          ${item.label}
        </button>
      `).join('');
      const profileHero = `
          <div class="flex flex-col md:flex-row gap-4 items-start md:items-center bg-black/40 border rounded-xl p-4 profile-accent-border profile-accent-glow">
            <div class="flex items-center gap-4">
              <div class="profile-avatar-action flex flex-col items-center gap-2" role="button" tabindex="0" data-action="open-profile-editor" aria-label="Edit Profile">
                <div id="profilePersonaPreview" class="persona-badge w-24 h-24">
                  ${renderPersonaSVG({ personaId: persona.personaId, themeId: persona.personaTheme, seed: persona.personaSeed, size: 96 })}
                  <span class="persona-energy">${(PERSONAS[persona.personaId] || PERSONAS.turntablist).energy || 'âš¡'}</span>
                </div>
                <span class="profile-accent-pill px-4 py-1.5 rounded-full text-xs font-semibold shadow-sm">Edit Profile</span>
              </div>
            </div>
            <div class="flex-1 space-y-2">
              <div>
                <div class="text-xl font-bold text-white">${escapeHtml(djVal || usernameVal || 'DJ')}</div>
                <div class="text-sm text-gray-300">@${escapeHtml(usernameVal || '')}</div>
              </div>
              ${bioDisplay}
              <div class="flex flex-wrap gap-2">
                <span id="profileThemeLabel" class="profile-accent-pill px-3 py-1 rounded-full text-xs font-semibold">Theme: ${themeLabel}</span>
                <span id="profilePersonaThemeLabel" class="profile-accent-pill px-3 py-1 rounded-full text-xs font-semibold">Energy: ${personaTheme.label}</span>
                <span class="px-3 py-1 rounded-full text-xs font-semibold bg-white/10 border border-white/20 text-gray-200">Myspace vibes</span>
              </div>
            </div>
          </div>
      `;
      const customizePanel = !viewOnly ? `
          <details class="panel space-y-3" open>
            <summary class="cursor-pointer text-lg font-bold text-white">Customize</summary>
            <div class="space-y-4">
              <div class="space-y-3">
                <div class="text-sm font-semibold text-white">Choose Your Energy</div>
                <div class="flex flex-wrap gap-3 items-center">
                  <div class="flex items-center gap-3">
                    <div id="personaBuilderPreview" class="persona-badge w-20 h-20">
                      ${renderPersonaSVG({ personaId: persona.personaId, themeId: persona.personaTheme, seed: persona.personaSeed, size: 80 })}
                    </div>
                    <div class="text-xs text-gray-400">Seed: <span id="personaSeedLabel" class="text-white font-semibold">${escapeHtml(persona.personaSeed)}</span></div>
                  </div>
                  <div class="flex flex-wrap gap-2">
                    <button type="button" onclick="randomizePersonaSeed()" ${profileEditable ? '' : 'disabled'} class="px-3 py-2 rounded-lg bg-white/10 hover:bg-white/20 border border-white/10 text-xs font-semibold ${editDisabledClass}">Randomize Seed</button>
                  </div>
                </div>
                <div class="space-y-2">
                  <div class="text-xs text-gray-400">Theme</div>
                  <div class="flex flex-wrap gap-2">${personaThemeButtons}</div>
                </div>
                <div class="space-y-2">
                  <div class="text-xs text-gray-400">Icons</div>
                  <div class="flex flex-wrap gap-3">${personaButtons}</div>
                </div>
              </div>
              <div class="space-y-2">
                <div class="text-sm font-semibold text-white">Bio</div>
                <textarea id="profileBioInput" maxlength="${PROFILE_BIO_MAX}" rows="3" ${editDisabledAttr} class="w-full px-3 py-2 rounded-lg bg-black/40 border border-white/10 text-white ${editDisabledClass}" placeholder="Add a short bio...">${escapeHtml(bio)}</textarea>
                <div id="profileBioCounter" class="text-xs text-gray-400 text-right">${bio.length}/${PROFILE_BIO_MAX}</div>
              </div>
              <div class="space-y-2">
                <div class="text-sm font-semibold text-white">Theme Accent</div>
                <div class="flex flex-wrap gap-2">${themeButtons}</div>
              </div>
              <div class="space-y-2">
                <div class="text-sm font-semibold text-white">Privacy</div>
                <div class="flex items-center justify-between bg-white/5 border border-white/10 rounded-lg px-3 py-2">
                  <div>
                    <div class="text-sm font-semibold text-white">Public Profile</div>
                    <div class="text-xs text-gray-400">Hide from search when off.</div>
                  </div>
                  <input id="profilePublicToggle" type="checkbox" class="profile-toggle" ${isPublicProfile ? 'checked' : ''} ${editDisabledAttr} />
                </div>
                <div class="flex items-center justify-between bg-white/5 border border-white/10 rounded-lg px-3 py-2">
                  <div>
                    <div class="text-sm font-semibold text-white">Allow Friend Requests</div>
                    <div class="text-xs text-gray-400">Block new requests when off.</div>
                  </div>
                  <input id="profileFriendRequestsToggle" type="checkbox" class="profile-toggle" ${allowFriendRequests ? 'checked' : ''} ${editDisabledAttr} />
                </div>
              </div>
            </div>
          </details>
      ` : '';
      const friendSearchResultsHtml = socialFriendSearchResults.map(profile=>{
        const uid = profile.uid || profile.username || '';
        const status = getFriendStatus(firebaseAuth?.currentUser?.uid, uid);
        const incomingReq = friendRequestsIncoming.find(req=>req.fromUid === uid);
        const outgoingReq = friendRequestsOutgoing.find(req=>req.toUid === uid);
        const liveBadge = profile.isLive ? `<span class="px-2 py-1 rounded-full text-[10px] font-bold bg-emerald-400 text-black border border-emerald-200/80">LIVE</span>` : '';
        let actionMarkup = '';
        if(status === 'friends'){
          actionMarkup = `<span class="px-3 py-1 rounded-full text-xs bg-white/10 border border-white/20 text-gray-200">Friends</span>`;
        } else if(status === 'outgoing_pending'){
          actionMarkup = `<div class="flex gap-2 items-center">
            <span class="px-3 py-1 rounded-full text-xs bg-purple-500/20 border border-purple-400/40 text-purple-100">Request sent</span>
            ${outgoingReq ? `<button onclick="cancelFriendRequest('${outgoingReq.id}')" class="px-3 py-1 rounded-lg bg-red-500/20 border border-red-400/40 text-xs font-semibold">Cancel</button>` : ''}
          </div>`;
        } else if(status === 'incoming_pending'){
          actionMarkup = `<div class="flex gap-2">
            <button onclick="acceptFriendRequest('${incomingReq?.id || ''}','${incomingReq?.fromUid || ''}')" class="px-3 py-1 rounded-lg bg-emerald-500/30 border border-emerald-400/50 text-xs font-semibold">Accept</button>
            <button onclick="rejectFriendRequest('${incomingReq?.id || ''}')" class="px-3 py-1 rounded-lg bg-red-500/30 border border-red-400/50 text-xs font-semibold">Decline</button>
          </div>`;
        } else if(profile.allowFriendRequests === false){
          actionMarkup = `<span class="text-xs text-gray-400">Requests disabled</span>`;
        } else {
          actionMarkup = `<button onclick="sendFriendRequest('${uid}')" class="px-3 py-1 rounded-lg bg-white/10 hover:bg-white/20 border border-white/10 text-xs font-semibold">Add</button>`;
        }
        return `<div class="flex items-center justify-between gap-3 bg-black/40 border border-white/10 rounded-xl p-3">
          <div class="flex items-center gap-3">
            ${renderPersonaBadge(profile, 40)}
            <div>
              <div class="font-semibold text-white">${escapeHtml(profile.djName || profile.username || 'DJ')}</div>
              <div class="text-xs text-gray-400">@${escapeHtml(profile.username || uid || '')}</div>
            </div>
          </div>
          <div class="flex items-center gap-2">
            ${liveBadge}
            ${actionMarkup}
          </div>
        </div>`;
      }).join('');
      const incomingRequestsHtml = friendRequestsIncoming.map(req=>{
        const profile = req.fromProfile || { username: req.fromUid, djName: req.fromUid };
        return `<div class="flex items-center justify-between gap-3 bg-white/5 border border-white/10 rounded-lg px-3 py-2">
          <div class="flex items-center gap-2">
            ${renderPersonaBadge(profile, 32)}
            <div>
              <div class="text-sm font-semibold text-white">${escapeHtml(profile.djName || profile.username || 'DJ')}</div>
              <div class="text-xs text-gray-400">@${escapeHtml(profile.username || req.fromUid || '')}</div>
            </div>
          </div>
          <div class="flex gap-2">
            <button onclick="acceptFriendRequest('${req.id}','${req.fromUid}')" class="px-3 py-1 rounded-lg bg-emerald-500/30 border border-emerald-400/50 text-xs font-semibold">Accept</button>
            <button onclick="rejectFriendRequest('${req.id}')" class="px-3 py-1 rounded-lg bg-red-500/30 border border-red-400/50 text-xs font-semibold">Decline</button>
          </div>
        </div>`;
      }).join('');
      const outgoingRequestsHtml = friendRequestsOutgoing.map(req=>{
        const profile = req.toProfile || { username: req.toUid, djName: req.toUid };
        return `<div class="flex items-center justify-between gap-3 bg-white/5 border border-white/10 rounded-lg px-3 py-2">
          <div class="flex items-center gap-2">
            ${renderPersonaBadge(profile, 32)}
            <div>
              <div class="text-sm font-semibold text-white">${escapeHtml(profile.djName || profile.username || 'DJ')}</div>
              <div class="text-xs text-gray-400">@${escapeHtml(profile.username || req.toUid || '')}</div>
            </div>
          </div>
          <div class="flex gap-2">
            <span class="px-2 py-1 rounded-full text-[10px] font-bold bg-purple-500/20 border border-purple-400/40 text-purple-100">Pending</span>
            <button onclick="cancelFriendRequest('${req.id}')" class="px-3 py-1 rounded-lg bg-red-500/20 border border-red-400/40 text-xs font-semibold">Cancel</button>
          </div>
        </div>`;
      }).join('');
      const friendsListHtml = friendsList.map(item=>{
        const profile = item.profile || { username: item.friendUid, djName: item.friendUid };
        const liveBadge = profile.isLive ? `<span class="px-2 py-1 rounded-full text-[10px] font-bold bg-emerald-400 text-black border border-emerald-200/80">LIVE</span>` : '';
        const watchBtn = profile.streamUrl && profile.isLive ? `<button onclick="viewLiveProfile('${profile.username || profile.uid || ''}')" class="px-3 py-1 rounded-lg bg-blue-500/20 border border-blue-400/40 text-xs font-semibold">Watch</button>` : '';
        return `<div class="flex items-center justify-between gap-3 bg-black/40 border border-white/10 rounded-xl p-3">
          <div class="flex items-center gap-3">
            ${renderPersonaBadge(profile, 40)}
            <div>
              <div class="font-semibold text-white">${escapeHtml(profile.djName || profile.username || 'DJ')}</div>
              <div class="text-xs text-gray-400">@${escapeHtml(profile.username || item.friendUid || '')}</div>
            </div>
          </div>
          <div class="flex items-center gap-2">
            ${liveBadge}
            ${watchBtn}
            <button onclick="viewLiveProfile('${profile.username || profile.uid || item.friendUid || ''}')" class="px-3 py-1 rounded-lg bg-white/10 hover:bg-white/20 text-xs font-semibold">View Profile</button>
            <button onclick="removeFriend('${item.friendUid}')" class="px-3 py-1 rounded-lg bg-red-500/20 border border-red-400/40 text-xs font-semibold">Remove</button>
          </div>
        </div>`;
      }).join('');
      const friendNoticeClass = socialFriendSearchNoticeTone === 'warn'
        ? 'bg-amber-500/20 border border-amber-400/40 text-amber-100'
        : socialFriendSearchNoticeTone === 'error'
          ? 'bg-red-500/20 border border-red-400/40 text-red-100'
          : 'bg-white/10 border border-white/20 text-gray-200';
      const friendsGateClass = friendsGateMessage ? 'bg-white/5 border border-white/10 text-gray-200' : '';
      const friendSearchButtonLabel = socialFriendSearchLoading ? 'Searchingâ€¦' : 'Search';
      const friendsPanel = !viewOnly ? `
          <div class="panel space-y-4">
            <div class="flex items-center justify-between flex-wrap gap-2">
              <div>
                <div class="text-lg font-bold text-white">Friends / Bandmates</div>
                <p class="text-sm text-gray-300">Search DJs and manage requests.</p>
              </div>
              <span class="profile-accent-pill px-3 py-1 rounded-full text-xs font-semibold">Social-lite</span>
            </div>
            ${friendsGateMessage ? `<div class="inline-flex items-center gap-2 text-xs px-3 py-1 rounded-full ${friendsGateClass}">${friendsGateMessage}</div>` : ''}
            <form id="socialFriendSearchForm" class="flex flex-col sm:flex-row gap-2" onsubmit="handleFriendSearch(event)">
              <input id="socialFriendSearchInput" value="${escapeHtml(socialFriendSearchTerm || '')}" placeholder="Search DJsâ€¦" class="flex-1 px-4 py-3 bg-black/40 border border-white/10 rounded-lg text-white" />
              <button id="socialFriendSearchButton" type="submit" onclick="logFriendSearchClick()" ${socialFriendSearchLoading ? 'disabled' : ''} class="px-4 py-3 rounded-lg bg-white/10 hover:bg-white/20 border border-white/10 font-semibold ${socialFriendSearchLoading ? 'opacity-60 cursor-not-allowed' : ''}">${friendSearchButtonLabel}</button>
            </form>
            ${socialFriendSearchNotice ? `<div class="inline-flex items-center gap-2 text-xs px-3 py-1 rounded-full ${friendNoticeClass}">${socialFriendSearchNotice}</div>` : ''}
            ${socialFriendSearchError ? `<div class="text-sm text-red-200 bg-red-500/10 border border-red-400/40 rounded-lg px-3 py-2">${socialFriendSearchError}</div>` : ''}
            ${friendSearchResultsHtml ? `<div class="space-y-2 max-h-64 overflow-y-auto pr-1">${friendSearchResultsHtml}</div>` : (socialFriendSearchQuery && !socialFriendSearchLoading ? `<div class="text-sm text-gray-400">No DJs found for â€˜${escapeHtml(socialFriendSearchQuery)}â€™.</div>` : '')}
            <div class="flex items-center gap-2 text-xs">
              <button onclick="setFriendPanelTab('friends')" class="px-3 py-1 rounded-full border ${friendPanelTab==='friends'?'bg-white/10 border-white/30 text-white':'bg-transparent border-white/10 text-gray-300'}">Friends (${friendsList.length})</button>
              <button onclick="setFriendPanelTab('requests')" class="px-3 py-1 rounded-full border ${friendPanelTab==='requests'?'bg-white/10 border-white/30 text-white':'bg-transparent border-white/10 text-gray-300'}">Requests (${friendRequestsIncoming.length + friendRequestsOutgoing.length})</button>
            </div>
            ${friendPanelTab === 'requests' ? `
              <div class="grid md:grid-cols-2 gap-3">
                <div class="space-y-2">
                  <div class="text-sm font-semibold text-white">Incoming Requests</div>
                  ${friendsLoading ? `<div class="text-xs text-gray-400">Loading requestsâ€¦</div>` : ''}
                  ${incomingRequestsHtml || `<div class="text-xs text-gray-400">No incoming requests.</div>`}
                </div>
                <div class="space-y-2">
                  <div class="text-sm font-semibold text-white">Outgoing Requests</div>
                  ${outgoingRequestsHtml || `<div class="text-xs text-gray-400">No outgoing requests.</div>`}
                </div>
              </div>
            ` : `
              <div class="space-y-2">
                <div class="flex items-center justify-between">
                  <div class="text-sm font-semibold text-white">Friends List</div>
                  ${friendsError ? `<span class="text-xs text-red-200">${friendsError}</span>` : ''}
                </div>
                <div class="space-y-2 max-h-64 overflow-y-auto pr-1">
                  ${friendsListHtml || `<div class="text-xs text-gray-400">No friends yet.</div>`}
                </div>
              </div>
            `}
          </div>
      ` : '';
      const profileErrorBanner = `<div id="profileErrorBanner" class="panel border border-red-400/40 bg-red-500/10 text-red-100 text-sm" style="display:${profileScriptError ? 'block' : 'none'};">Profile scripts failed. Open console.</div>`;
      profileEl.innerHTML = `
        <div class="space-y-4 max-w-5xl mx-auto relative z-10" style="${profileAccentStyle}">
          ${profileErrorBanner}
          <div class="panel space-y-3">
            <div class="flex items-center justify-between">
              <div>
                <div class="text-2xl font-bold text-white">Profile</div>
                <p class="text-sm text-gray-300">Update your DJ identity without leaving the mixer. Username changes migrate your data safely.</p>
              </div>
              ${viewOnly
                ? `<div class="text-sm px-3 py-1 rounded-full bg-purple-500/20 border border-purple-400/40 text-purple-100">View only</div>`
                : `<button id="profileEditToggle" data-profile-action="toggle-edit" class="text-sm px-3 py-1 rounded-full ${editBadgeClass} hover:brightness-110 transition">Edit Mode: ${editBadgeLabel}</button>`
              }
            </div>
            ${viewOnly ? `<div class="text-sm text-gray-300 bg-white/5 border border-white/10 rounded-lg px-3 py-2">Viewing ${djVal || usernameVal}'s public profile. Editing is disabled.</div>` : ''}
            ${profileHero}
            <div class="grid gap-4 md:grid-cols-2">
              <div>
                <label class="text-sm text-gray-300">Email</label>
                <div class="px-4 py-3 bg-black/40 border border-gray-700 rounded-lg text-white">${email}</div>
              </div>
              <div>
                <label class="text-sm text-gray-300">Username</label>
                <input id="profileUsername" value="${usernameVal}" ${editDisabledAttr} class="w-full px-4 py-3 bg-black/40 border border-cyan-500/30 rounded-lg text-white ${editDisabledClass}" />
                <p class="text-xs text-gray-400 mt-1">3â€“20 characters, letters/numbers/underscore only. No logout needed.</p>
              </div>
              <div>
                <label class="text-sm text-gray-300">DJ Name</label>
                <input id="profileDjName" value="${djVal}" ${editDisabledAttr} class="w-full px-4 py-3 bg-black/40 border border-purple-500/30 rounded-lg text-white ${editDisabledClass}" />
                <p class="text-xs text-gray-400 mt-1">Shown in headers and shared views.</p>
              </div>
              <div class="md:col-span-2">
                <label class="text-sm text-gray-300">Stream URL</label>
                <input id="profileStreamUrl" value="${streamUrlValue}" ${editDisabledAttr} placeholder="https://twitch.tv/yourname" class="w-full px-4 py-3 bg-black/40 border border-green-500/30 rounded-lg text-white ${editDisabledClass}" />
                <p class="text-xs text-gray-400 mt-1">Examples: twitch.tv/yourname, youtube.com/@you/live, kick.com/yourname</p>
                <p id="streamUrlHelper" class="text-xs text-amber-200 mt-1" ${streamHelperText ? '' : 'style="display:none;"'}>${streamHelperText}</p>
              </div>
              <div class="md:col-span-2">
                <div class="flex items-center gap-2">
                  <label class="text-sm text-gray-300">Live Status</label>
                  <button type="button" class="helpIconBtn" onclick="openHelpModal({ source: 'live_icon', target: 'live' })" aria-label="Open help: Live streaming" title="How Live status works">?</button>
                </div>
                <div class="flex items-center gap-3 flex-wrap">
                  <button id="liveToggleBtn" onclick="toggleLiveStatus()" class="px-4 py-2 rounded-lg font-semibold ${liveActive ? 'bg-red-500/30 border border-red-400/60 text-red-100' : 'bg-emerald-500/30 border border-emerald-400/60 text-emerald-100'} ${profileEditable ? '' : 'opacity-60 cursor-not-allowed'}" ${!profileEditable || !streamUrlValid ? 'disabled' : ''}>${liveToggleLabel}</button>
                  <a id="watchStreamBtn" href="${normalizedStreamUrl}" target="_blank" rel="noopener noreferrer" class="px-4 py-2 rounded-lg bg-blue-500/20 border border-blue-400/40 text-blue-100 text-sm font-semibold" style="display:${streamUrlValid ? 'inline-flex' : 'none'};">Watch Stream</a>
                  ${livePill}
                  ${liveSinceLabel && liveActive ? `<span class="text-xs text-gray-400">Live since ${liveSinceLabel}</span>` : ''}
                </div>
              </div>
            </div>
            <div class="flex gap-3 flex-wrap">
              ${viewOnly ? '' : `<button onclick="saveProfileSettings()" ${profileEditable ? '' : 'disabled'} class="px-4 py-2 bg-gradient-to-r from-purple-500 to-pink-500 rounded-lg font-bold profile-accent-glow ${editDisabledClass}">Save Profile</button>`}
              <button onclick="switchView('browser')" class="px-4 py-2 bg-white/10 hover:bg-white/20 rounded-lg">Back to Mixer</button>
              ${viewOnly ? `<button onclick="exitProfileViewMode()" class="px-4 py-2 bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/40 rounded-lg">Back to My Profile</button>` : ''}
            </div>
            <div id="profileStatus" class="text-sm text-cyan-200"></div>
          </div>

          ${liveNowPanel}
          ${ratingPanel}
          ${customizePanel}
          ${friendsPanel}

          ${showConnectedAccounts ? `
          <div class="panel space-y-3">
            <div class="flex items-center justify-between flex-wrap gap-2">
              <div>
                <div class="text-lg font-bold text-white">Connected Accounts</div>
                <p class="text-sm text-gray-300">Link Epic to get ready for Epic account login later.</p>
              </div>
            </div>
            <div class="flex items-center justify-between gap-3 flex-wrap bg-white/5 border border-white/10 rounded-lg p-3">
              <div class="flex items-center gap-3">
                <div class="w-10 h-10 rounded-lg bg-gradient-to-br from-purple-500 to-blue-500 flex items-center justify-center text-xl">ðŸŽ®</div>
                <div>
                  <div class="font-semibold text-white">Epic Games</div>
                  <div class="text-xs text-gray-300">${epicLinked ? `Linked${epicDisplay ? ` â€¢ ${epicDisplay}` : ''}` : 'Not linked yet'}</div>
                </div>
              </div>
              <div class="flex items-center gap-2">
                <span class="text-xs font-semibold px-2 py-1 rounded-full ${epicLinked ? 'bg-emerald-500/20 text-emerald-100 border border-emerald-400/40' : 'bg-white/10 text-gray-200 border border-white/20'}">${epicLinked ? 'Linked' : 'Not linked'}</span>
                ${epicLinked ? `<button onclick="unlinkOAuth('epic')" class="px-3 py-2 bg-red-500/20 hover:bg-red-500/30 border border-red-400/50 rounded-lg text-sm">Unlink</button>` : `<button onclick="startOAuth('epic')" class="px-3 py-2 bg-gradient-to-r from-purple-500 to-blue-500 rounded-lg text-sm font-semibold">Link Epic</button>`}
              </div>
            </div>
            <p class="text-xs text-gray-400">Redirects through Epic, then returns here to store a link in your profile. Firebase email/password stays your primary sign-in.</p>
          </div>
          ` : ''}

          <div class="panel space-y-4">
            <div class="flex items-start justify-between gap-3 flex-wrap">
              <div>
                <div class="text-lg font-bold text-white">Owned Songs</div>
                <p class="text-sm text-gray-300">Songs youâ€™ve marked as owned</p>
              </div>
              <div class="text-sm text-cyan-200 font-semibold">${ownedIds.length} / ${songs.length}</div>
            </div>
            <div class="flex flex-col lg:flex-row gap-3 items-stretch lg:items-center">
              <div class="flex-1 flex flex-col gap-2">
                <div class="flex flex-col sm:flex-row gap-2 items-stretch sm:items-center">
                  <input id="friendSearchInput" value="${friendSearchTerm || ''}" ${friendsEnabled ? '' : 'disabled'} placeholder="Search DJ nameâ€¦" class="flex-1 px-4 py-3 bg-black/40 border border-white/10 rounded-lg text-white ${friendsEnabled ? '' : 'opacity-60 cursor-not-allowed'}" />
                  <button onclick="viewFriendProfile()" ${friendsEnabled ? '' : 'disabled'} class="px-4 py-3 bg-purple-500/40 hover:bg-purple-500/50 border border-purple-400/50 rounded-lg font-semibold ${friendsEnabled ? '' : 'opacity-60 cursor-not-allowed'}">View</button>
                </div>
                <div class="text-xs text-gray-400">${friendsEnabled ? 'Shows their owned songs (read-only)' : (friendsGateMessage || 'Friends require Online mode.')}</div>
                ${friendError}
                ${friendList}
              </div>
              <div class="flex-1 flex flex-col gap-2">
                <div class="flex flex-col sm:flex-row gap-2 items-stretch sm:items-center">
                  <input id="ownedSearchInput" value="${profileOwnedSearch || ''}" placeholder="Search owned songsâ€¦" class="flex-1 px-4 py-3 bg-black/40 border border-white/10 rounded-lg text-white" />
                  <div class="text-xs text-gray-400 sm:w-40">Live filter by title or artist</div>
                </div>
                ${viewOnly ? `<button onclick="exitProfileViewMode()" class="px-4 py-2 bg-white/10 hover:bg-white/20 rounded-lg">Back to My Profile</button>` : ''}
              </div>
            </div>
            <div id="profileOwnedList" class="grid grid-cols-1 md:grid-cols-2 gap-3">
              ${ownedCards || ownedEmpty}
            </div>
            <div id="profileOwnedPagination"></div>
          </div>
        </div>`;
      const ownedPaginationEl = document.getElementById('profileOwnedPagination');
      const ownedListEl = document.getElementById('profileOwnedList');
      if(ownedPaginationEl){
        renderPaginationBar(ownedPaginationEl, profileOwnedPager, {
          onPageChange: (nextIndex)=>{
            profileOwnedPager.pageIndex = Math.max(0, nextIndex);
            persistPageSizePreference(profileOwnedPager);
            renderProfile();
            if(ownedListEl) ownedListEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
          },
          onPageSizeChange: (nextSize)=>{
            setPageSize(profileOwnedPager, nextSize);
            persistPageSizePreference(profileOwnedPager);
            setPageSize(mainPager, nextSize);
            persistMainPagerState();
            renderProfile();
            if(ownedListEl) ownedListEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, { totalItems: ownedFiltered.length, totalPages: ownedPagination.totalPages, from: ownedPagination.from, to: ownedPagination.to });
      }
      updateTourUI();
    }

    function updateStreamControlsFromInput(){
      const input = document.getElementById('profileStreamUrl');
      if(!input) return;
      const normalized = normalizeStreamUrlInput(input.value || '');
      const valid = isValidStreamUrl(normalized);
      const helper = document.getElementById('streamUrlHelper');
      if(helper){
        helper.textContent = valid ? '' : (viewingProfile ? 'Stream link not provided.' : 'Add a valid stream link to enable Live.');
        helper.style.display = valid ? 'none' : 'block';
      }
      const toggleBtn = document.getElementById('liveToggleBtn');
      if(toggleBtn){
        if(viewingProfile || !profileEditMode){
          toggleBtn.disabled = true;
          toggleBtn.style.opacity = '0.6';
          toggleBtn.style.cursor = 'not-allowed';
        } else {
          toggleBtn.disabled = !valid;
          toggleBtn.style.opacity = valid ? '1' : '0.6';
          toggleBtn.style.cursor = valid ? 'pointer' : 'not-allowed';
        }
      }
      const pill = document.getElementById('liveStatusPill');
      if(pill && valid && pill.tagName === 'A'){
        pill.setAttribute('href', normalized);
      }
      if(pill && !valid){
        pill.removeAttribute('href');
        pill.removeAttribute('target');
        pill.removeAttribute('rel');
        pill.textContent = 'OFFLINE';
        pill.className = 'px-3 py-1 rounded-full text-xs font-semibold bg-gray-600/60 text-gray-100 border border-gray-500/70';
        pill.style.boxShadow = '';
      }
      const watchBtn = document.getElementById('watchStreamBtn');
      if(watchBtn){
        if(valid){
          watchBtn.setAttribute('href', normalized);
          watchBtn.style.display = 'inline-flex';
        } else {
          watchBtn.style.display = 'none';
        }
      }
    }

    window.toggleLiveStatus = async () => {
      if(viewingProfile) return;
      if(!currentUser) return;
      if(!profileEditMode) return;
      const status = document.getElementById('profileStatus');
      const input = document.getElementById('profileStreamUrl');
      const normalizedStreamUrl = normalizeStreamUrlInput(input?.value || currentUser.streamUrl || '');
      const streamUrlValid = isValidStreamUrl(normalizedStreamUrl);
      if(!streamUrlValid){
        if(status) status.textContent = 'Add a valid stream link to enable Live.';
        updateStreamControlsFromInput();
        return;
      }
      draftProfile = draftProfile || cloneProfile(currentUser) || {};
      const nextIsLive = !(draftProfile.isLive ?? currentUser.isLive ?? false);
      const nextLiveStartedAt = nextIsLive ? (draftProfile.liveStartedAt || currentUser.liveStartedAt || currentUser.liveSince || new Date().toISOString()) : null;
      draftProfile.streamUrl = normalizedStreamUrl;
      draftProfile.isLive = nextIsLive;
      draftProfile.liveStartedAt = nextLiveStartedAt;
      const previousProfile = currentUser;
      currentUser = applyAdminFlag({ ...currentUser, ...draftProfile, streamUrl: normalizedStreamUrl, isLive: nextIsLive, liveStartedAt: nextLiveStartedAt });
      await persistAdminFlagIfNeeded(previousProfile, currentUser);
      try{
        if(status) status.textContent = nextIsLive ? 'Going live...' : 'Ending live...';
        await persistCurrentUserProfile();
        refreshLiveNowUsers();
        renderProfile();
        setupEventListeners();
        if(status) status.textContent = nextIsLive ? 'Live âœ…' : 'Offline âœ…';
      }catch(err){
        if(status) status.textContent = 'Live toggle failed âŒ: ' + (err.message || err);
        console.error('[profile] live toggle failed', err);
      }
    };

    function renderAuditView(){
      const auditEl = document.getElementById('auditView');
      if(!auditEl) return;
      if(!isAdmin()){ auditEl.innerHTML = '<div class="panel">Admin only</div>'; return; }
      const total = songs.length;
      const flaggedCount = songs.filter(s=>s.flags && s.flags.length).length;
      const camelotCount = Object.keys(camelotOverridesStore.ids||{}).length;
      const bpmCount = Object.keys(bpmOverridesStore.ids||{}).length;
      const okCount = total - flaggedCount;
      const filterMatches = (track)=>{
        const term = (auditSearch||'').toLowerCase();
        if(term && !(track.title.toLowerCase().includes(term) || track.artist.toLowerCase().includes(term))) return false;
        if(auditFilters.flaggedOnly && !(track.flags&&track.flags.length)) return false;
        if(auditFilters.overriddenOnly && !(track.camelotOverridden||track.bpmOverridden)) return false;
        if(auditFilters.invalidCamelot && !(track.flags||[]).includes('INVALID_CAMELOT')) return false;
        if(auditFilters.modeMismatch && !(track.flags||[]).includes('MODE_MISMATCH')) return false;
        if(auditFilters.bpmOutlier && !(track.flags||[]).includes('BPM_OUTLIER')) return false;
        return true;
      };
        const filtered = songs.filter(filterMatches);
        const rows = filtered.map(t=>{
          const flags = t.flags && t.flags.length ? t.flags.map(f=>`<span class="px-2 py-1 rounded bg-white/10 border border-white/10 text-xs mr-1">${f}</span>`).join('') : '<span class="text-green-300 text-xs">OK</span>';
          const hasOverride = genreOverrides[t.id];
          const genreButton = `<button data-song-id-genre="${t.id}" class="px-2 py-1 ${hasOverride ? 'bg-green-500/30 border-green-500/50' : 'bg-orange-500/30 border-orange-500/50'} border rounded text-xs cursor-pointer hover:border-cyan-400/60" title="Click to edit genre">${t.genre}${hasOverride ? ' âœ“' : ''}</button>`;
          return `<tr class="border-b border-white/5"><td class="p-2">${t.title}<div class="text-xs text-gray-400">${t.artist}</div></td><td class="p-2">${t.bpm} <div class="text-xs text-gray-400">raw ${t.rawBpm||t.bpm}</div></td><td class="p-2">${t.camelot}<div class="text-xs text-gray-400">derived ${t.derivedCamelot}</div></td><td class="p-2 text-xs text-gray-300">${t.rawKey||'?'} ${t.rawMode||''}</td><td class="p-2">${genreButton}</td><td class="p-2">${flags}</td><td class="p-2 text-xs"><button class="px-2 py-1 bg-purple-500/30 rounded" onclick="openOverrideModal('camelot','${t.id}')">Set Camelot</button><button class="ml-1 px-2 py-1 bg-blue-500/30 rounded" onclick="openOverrideModal('bpm','${t.id}')">Set BPM</button><button class="ml-1 px-2 py-1 bg-red-500/30 rounded" onclick="clearOverrides('${t.id}')">Clear</button></td></tr>`;
        }).join('');

      auditEl.innerHTML = `
        <div class="space-y-4">
          <div class="grid md:grid-cols-5 gap-3">
            <div class="panel p-3"><div class="text-xs text-gray-400">Total tracks</div><div class="text-2xl font-bold">${total}</div></div>
            <div class="panel p-3"><div class="text-xs text-gray-400">OK</div><div class="text-2xl font-bold text-green-300">${okCount}</div></div>
            <div class="panel p-3"><div class="text-xs text-gray-400">Flagged</div><div class="text-2xl font-bold text-amber-300">${flaggedCount}</div></div>
            <div class="panel p-3"><div class="text-xs text-gray-400">Camelot overrides</div><div class="text-2xl font-bold">${camelotCount}</div></div>
            <div class="panel p-3"><div class="text-xs text-gray-400">BPM overrides</div><div class="text-2xl font-bold">${bpmCount}</div></div>
          </div>
          <div class="panel p-3 space-y-3">
            <div class="flex flex-wrap gap-2 items-center">
              <input id="auditSearchInput" value="${auditSearch}" placeholder="Search title or artist" class="flex-1 min-w-[200px] px-3 py-2 bg-black/40 border border-white/10 rounded" />
            </div>
            <div class="flex flex-wrap gap-2 text-xs">
              <button class="px-3 py-1 rounded ${auditFilters.flaggedOnly?'bg-amber-500/40':'bg-white/10'}" onclick="toggleAuditFilter('flaggedOnly')">Show flagged only</button>
              <button class="px-3 py-1 rounded ${auditFilters.overriddenOnly?'bg-amber-500/40':'bg-white/10'}" onclick="toggleAuditFilter('overriddenOnly')">Show overridden only</button>
              <button class="px-3 py-1 rounded ${auditFilters.invalidCamelot?'bg-amber-500/40':'bg-white/10'}" onclick="toggleAuditFilter('invalidCamelot')">Invalid camelot</button>
              <button class="px-3 py-1 rounded ${auditFilters.modeMismatch?'bg-amber-500/40':'bg-white/10'}" onclick="toggleAuditFilter('modeMismatch')">Mode mismatch</button>
              <button class="px-3 py-1 rounded ${auditFilters.bpmOutlier?'bg-amber-500/40':'bg-white/10'}" onclick="toggleAuditFilter('bpmOutlier')">BPM outliers</button>
            </div>
          </div>
          <div class="panel overflow-auto">
            <table class="w-full text-sm">
              <thead class="text-left text-gray-300">
                <tr><th class="p-2">Title</th><th class="p-2">BPM</th><th class="p-2">Camelot</th><th class="p-2">Raw key/mode</th><th class="p-2">Genre</th><th class="p-2">Flags</th><th class="p-2">Actions</th></tr>
              </thead>
              <tbody>${rows}</tbody>
            </table>
          </div>
          <div class="panel text-xs text-gray-300">
            <div class="font-semibold text-white mb-1">Debug</div>
            <div>Firebase enabled: ${firebaseEnabled}</div>
            <div>User key: ${computeUserKey()}</div>
            <div>Songs loaded: ${songs.length}</div>
            <div>Overrides loaded: ${camelotCount} camelot / ${bpmCount} bpm</div>
          </div>
        </div>
      `;
      bindGenreEditors(auditEl);
    }

    function updateBandReferencesLocal(oldUsername,newUsername,newDj){
      const profiles = JSON.parse(localStorage.getItem('userProfiles')||'{}');
      Object.keys(profiles).forEach(key=>{
        const memberList = profiles[key].bandMembers || [];
        const updated = memberList.map(m=> m.username===oldUsername ? { ...m, username:newUsername, djName:newDj } : m);
        profiles[key].bandMembers = updated;
      });
      localStorage.setItem('userProfiles', JSON.stringify(profiles));
      bandMembers = (bandMembers||[]).map(m=> m.username===oldUsername ? { ...m, username:newUsername, djName:newDj } : m);
      currentUser.bandMembers = bandMembers;
    }

    async function saveProfileSettings(){
      if(viewingProfile){ const status = document.getElementById('profileStatus'); if(status) status.textContent = 'View-only mode: cannot save this profile.'; return; }
      if(!currentUser) return;
      if(!profileEditMode) return;
      const status = document.getElementById('profileStatus');
      const newUsername = (document.getElementById('profileUsername')?.value || '').trim();
      const newDjName = (document.getElementById('profileDjName')?.value || '').trim() || newUsername;
      const streamUrlInput = (document.getElementById('profileStreamUrl')?.value || '').trim();
      const normalizedStreamUrl = normalizeStreamUrlInput(streamUrlInput);
      const streamUrlValid = isValidStreamUrl(normalizedStreamUrl);
      const existingLiveStartedAt = draftProfile?.liveStartedAt || currentUser.liveStartedAt || currentUser.liveSince || null;
      const nextIsLive = streamUrlValid ? (draftProfile?.isLive ?? currentUser.isLive ?? false) : false;
      const nextLiveStartedAt = nextIsLive ? (existingLiveStartedAt || new Date().toISOString()) : null;
      if(!usernamePattern.test(newUsername)){
        if(status) status.textContent = 'Username must be 3-20 chars, letters/numbers/underscore only';
        alert('Username must be 3-20 chars, letters/numbers/underscore only');
        return;
      }
      draftProfile = draftProfile || cloneProfile(currentUser) || {};
      draftProfile.username = newUsername;
      draftProfile.djName = newDjName;
      draftProfile.streamUrl = normalizedStreamUrl;
      draftProfile.isLive = nextIsLive;
      draftProfile.liveStartedAt = nextLiveStartedAt;
      currentUser = { ...currentUser, streamUrl: normalizedStreamUrl, isLive: nextIsLive, liveStartedAt: nextLiveStartedAt };
      const previousUsername = currentUser.username;
      const usernameChanged = newUsername !== currentUser.username;
      const djChanged = newDjName !== currentUser.djName;
      try{
        if(status) status.textContent = 'Saving profile...';
        const previousProfile = currentUser;
        currentUser = applyAdminFlag({ ...currentUser, ...draftProfile, username:newUsername, djName:newDjName });
        await persistAdminFlagIfNeeded(previousProfile, currentUser);
        if(usernameChanged || djChanged) updateBandReferencesLocal(previousUsername, newUsername, newDjName);
        console.log('[profile-save] streamUrl=', currentUser.streamUrl);
        await persistCurrentUserProfile();
        refreshLiveNowUsers();
        render(); setupEventListeners();
        const statusEl = document.getElementById('profileStatus');
        if(statusEl) statusEl.textContent = 'Saved âœ…';
      }catch(e){ const statusEl = document.getElementById('profileStatus'); if(statusEl) statusEl.textContent = 'Save failed âŒ: ' + (e.message||e); console.error('[profile] save failed', e); }
    }


function renderCommunityStat(id, label, icon, value, caption=''){
  return `<div class="flex items-center justify-between px-3 py-2 rounded-lg border border-white/10 bg-white/5">
    <div class="flex items-center gap-2">
      <span>${icon}</span>
      <div class="flex flex-col leading-tight">
        <span class="text-[10px] uppercase tracking-wide text-gray-300">${label}</span>
        <span class="text-sm font-bold text-white" data-community-stat="${id}">${formatStatValue(value)}</span>
      </div>
    </div>
    ${caption ? `<span class="text-[11px] text-cyan-100/80">${caption}</span>` : ''}
  </div>`;
}

function render(){
  logEvent('ui_render', { view });
  if(view === 'audit' && !isAdmin()){
    alert('Admin only');
    view = 'browser';
  }
  currentUser = getActiveProfile() || currentUser;
  if(!isAdmin() && adminMenuOpen){
    adminMenuOpen = false;
  }
  syncAdminGlobals();
  const displayTracks = viewingProfile ? viewingProfile.ownedTracks || [] : ownedTracks;
  const ownedCount = displayTracks.length;
  const ownedLibraryStatusMessage = resolveOwnedLibraryStatusMessage();
  const ownedLibraryBadge = ownedLibraryStatusMessage
    ? `<span class="${ownedLibraryState.phase === 'restoring' ? 'inline-flex items-center gap-1 px-2 py-1 rounded-full text-[10px] font-semibold bg-white/10 border border-white/20 text-cyan-100' : 'text-[11px] text-cyan-100/90'}">${ownedLibraryStatusMessage}</span>`
    : '';
  const networkBadge = `<span data-network-badge class="${isOffline ? 'inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold bg-red-600/30 border border-red-400/60 text-red-100' : 'inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold bg-emerald-600/30 border border-emerald-400/60 text-emerald-100'}">${isOffline ? 'Offline' : 'Online'}</span>`;
  const trackSourceLabel = trackSource === 'cache' ? 'Cached tracks' : trackSource === 'fallback' ? 'Sample tracks' : 'Live tracks';
  const trackSourceBadge = `<span class="inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold bg-white/10 border border-white/20 text-cyan-100">ðŸŽµ ${trackSourceLabel}</span>`;
  const cloudSyncBadge = (firebaseEnabled && firebaseAuth?.currentUser)
    ? `<span class="inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold ${isOffline ? 'bg-amber-500/20 border border-amber-300/60 text-amber-100' : 'bg-sky-500/20 border border-sky-400/50 text-sky-100'}">â˜ï¸ ${isOffline ? 'Cloud Sync unavailable offline' : 'Cloud Sync: ON'}</span>`
    : `<span class="inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold bg-slate-500/20 border border-slate-300/40 text-slate-100">ðŸ“¦ Local Only</span>`;
  const adminBadge = isAdmin() ? `<span class="ml-2 px-2 py-1 text-xs rounded border border-cyan-400/40 text-cyan-100 bg-white/5">ðŸ›¡ Admin</span>` : '';
  const syncBanner = profileSyncState?.syncing
    ? `<div class="inline-banner mt-2">ðŸ”„ ${profileSyncState.message || 'Syncing your profileâ€¦'}</div>`
    : '';
  const communityStatsRow = FEATURE_SIGNIN_STATS
    ? `
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2 mt-2 text-xs">
      ${renderCommunityStat('totalDjs','TOTAL DJS','ðŸŽ›ï¸', communityStats.totalDjs)}
    </div>`
    : '';
  const regressionBanner = (isAdmin() && regressionWarnings.length) ? `<div class="mt-2 p-3 rounded-lg border border-amber-400/40 bg-amber-500/10 text-amber-100 text-sm">Regression alerts: ${regressionWarnings.map(r=>`${r.id}â†’${r.expectedCamelot}`).join(', ')}</div>` : '';
  const selectedPanel = `
    <div class="panel ${selectedSong ? 'selected-panel' : ''} space-y-3 dim-when-sticky">
      <div class="flex items-center justify-between">
        <div class="font-bold text-white">Selection</div>
        <span class="text-xs text-cyan-100">${selectedSong ? 'Pinned track' : 'No track selected'}</span>
      </div>
      <div class="flex items-start gap-3">
        <div class="w-12 h-12 rounded-lg flex items-center justify-center text-lg font-bold" style="background:${selectedSong ? (camelotColors[selectedSong.camelot] || '#0ea5e9') : 'rgba(255,255,255,0.08)'};color:#fff;">${selectedSong ? selectedSong.camelot : 'â€”'}</div>
        <div class="flex-1">
          <div class="font-bold text-white">${selectedSong ? selectedSong.title : 'Select a track to pin it'}</div>
          <div class="text-sm text-gray-300">${selectedSong ? selectedSong.artist : 'Songs stay visible while you filter.'}</div>
          <div class="text-xs text-cyan-100 font-semibold mt-1">${selectedSong ? `BPM: ${selectedSong.bpm} â€¢ Camelot: ${selectedSong.camelot}` : 'Click any card or Select to choose.'}</div>
        </div>
      </div>
      <div class="flex flex-wrap gap-2">
        <button id="panelClearSelectionBtn" onclick="clearSelection()" class="px-3 py-2 bg-white/10 hover:bg-white/20 border border-cyan-400/60 rounded-lg font-semibold text-cyan-100" ${selectedSong ? '' : 'disabled style="opacity:0.55;cursor:not-allowed;"'}>Clear Selection</button>
        <button id="panelClearSearchBtn" onclick="clearSearch()" class="px-3 py-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded-lg font-semibold text-white" ${searchTerm ? '' : 'disabled style="opacity:0.55;cursor:not-allowed;"'}>Clear Search</button>
        <button id="panelDisableMixableBtn" onclick="disableMixable()" class="px-3 py-2 rounded-lg font-semibold border ${showMixableOnly?'border-cyan-300 bg-cyan-500/20 text-cyan-100':'border-white/20 bg-white/5 text-gray-300'}" ${showMixableOnly ? '' : 'disabled style="opacity:0.55;cursor:not-allowed;"'}>${showMixableOnly ? 'Disable Mixable' : 'Mixable Off'}</button>
      </div>
    </div>`;
  const adminLabel = currentUser?.isAdmin ? ' â€¢ ADMIN' : '';
  const signedLabel = viewingProfile ? `Viewing ${viewingProfile.djName || viewingProfile.username || 'Profile'}${adminLabel}` : `Signed in as ${currentUser ? currentUser.djName : 'Guest'}${adminLabel}`;
  const authButtonLabel = firebaseAuth?.currentUser ? 'Logout' : 'Sign In';
  const authButtonAction = firebaseAuth?.currentUser ? 'logoutUser()' : 'showLoginScreen()';
  const stickyCtaActive = getStickyCtaConfig().visible;
  document.getElementById('app').innerHTML = `
    <div class="min-h-screen ${stickyCtaActive ? 'sticky-cta-active' : ''}" id="appRoot">
      <header class="bg-black/70 backdrop-blur-xl border-b border-cyan-500/30 sticky top-0 z-50 shadow-lg safe-header">
        <div class="max-w-[1400px] mx-auto px-4 py-4">
          <div class="flex items-center justify-between gap-4 flex-wrap">
            <div class="flex items-center gap-3">
              <div class="w-12 h-12 bg-gradient-to-br from-pink-500 via-purple-500 to-cyan-500 rounded-lg flex items-center justify-center text-2xl vinyl-spin">ðŸŽµ</div>
              <div>
                <h1 class="text-2xl font-bold text-white graffiti-text">${BRAND.APP_NAME.toUpperCase()}</h1>
                <div class="text-xs text-cyan-200 font-semibold">Festival Pro Mixer 1.2</div>
              </div>
            </div>
            <div class="flex items-center flex-wrap justify-end header-actions">
              <button class="mobile-only px-3 py-2 bg-white/10 border border-white/20 rounded-lg text-xs text-white" data-action="toggleHeaderMore">More</button>
              ${viewingProfile?`<button onclick="exitProfileViewMode()" class="px-3 py-2 bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/40 rounded-lg text-purple-100 text-sm">Back to my profile</button>`:''}
              ${(!viewingProfile && isAdmin())?`<div class="relative"><button id="adminToolsBtn" aria-haspopup="true" aria-expanded="${adminMenuOpen}" class="px-3 py-2 bg-cyan-500/20 hover:bg-cyan-500/30 border border-cyan-400/50 rounded-lg text-cyan-100 text-sm flex items-center gap-2" style="pointer-events:auto;cursor:pointer;">ðŸ› ï¸ Admin Tools</button>${adminMenuOpen?`<div id="adminToolsMenu" role="menu" class="admin-tools-menu absolute right-0 mt-2 w-56 bg-black/90 border border-cyan-400/30 rounded-lg shadow-xl ring-1 ring-cyan-400/30 p-2 space-y-2" style="z-index:6000;pointer-events:auto;">
                  <button id="adminMenuHelpEditor" role="menuitem" class="w-full text-left px-3 py-2 rounded-md bg-white/5 hover:bg-cyan-500/20 border border-white/10 text-sm">Help Editor</button>
                  <button id="adminMenuWhatsNewEditor" role="menuitem" class="w-full text-left px-3 py-2 rounded-md bg-white/5 hover:bg-cyan-500/20 border border-white/10 text-sm">Whatâ€™s New Editor</button>
                  <button id="adminMenuAudit" role="menuitem" class="w-full text-left px-3 py-2 rounded-md bg-white/5 hover:bg-cyan-500/20 border border-white/10 text-sm">Data Audit (Key/BPM)</button>
                </div>`:''}</div>`:''}
              <button onclick="openProfileView()" class="px-3 py-2 bg-purple-500/20 hover:bg-purple-500/30 border border-purple-500/50 rounded-lg text-purple-200 text-sm">Profile</button>
              <button onclick="openHelp()" class="px-3 py-2 bg-white/6 hover:bg-white/12 border border-cyan-500/20 rounded-lg text-cyan-200 text-sm">â“ Help</button>
              <button onclick="${authButtonAction}" class="px-3 py-2 bg-red-500/20 hover:bg-red-500/30 border border-red-500/50 rounded-lg text-red-300 text-sm">${authButtonLabel}</button>
            </div>
          </div>
          <div class="header-secondary ${headerMoreOpen ? 'is-open' : ''}">
            <div class="flex items-center flex-wrap gap-2">
              <p id="ownedCount" class="text-xs text-cyan-300 font-semibold">Owned: ${ownedCount}/${songs.length}</p>
              ${ownedLibraryBadge}
              ${networkBadge}
              ${trackSourceBadge}
              ${cloudSyncBadge}
              <div class="text-sm text-gray-200">${signedLabel}${adminBadge}</div>
            </div>
            ${communityStatsRow}
          </div>
        </div>
      </header>

      <main class="max-w-[1400px] mx-auto px-4 py-6 space-y-4" style="padding-bottom: calc(6rem + var(--safe-bottom));">
        <div class="flex items-center justify-between gap-3 flex-wrap">
          <div class="flex gap-2 flex-wrap">
            <button id="browserBtn" data-action="switchView" data-view="browser" class="px-4 py-2 rounded-lg font-medium transition ${view==='browser'?'bg-gradient-to-r from-purple-500 to-pink-500':'bg-white/10 hover:bg-white/20'}">Browse</button>
            <div class="flex items-center gap-1">
              <button id="setlistBtn" data-action="switchView" data-view="setlist" class="px-4 py-2 rounded-lg font-medium transition ${view==='setlist'?'bg-gradient-to-r from-purple-500 to-pink-500':'bg-white/10 hover:bg-white/20'}">Setlist (<span id="setlistCount">${setlist.length}</span>)</button>
              <button type="button" class="helpIconBtn" onclick="openHelpModal({ source: 'setlist_icon', target: 'setlist' })" aria-label="Open help: Setlist" title="How Setlist works">?</button>
            </div>
            <button id="profileBtn" data-action="switchView" data-view="profile" class="px-4 py-2 rounded-lg font-medium transition ${view==='profile'?'bg-gradient-to-r from-indigo-500 to-blue-500':'bg-white/10 hover:bg-white/20'}">Profile</button>
          </div>
          ${view==='browser'?`<div class="text-sm text-cyan-200 font-semibold">Selected: ${selectedSong ? selectedSong.title : 'None'}</div>`:''}
        </div>
        <div class="flex items-center gap-2 flex-wrap text-sm text-cyan-100">
          ${networkBadge}
          ${trackSourceBadge}
          ${cloudSyncBadge}
          <span class="text-xs text-gray-300">Offline browsing pulls your last cached tracks.</span>
        </div>

        ${syncBanner}
        ${regressionBanner}
        <div id="browserView" style="display:${view==='browser'?'block':'none'}">
          <div class="grid lg:grid-cols-[350px,1fr] gap-4 items-start">
            <div class="space-y-4">
              <div class="panel space-y-3 dim-when-sticky">
                <div class="flex items-center justify-between">
                  <div class="font-bold text-white">Controls</div>
                  <span class="text-xs text-gray-300">${viewingProfile ? 'Shared profile (view only)' : 'Your library'}</span>
                </div>
                <div class="relative">
                  <input type="text" id="searchInput" value="${searchTerm || ''}" placeholder="ðŸ” Search songs" class="w-full px-4 py-3 pr-12 bg-black/40 backdrop-blur-sm border border-cyan-500/30 rounded-xl text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500"/>
                  <button id="clearSearchBtn" class="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 hover:text-white transition text-xl" style="display:none;">âœ•</button>
                </div>
                <div id="searchStatus" class="text-xs text-cyan-200" style="display:none;">Filteringâ€¦</div>
                <div class="flex flex-wrap gap-2">
                  <button id="mixableFilterBtn" class="px-3 py-2 rounded-lg font-medium transition ${showMixableOnly?'bg-gradient-to-r from-blue-500 to-cyan-500':'bg-white/10 hover:bg-white/20'}">${showMixableOnly? 'ðŸŽ§ Mixable Only' : 'Show Mixable'}</button>
                  <button id="ownedFilterBtn" class="px-3 py-2 rounded-lg font-medium transition ${showOwnedOnly?'bg-gradient-to-r from-green-500 to-emerald-500':'bg-white/10 hover:bg-white/20'}">${showOwnedOnly? 'âœ“ Owned Only' : 'Show All'}</button>
                  <button id="controlClearSelectionBtn" onclick="clearSelection()" class="px-3 py-2 bg-white/10 hover:bg-white/20 border border-cyan-400/60 rounded-lg font-semibold text-cyan-100" ${selectedSong ? '' : 'disabled style="opacity:0.55;cursor:not-allowed;"'}>Clear Selection</button>
                </div>
                <div id="mixableInlineNotice" class="inline-banner" style="display:${mixableInlineNotice ? 'block' : 'none'};">${mixableInlineNotice}</div>
                ${!viewingProfile?`<div class="flex flex-wrap gap-2">
                  <button id="markAllBtn" class="px-3 py-2 bg-white/10 hover:bg-white/20 rounded-lg">Mark All Owned</button>
                  <button id="clearAllBtn" class="px-3 py-2 bg-white/10 hover:bg-white/20 rounded-lg">Clear All</button>
                </div>`:''}
                <div class="bg-black/40 border border-white/10 rounded-lg p-3 space-y-3">
                  <div class="flex items-center justify-between flex-wrap gap-2">
                    <div class="text-sm font-semibold text-white">Key Mode</div>
                    <span class="text-[11px] text-gray-400">Harmonic preference</span>
                  </div>
                  <div class="grid sm:grid-cols-2 gap-3">
                    <label class="flex flex-col gap-1 text-xs text-gray-300">
                      <span class="font-semibold text-white">Key Matching</span>
                      <select id="keyMatchModeSelect" class="px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-sm text-white">
                        <option value="camelot">Camelot (DJ Wheel)</option>
                        <option value="semitone">Key (Same Mode Â±0â€“6)</option>
                      </select>
                    </label>
                    <label class="flex flex-col gap-1 text-xs text-gray-300">
                      <span class="font-semibold text-white">Â± Range</span>
                      <input id="semitoneRangeInput" type="range" min="1" max="6" step="1" value="${maxSemitoneRange}" class="accent-cyan-400" />
                      <div id="semitoneRangeValue" class="text-[11px] text-cyan-200 font-semibold">Â±${maxSemitoneRange} semitones</div>
                    </label>
                  </div>
                  <div class="flex items-center justify-between gap-2 flex-wrap text-sm text-gray-200">
                    <div>
                      <div class="font-semibold text-white">Include Opposite Mode</div>
                      <div class="text-[11px] text-gray-400">Opposite mode ranks after all same-mode matches</div>
                    </div>
                    <label class="inline-flex items-center gap-2 text-xs">
                      <input id="includeOppositeModeToggle" type="checkbox" class="w-5 h-5 accent-cyan-400" ${includeOppositeMode ? 'checked' : ''} />
                      <span>Include</span>
                    </label>
                  </div>
                  <p class="text-[11px] text-gray-400">Semitone mode prioritizes the most natural-sounding blends; Camelot is better for DJ-style key transitions.</p>
                </div>
              </div>
              <div class="panel space-y-3 dim-when-sticky">
                <div class="flex items-center justify-between">
                  <div class="font-bold text-white">Mix Logic</div>
                  <span class="text-xs text-gray-300">Priority selector</span>
                </div>
                <div class="flex flex-wrap gap-2">
                  <button onclick="setSortMode('bpm')" class="px-3 py-2 rounded-lg text-sm font-semibold border ${sortMode==='bpm'?'border-cyan-400 bg-cyan-500/20 text-cyan-100':'border-white/10 bg-white/5 text-gray-200'}">Tempo (BPM)</button>
                  <button onclick="setSortMode('camelot')" class="px-3 py-2 rounded-lg text-sm font-semibold border ${sortMode==='camelot'?'border-pink-400 bg-pink-500/20 text-pink-100':'border-white/10 bg-white/5 text-gray-200'}">Camelot</button>
                  <button onclick="setSortMode('genre')" class="px-3 py-2 rounded-lg text-sm font-semibold border ${sortMode==='genre'?'border-emerald-400 bg-emerald-500/20 text-emerald-100':'border-white/10 bg-white/5 text-gray-200'}">Genre</button>
                </div>
                <div class="flex items-center gap-2">
                  <div class="text-xs text-gray-300 font-semibold">Priority Strength</div>
                  <div class="flex items-center gap-2 flex-1">
                    <span class="text-[11px] text-gray-500">Low</span>
                    <input type="range" min="0" max="2" step="1" value="${priorityStrength==='low'?0:priorityStrength==='high'?2:1}" class="flex-1 accent-cyan-400" oninput="setPriorityStrength(this.value)" aria-label="Priority Strength" />
                    <span class="text-[11px] text-gray-500">High</span>
                  </div>
                  <div class="text-[11px] px-2 py-1 rounded bg-white/10 border border-white/10 text-cyan-200 font-semibold">${priorityStrength==='low'?'Low':priorityStrength==='high'?'High':'Medium'}</div>
                </div>
              </div>

              ${selectedPanel}

              <div class="panel space-y-2 dim-when-sticky">
                <div class="flex items-center justify-between">
                  <div class="font-bold text-white">Sandbox (Drag tracks here)</div>
                  <div class="flex items-center gap-2 text-xs text-gray-300">
                    <span>Limit 4</span>
                    <button onclick="clearSandbox()" class="px-2 py-1 bg-white/10 hover:bg-white/20 rounded border border-white/10">Clear</button>
                  </div>
                </div>
                <div id="sandbox" class="sandbox-drop bg-black/40"></div>
                <div id="sandboxInfo" class="small-muted"></div>
              </div>
            </div>

            <div class="space-y-4">
              <div class="flex items-center justify-between flex-wrap gap-3">
                <div class="text-xl font-bold text-white">Song Browser</div>
                <div class="text-sm text-cyan-200 font-semibold">Selected: ${selectedSong ? selectedSong.title : 'None'}</div>
              </div>
              <div id="songList" class="space-y-4"></div>
            </div>
          </div>
        </div>

        <div id="setlistView" style="display:${view==='setlist'?'block':'none'}">
          <div id="setlistContent"></div>
        </div>
        <div id="profileView" style="display:${view==='profile'?'block':'none'}"></div>
        <div id="auditView" style="display:${view==='audit'?'block':'none'}"></div>
      </main>
      <div id="stickyCtaBar" class="sticky-cta-bar hidden" aria-live="polite">
        <button id="stickyCtaButton" class="sticky-cta-button" data-action="stickyCta" type="button"></button>
        <div id="stickyCtaCopy" class="sticky-cta-copy"></div>
      </div>
    </div>
  `;
  if(view==='browser'){ renderSongList(); sandboxInit(); renderSandbox(); } else if(view==='setlist'){ renderSetlist(); } else if(view==='audit'){ renderAuditView(); } else { renderProfile(); }
  syncCommunityStatsUI();
  bindTourEvents();
  updateTourUI();
  updateStickyCTA();
  maybeAutoOpenQuickStart();
}


    // ------------------ Genre context menu ------------------------
    function showGenreMenu(songId,event){
      if(!currentUser?.isAdmin) { alert('ðŸ”’ Admin only.'); return; }
      const existing = document.getElementById('genreContextMenu'); if(existing) existing.remove();
      const menu=document.createElement('div'); menu.id='genreContextMenu'; menu.className='context-menu';
      const anchor = getEventElement(event) || event.currentTarget;
      if(!anchor?.getBoundingClientRect) return;
      const rect = anchor.getBoundingClientRect();
      let left=rect.left, top=rect.bottom+5;
      if(left+220>window.innerWidth) left=rect.right-220;
      if(top+300>window.innerHeight) top=rect.top-305;
      menu.style.left = left+'px'; menu.style.top = top+'px';
      const genres = Object.keys(genreMap).concat(['Other']);
      menu.innerHTML = `<div style="padding:8px 12px;color:#00d9ff;font-weight:bold;border-bottom:1px solid rgba(0,217,255,0.3);margin-bottom:6px;">Select Genre:</div>`;
      genres.forEach(g=>{
        const btn=document.createElement('button'); btn.textContent=g; btn.style.display='block'; btn.style.width='100%'; btn.style.padding='8px 12px'; btn.style.background='transparent'; btn.style.border='none'; btn.style.textAlign='left'; btn.style.color='#e6f7ff'; btn.style.cursor='pointer';
        btn.addEventListener('click',async()=>{ await setGenreOverride(songId,g); menu.remove(); });
        menu.appendChild(btn);
      });
      document.body.appendChild(menu);
      setTimeout(()=>{
        const closeMenu = (e)=>{
          const target = getEventElement(e);
          if(!target || !menu.contains(target)){
            menu.remove();
            document.removeEventListener('click', closeMenu);
          }
        };
        document.addEventListener('click', closeMenu);
      },100);
    }

    function bindGenreEditors(scope=document){
      if(!isAdmin()) return;
      scope.querySelectorAll('[data-song-id-genre]').forEach(btn=>{
        const handler = (e)=>{ e.preventDefault(); e.stopPropagation(); const songId = btn.getAttribute('data-song-id-genre'); showGenreMenu(songId, e); };
        btn.onclick = handler;
        btn.oncontextmenu = handler;
      });
    }

    const setGenreOverride = async (songId,newGenre) => {
      if(!isAdmin()) return alert('Admin only');
      if(!currentUser && firebaseAuth?.currentUser){
        const tempProfile = normalizeProfileShape({
          username: firebaseAuth.currentUser.email?.split('@')[0] || firebaseAuth.currentUser.uid || 'admin',
          djName: firebaseAuth.currentUser.displayName || firebaseAuth.currentUser.email || 'Admin',
          ownedTracks,
          genreOverrides,
          isAdmin: false
        }, firebaseAuth.currentUser.uid || firebaseAuth.currentUser.email);
        const appliedProfile = applyAdminFlag(tempProfile);
        await persistAdminFlagIfNeeded(tempProfile, appliedProfile);
        currentUser = appliedProfile;
        refreshDraftProfileFromCurrentUser();
      }
      if(!currentUser) return alert('Sign in required for admin edits');
      genreOverrides[songId] = newGenre;
      const song = songs.find(s=>s.id===songId);
      if(song){
        song.genre = newGenre;
        refreshSongOverrides(song);
      }
      scheduleProfileCacheSync();
      refreshRegressionWarnings();
      renderAuditView();
      renderSongList();
      const genreTag = document.querySelector(`[data-genre-tag="${songId}"]`);
      if(genreTag){ genreTag.textContent = newGenre + ' âœ“'; genreTag.classList.add('animate-pulse'); setTimeout(()=>genreTag.classList.remove('animate-pulse'),1000); }
    };

    function toggleAuditFilter(key){ auditFilters[key] = !auditFilters[key]; renderAuditView(); }
    function closeOverrideModal(){ const m=document.getElementById('overrideModal'); if(m) m.remove(); }
    const openOverrideModal = (type, trackId)=>{
      if(!isAdmin()) return alert('Admin only');
      const track = songs.find(s=>s.id===trackId); if(!track) return;
      closeOverrideModal();
      const modal=document.createElement('div'); modal.id='overrideModal'; modal.className='fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50';
      const options = Array.from({length:12},(_,i)=>`${i+1}A`).concat(Array.from({length:12},(_,i)=>`${i+1}B`));
      const camelotSelect = `<select id="camelotSelect" class="w-full px-3 py-2 bg-black/60 border border-white/20 rounded">${options.map(o=>`<option value="${o}" ${track.camelot===o?'selected':''}>${o}</option>`).join('')}</select>`;
      const bpmInput = `<input id="bpmInput" type="number" value="${Math.round(track.bpm)}" class="w-full px-3 py-2 bg-black/60 border border-white/20 rounded"/>`;
      const actionCall = type==='camelot' ? `setCamelotOverride('${trackId}', document.getElementById('camelotSelect').value)` : `setBpmOverride('${trackId}', document.getElementById('bpmInput').value)`;
      modal.innerHTML = `<div class="panel max-w-md w-full">
        <div class="flex items-center justify-between mb-3"><div class="font-bold">Set ${type==='camelot'?'Camelot':'BPM'} for ${track.title}</div><button onclick="closeOverrideModal()">âœ•</button></div>
        <div class="space-y-3">
          ${type==='camelot'?camelotSelect:bpmInput}
          <div class="flex gap-2 justify-end">
            <button class="px-3 py-2 bg-white/10 rounded" onclick="closeOverrideModal()">Cancel</button>
            <button class="px-3 py-2 bg-blue-500/60 rounded" onclick="${actionCall}; closeOverrideModal();">Save</button>
          </div>
        </div>
      </div>`;
      document.body.appendChild(modal);
    };

    function syncAdminGlobals(){
      const adminActive = isAdmin();
      const adminFunctions = { toggleAdminTools, openOverrideModal, clearOverrides, setCamelotOverride, setBpmOverride, setGenreOverride, openAdminHelpEditor, openAdminWhatsNewEditor };
      Object.entries(adminFunctions).forEach(([name, fn])=>{
        if(adminActive){ window[name] = fn; }
        else {
          try { delete window[name]; } catch(_) { window[name] = undefined; }
        }
      });
    }

    // ------------------ Event listeners and interactions --------------
    let appDelegatesBound = false;
    function bindAppDelegates(){
      if(appDelegatesBound) return;
      const app = document.getElementById('app');
      if(!app) return;
      app.addEventListener('click', safeOn('click', (e)=>{
        if(closestFromEvent(e, '#mixableFilterBtn', { within: app })){ toggleMixableFilter(); return; }
        if(closestFromEvent(e, '#ownedFilterBtn', { within: app })){ toggleOwnedFilter(); return; }
        if(closestFromEvent(e, '#clearSearchBtn', { within: app }) || closestFromEvent(e, '#panelClearSearchBtn', { within: app })){ clearSearch(); return; }
        if(closestFromEvent(e, '[data-action="clearFilters"]', { within: app })){ clearFilters(); return; }
        if(closestFromEvent(e, '[data-action="openQuickStart"]', { within: app })){ openQuickStart(); return; }
        if(closestFromEvent(e, '[data-action="closeQuickStart"]', { within: app })){ closeQuickStart(); return; }
        if(closestFromEvent(e, '[data-action="quickStartSkip"]', { within: app })){ completeQuickStart({ skipped: true }); return; }
        if(closestFromEvent(e, '[data-action="quickStartBack"]', { within: app })){ moveQuickStartStep(-1); return; }
        const presetBtn = closestFromEvent(e, '[data-action="quickStartPreset"]', { within: app });
        if(presetBtn){
          const preset = presetBtn.dataset.preset;
          void applyQuickStartPreset(preset).then((applied)=>{
            if(applied){
              quickStartState.preset = preset;
              moveQuickStartStep(1);
            }
          });
          return;
        }
        const pickBtn = closestFromEvent(e, '[data-action="quickStartPickTrack"]', { within: app });
        if(pickBtn){
          const songId = pickBtn.dataset.songId || pickBtn.getAttribute('data-song-id');
          if(songId){
            selectedSong = songsById[songId] || songs.find(s=>s.id===songId) || null;
            refreshSelectedSongCriteria();
            showMixableOnly = true;
            matchHintMessage = 'These are your best matches.';
            render();
            setupEventListeners();
            const list = document.getElementById('songList');
            if(list) list.scrollIntoView({ behavior: 'smooth', block: 'start' });
            setTimeout(()=>{ matchHintMessage = ''; scheduleSongListRender('match-hint-clear'); }, 2600);
            completeQuickStart();
          }
          return;
        }
        if(closestFromEvent(e, '[data-action="mobileNextWindow"]', { within: app })){ shiftMobileWindow(1); return; }
        if(closestFromEvent(e, '[data-action="mobilePrevWindow"]', { within: app })){ shiftMobileWindow(-1); return; }
        const headerMoreBtn = closestFromEvent(e, '[data-action="toggleHeaderMore"]', { within: app });
        if(headerMoreBtn){ headerMoreOpen = !headerMoreOpen; render(); setupEventListeners(); return; }
        const stickyBtn = closestFromEvent(e, '[data-action="stickyCta"]', { within: app });
        if(stickyBtn){
          const action = stickyBtn.dataset.stickyAction || '';
          if(action === 'open-quickstart'){ openQuickStart(); return; }
          if(action === 'scroll-to-list'){
            const list = document.getElementById('songList');
            if(list){
              list.classList.add('song-list-highlight');
              list.scrollIntoView({ behavior: 'smooth', block: 'start' });
              setTimeout(()=>list.classList.remove('song-list-highlight'), 1500);
            }
            return;
          }
          if(action === 'mixable-warning'){
            setMixableInlineNotice('Select a song before enabling Mixable Only.');
            return;
          }
        }
        if(closestFromEvent(e, '#markAllBtn', { within: app }) && !viewingProfile){ markAllOwned(); return; }
        if(closestFromEvent(e, '#clearAllBtn', { within: app }) && !viewingProfile){ clearAllOwned(); return; }
        const genreBtn = closestFromEvent(e, '[data-genre-tag]', { within: app });
        if(genreBtn && isAdmin()){
          showGenreMenu(genreBtn.dataset.genreTag || genreBtn.getAttribute('data-genre-tag'), e);
          return;
        }
        const songAction = closestFromEvent(e, '[data-song-action]', { within: app });
        if(songAction){
          const action = songAction.dataset.songAction;
          const songId = songAction.dataset.songId || songAction.getAttribute('data-song-id');
          if(action === 'select' && songId){ selectSong(songId); return; }
          if(action === 'clear-selection'){ clearSelection(e); return; }
          if(action === 'toggle-owned' && songId){ toggleOwned(songId); return; }
          if(action === 'toggle-setlist' && songId){ addToSetlist(songId); return; }
          if(action === 'add-sandbox' && songId){ addToSandbox(songId); return; }
          if(action === 'preview' && songId){ onPreviewClick(songId); return; }
        }
      }, { action: 'app-click' }));
      app.addEventListener('input', safeOn('input', (e)=>{
        const target = getEventElement(e);
        if(!target) return;
        if(target.id === 'searchInput'){
          searchTerm = target.value;
          const clearSearchBtn = document.getElementById('clearSearchBtn');
          if(clearSearchBtn) clearSearchBtn.style.display = searchTerm ? 'block' : 'none';
          const panelClear = document.getElementById('panelClearSearchBtn');
          if(panelClear){ panelClear.disabled = !searchTerm; panelClear.style.opacity = searchTerm ? '1' : '0.55'; panelClear.style.cursor = searchTerm ? 'pointer' : 'not-allowed'; }
          const searchStatus = document.getElementById('searchStatus');
          if(searchStatus){ searchStatus.textContent = 'Filteringâ€¦'; searchStatus.style.display = 'block'; }
          if(searchDebounceTimer) clearTimeout(searchDebounceTimer);
          searchDebouncePending = true;
          searchDebounceTimer = setTimeout(()=>{
            resetMainPagination();
            updateMobileWindowState({ reset: true });
            scheduleSongListRender('search');
            searchDebouncePending = false;
            if(searchStatus){ searchStatus.style.display = 'none'; }
          }, 170);
        }
        if(target.id === 'auditSearchInput'){ auditSearch = target.value; renderAuditView(); }
        if(target.id === 'ownedSearchInput'){
          profileOwnedSearch = target.value;
          resetPage(profileOwnedPager);
          renderProfile();
        }
        if(target.id === 'profileUsername' && !viewingProfile){ draftProfile = draftProfile || cloneProfile(currentUser) || {}; draftProfile.username = target.value; }
        if(target.id === 'profileDjName' && !viewingProfile){ draftProfile = draftProfile || cloneProfile(currentUser) || {}; draftProfile.djName = target.value; }
        if(target.id === 'profileStreamUrl' && !viewingProfile){
          draftProfile = draftProfile || cloneProfile(currentUser) || {};
          draftProfile.streamUrl = target.value;
          updateStreamControlsFromInput();
        }
        if(target.id === 'profileBioInput' && !viewingProfile){
          const draft = updateDraftProfile({ bio: target.value.slice(0, PROFILE_BIO_MAX) });
          if(draft) updateBioCounter(draft.bio || '');
        }
        if(target.id === 'socialFriendSearchInput'){
          socialFriendSearchTerm = target.value;
          socialFriendSearchQuery = target.value.trim();
          socialFriendSearchError = '';
          if(socialFriendSearchNotice) setFriendSearchNotice('');
          if(socialFriendSearchDebounce) clearTimeout(socialFriendSearchDebounce);
          if(!socialFriendSearchQuery){
            socialFriendSearchResults = [];
            socialFriendSearchLoading = false;
            renderProfile();
            setupEventListeners();
            return;
          }
          socialFriendSearchDebounce = setTimeout(()=>{ handleFriendSearch(null, { explicit: false }); }, 300);
        }
        if(target.id === 'ratingCommentInput'){
          ratingDraft.comment = target.value;
          const countEl = document.getElementById('ratingCommentCount');
          if(countEl) countEl.textContent = `${ratingDraft.comment.length}/${RATING_MAX_COMMENT}`;
        }
        if(target.id === 'semitoneRangeInput'){ setMaxSemitoneRange(target.value); }
      }, { action: 'app-input' }));
      app.addEventListener('change', safeOn('change', (e)=>{
        const target = getEventElement(e);
        if(!target) return;
        if(target.id === 'keyMatchModeSelect'){ setKeyMatchMode(target.value); }
        if(target.id === 'includeOppositeModeToggle'){ toggleIncludeOppositeMode(target.checked); }
        if(target.id === 'profilePublicToggle' && !viewingProfile){
          updateDraftProfile({ isPublic: target.checked });
        }
        if(target.id === 'profileFriendRequestsToggle' && !viewingProfile){
          updateDraftProfile({ allowFriendRequests: target.checked });
        }
      }, { action: 'app-change' }));
      app.addEventListener('focusin', safeOn('focusin', (e)=>{
        const target = getEventElement(e);
        if(target?.id === 'searchInput'){
          isSearchFocused = true;
          updateStickyCTA();
        }
      }, { action: 'app-focusin' }));
      app.addEventListener('focusout', safeOn('focusout', (e)=>{
        const target = getEventElement(e);
        if(target?.id === 'searchInput'){
          isSearchFocused = false;
          updateStickyCTA();
        }
      }, { action: 'app-focusout' }));
      app.addEventListener('keydown', safeOn('keydown', (e)=>{
        const target = getEventElement(e);
        if(!target) return;
        if(target.id === 'friendSearchInput' && e.key === 'Enter'){ e.preventDefault(); viewFriendProfile(); }
        if(e.key === 'Escape' && !stickyCtaDismissed){
          stickyCtaDismissed = true;
          localStorage.setItem('jamMixer.stickyCtaDismissed', 'true');
          updateStickyCTA();
        }
      }, { action: 'app-keydown' }));
      app.addEventListener('contextmenu', safeOn('contextmenu', (e)=>{
        const target = closestFromEvent(e, '[data-song-id-genre]', { within: app });
        if(target && isAdmin()){
          e.preventDefault();
          showGenreMenu(target.dataset.songIdGenre || target.getAttribute('data-song-id-genre'), e);
        }
      }, { action: 'app-contextmenu' }));
      appDelegatesBound = true;
    }

    function bindQuickStartDelegates(){
      if(quickStartDelegatesBound) return;
      const modal = document.getElementById('quickStartModal');
      if(!modal) return;
      document.addEventListener('click', safeOn('click', (e)=>{
        const target = getEventElement(e);
        if(!target) return;
        if(target === modal){ closeQuickStart(); return; }
        if(closestFromEvent(e, '[data-action="closeQuickStart"]', { within: modal })){ closeQuickStart(); return; }
        if(closestFromEvent(e, '[data-action="quickStartSkip"]', { within: modal })){ completeQuickStart({ skipped: true }); return; }
        if(closestFromEvent(e, '[data-action="quickStartBack"]', { within: modal })){ moveQuickStartStep(-1); return; }
        const presetBtn = closestFromEvent(e, '[data-action="quickStartPreset"]', { within: modal });
        if(presetBtn){
          const preset = presetBtn.dataset.preset;
          void applyQuickStartPreset(preset).then((applied)=>{
            if(applied){
              quickStartState.preset = preset;
              moveQuickStartStep(1);
            }
          });
          return;
        }
        const pickBtn = closestFromEvent(e, '[data-action="quickStartPickTrack"]', { within: modal });
        if(pickBtn){
          const songId = pickBtn.dataset.songId || pickBtn.getAttribute('data-song-id');
          if(songId){
            selectedSong = songsById[songId] || songs.find(s=>s.id===songId) || null;
            refreshSelectedSongCriteria();
            showMixableOnly = true;
            matchHintMessage = 'These are your best matches.';
            render();
            setupEventListeners();
            const list = document.getElementById('songList');
            if(list) list.scrollIntoView({ behavior: 'smooth', block: 'start' });
            setTimeout(()=>{ matchHintMessage = ''; scheduleSongListRender('match-hint-clear'); }, 2600);
            completeQuickStart();
          }
        }
      }, { action: 'quick-start-modal-click' }));
      quickStartDelegatesBound = true;
    }

    function setupEventListeners(){
      bindUiDebugging();
      bindAppDelegates();
      bindQuickStartDelegates();
      bindProfileHandlers();
      updateProfileErrorBanner();
      runDelegationSelfTest();
      const searchInput = document.getElementById('searchInput');
      if(searchInput){
        const clearSearchBtn = document.getElementById('clearSearchBtn');
        if(clearSearchBtn){ clearSearchBtn.style.display = searchTerm ? 'block' : 'none'; }
      }
      const keyModeSelect = document.getElementById('keyMatchModeSelect'); if(keyModeSelect){ keyModeSelect.value = keyMatchMode; }
      const semitoneRangeInput = document.getElementById('semitoneRangeInput'); if(semitoneRangeInput){ semitoneRangeInput.value = maxSemitoneRange; }
      const includeOppToggle = document.getElementById('includeOppositeModeToggle'); if(includeOppToggle){ includeOppToggle.checked = includeOppositeMode; }
      if(isAdmin()){
        const adminBtn = document.getElementById('adminToolsBtn');
        if(adminBtn){
          adminBtn.onclick = (e)=>{ e.stopPropagation(); console.debug('[admin] Admin Tools clicked'); window.toggleAdminTools(); };
          console.debug('[admin] Admin Tools button bound');
        } else {
          console.debug('[admin] Admin Tools button missing after render');
        }
        const adminMenu = document.getElementById('adminToolsMenu');
        if(adminMenu){
          adminMenu.style.pointerEvents = 'auto';
          const helpBtn = document.getElementById('adminMenuHelpEditor');
          if(helpBtn) helpBtn.onclick = (e)=>{ e.stopPropagation(); openAdminHelpEditor(); toggleAdminTools(false); };
          const whatsNewBtn = document.getElementById('adminMenuWhatsNewEditor');
          if(whatsNewBtn) whatsNewBtn.onclick = (e)=>{ e.stopPropagation(); openAdminWhatsNewEditor(); toggleAdminTools(false); };
          const auditBtn = document.getElementById('adminMenuAudit');
          if(auditBtn) auditBtn.onclick = (e)=>{ e.stopPropagation(); openAuditFromMenu(); };
        }
      }
      setupLiveNowCarousel();
      updateRatingStarsUI();
      updateRatingTagsUI();
    }

    function setupLiveNowCarousel(){
      const carousel = document.getElementById('liveNowCarousel');
      if(!carousel || carousel.dataset.bound) return;
      carousel.dataset.bound = 'true';
      let isDown = false;
      let startX = 0;
      let scrollLeft = 0;
      carousel.addEventListener('mousedown', (e)=>{
        isDown = true;
        carousel.classList.add('dragging');
        startX = e.pageX - carousel.offsetLeft;
        scrollLeft = carousel.scrollLeft;
      });
      carousel.addEventListener('mouseleave', ()=>{
        isDown = false;
        carousel.classList.remove('dragging');
      });
      carousel.addEventListener('mouseup', ()=>{
        isDown = false;
        carousel.classList.remove('dragging');
      });
      carousel.addEventListener('mousemove', (e)=>{
        if(!isDown) return;
        e.preventDefault();
        const x = e.pageX - carousel.offsetLeft;
        const walk = (x - startX) * 1.2;
        carousel.scrollLeft = scrollLeft - walk;
      });
      carousel.addEventListener('wheel', (e)=>{
        if(Math.abs(e.deltaY) > Math.abs(e.deltaX)){
          carousel.scrollLeft += e.deltaY;
          e.preventDefault();
        }
      }, { passive: false });
    }

    let dataActionDelegatesBound = false;
    function handleDataAction(el, event){
      if(!el) return;
      const action = el.dataset?.action;
      if(!action) return;
      if(action === 'addSet'){
        const id = el.dataset?.id;
        if(!id) return;
        event?.preventDefault();
        addToSetlist(id);
        return;
      }
      if(action === 'removeSet'){
        const id = el.dataset?.id;
        if(!id) return;
        event?.preventDefault();
        removeFromSetlist(id);
        return;
      }
      if(action === 'switchView'){
        const viewName = el.dataset?.view;
        if(!viewName) return;
        event?.preventDefault();
        switchView(viewName);
      }
    }

    document.addEventListener('click', safeOn('click', (e) => {
      const el = closestFromEvent(e, '[data-action]');
      if (!el) return;
      handleDataAction(el, e);
    }, { action: 'data-action-click' }));

    document.addEventListener('keydown', safeOn('keydown', (e) => {
      if(e.key !== 'Enter' && e.key !== ' ') return;
      const el = closestFromEvent(e, '[data-action]');
      if (!el) return;
      e.preventDefault();
      handleDataAction(el, e);
    }, { action: 'data-action-keydown' }));
    dataActionDelegatesBound = true;

    window.setPriorityStrength = (val) => {
      const map = { '0':'low', '1':'medium', '2':'high', low:'low', medium:'medium', high:'high' };
      priorityStrength = map[val] || 'medium';
      persistKeyMatchSettings();
      render();
      setupEventListeners();
    };

    function persistKeyMatchSettings(){
      localStorage.setItem('jamMixer.keyMatchMode', keyMatchMode);
      localStorage.setItem('jamMixer.maxSemitoneRange', String(maxSemitoneRange));
      localStorage.setItem('jamMixer.includeOppositeMode', includeOppositeMode ? 'true' : 'false');
      localStorage.setItem('jamMixer.priorityStrength', priorityStrength);
      syncPreferencesIntoProfile();
      if(!isPersistingProfile) schedulePreferencePersist();
    }
    window.setKeyMatchMode = (mode) => {
      keyMatchMode = mode === 'semitone' ? 'semitone' : 'camelot';
      persistKeyMatchSettings();
      resetMainPagination();
      refreshSelectedSongCriteria();
      render();
      setupEventListeners();
    };
    window.setMaxSemitoneRange = (val) => {
      const num = Math.min(6, Math.max(1, Number(val) || 6));
      maxSemitoneRange = num;
      persistKeyMatchSettings();
      const rangeDisplay = document.getElementById('semitoneRangeValue');
      if(rangeDisplay){ rangeDisplay.textContent = `Â±${num} semitones`; }
      refreshSelectedSongCriteria();
      scheduleSongListRender('semitone-range');
    };
    window.toggleIncludeOppositeMode = (checked) => {
      includeOppositeMode = !!checked;
      persistKeyMatchSettings();
      refreshSelectedSongCriteria();
      scheduleSongListRender('include-opposite');
    };

    window.setSortMode = (mode) => {
      sortMode = mode;
      resetMainPagination();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    };

    window.selectSong = (id) => {
      selectedSong = songs.find(s=>s.id===id);
      resetMainPagination();
      refreshSelectedSongCriteria();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    };

    window.clearSelection = (event) => {
      if(event){ event.preventDefault(); event.stopPropagation(); }
      selectedSong = null;
      showMixableOnly = false;
      refreshSelectedSongCriteria();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    };

    window.disableMixable = () => {
      if(!showMixableOnly) return;
      showMixableOnly = false;
      render();
      setupEventListeners();
    };

    window.clearSearch = () => {
      searchTerm = '';
      if(searchDebounceTimer){ clearTimeout(searchDebounceTimer); searchDebounceTimer = null; }
      searchDebouncePending = false;
      const searchInput = document.getElementById('searchInput');
      const clearSearchBtn = document.getElementById('clearSearchBtn');
      if(searchInput) searchInput.value = '';
      if(clearSearchBtn) clearSearchBtn.style.display = 'none';
      const searchStatus = document.getElementById('searchStatus');
      if(searchStatus) searchStatus.style.display = 'none';
      const panelClearBtn = document.getElementById('panelClearSearchBtn');
      if(panelClearBtn){ panelClearBtn.disabled = true; panelClearBtn.style.opacity = '0.55'; panelClearBtn.style.cursor = 'not-allowed'; }
      resetMainPagination();
      updateMobileWindowState({ reset: true });
      scheduleSongListRender('clear-search');
    };

    window.clearFilters = () => {
      searchTerm = '';
      showOwnedOnly = false;
      showMixableOnly = false;
      selectedGenre = 'All';
      resetMainPagination();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    };

    window.openProfileView = () => {
      view = 'profile';
      render();
      setupEventListeners();
      renderProfile();
    };

    window.toggleOwned = async (id) => {
      if(viewingProfile){ alert("You can't edit other people's collections!"); return; }
      const nextOwned = ownedTracks.includes(id) ? ownedTracks.filter(t=>t!==id) : [...ownedTracks, id];
      await saveOwnedTracksSafe(nextOwned, { reason: 'toggle' });
      updateOwnedCount();
      updateSongCardOwnedState(id);
      updateStickyCTA();
      if(showOwnedOnly){
        updateMobileWindowState({ reset: true });
        scheduleSongListRender('owned-filter-change');
      }
    };

    window.exitProfileViewMode = () => {
      clearViewedProfile();
      refreshDraftProfileFromCurrentUser();
      render();
      setupEventListeners();
    };

    function updateSetlistCountUI(){
      const el = document.getElementById('setlistCount');
      if(el) el.textContent = setlist.length;
    }

    window.addToSetlist = (id) => {
      if(!id) return;
      const exists = setlist.includes(id);
      if(exists){
        setlist = setlist.filter(x => x !== id);
      } else {
        setlist.push(id);
      }
      scheduleProfileCacheSync();
      updateSetlistCountUI();
      updateSongCardSetlistState(id);
      if(view === 'setlist') renderSetlist();
    };

    window.removeFromSetlist = (id) => {
      setlist = setlist.filter(x => x !== id);
      scheduleProfileCacheSync();
      updateSetlistCountUI();
      updateSongCardSetlistState(id);
      renderSetlist();
    };

    window.switchView = (newView) => {
      if(newView === 'audit' && !isAdmin()){
        alert('Admin only');
        newView = 'browser';
      }
      adminMenuOpen = false;
      logEvent('view_switch', { from: view, to: newView });
      view = newView;
      if(view === 'browser'){ updateMobileWindowState({ reset: true }); }
      const browserView = document.getElementById('browserView');
      const setlistView = document.getElementById('setlistView');
      const profileView = document.getElementById('profileView');
      const auditViewEl = document.getElementById('auditView');
      if(browserView) browserView.style.display = view==='browser' ? 'block' : 'none';
      if(setlistView) setlistView.style.display = view==='setlist' ? 'block' : 'none';
      if(profileView) profileView.style.display = view==='profile' ? 'block' : 'none';
      if(auditViewEl) auditViewEl.style.display = view==='audit' ? 'block' : 'none';
      const browserBtn = document.getElementById('browserBtn'); const setlistBtn = document.getElementById('setlistBtn'); const profileBtn = document.getElementById('profileBtn'); const auditBtn = document.getElementById('auditBtn');
      if(browserBtn) browserBtn.className = `px-4 py-2 rounded-lg font-medium transition ${view==='browser'?'bg-gradient-to-r from-purple-500 to-pink-500':'bg-white/10 hover:bg-white/20'}`;
      if(setlistBtn) setlistBtn.className = `px-4 py-2 rounded-lg font-medium transition ${view==='setlist'?'bg-gradient-to-r from-purple-500 to-pink-500':'bg-white/10 hover:bg-white/20'}`;
      if(profileBtn) profileBtn.className = `px-4 py-2 rounded-lg font-medium transition ${view==='profile'?'bg-gradient-to-r from-indigo-500 to-blue-500':'bg-white/10 hover:bg-white/20'}`;
      if(auditBtn) auditBtn.className = `px-4 py-2 rounded-lg font-medium transition ${view==='audit'?'bg-gradient-to-r from-amber-500 to-yellow-500':'bg-white/10 hover:bg-white/20'}`;
      if(view==='browser'){ renderSongList(); setupEventListeners(); sandboxInit(); renderSandbox(); }
      else if(view==='setlist'){ renderSetlist(); setupEventListeners(); }
      else if(view==='audit'){ renderAuditView(); setupEventListeners(); }
      else { renderProfile(); setupEventListeners(); }
      updateTourUI();
    };

    window.toggleMixableFilter = () => {
      if(!selectedSong){
        setMixableInlineNotice('Select a song first to see mixable matches.');
        return;
      }
      showMixableOnly = !showMixableOnly;
      resetMainPagination();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    };

    window.toggleOwnedFilter = () => {
      showOwnedOnly = !showOwnedOnly;
      resetMainPagination();
      updateMobileWindowState({ reset: true });
      render();
      setupEventListeners();
    };

    window.markAllOwned = async () => {
      if(viewingProfile) return;
      if(!confirm(`âš ï¸ Mark ALL ${songs.length} songs as owned?\nThis will override your current selection!`)) return;
      ownedTracks = songs.map(s=>s.id);
      scheduleProfileCacheSync();
      updateOwnedCount();
      updateMobileWindowState({ reset: true });
      scheduleSongListRender('mark-all-owned');
      updateStickyCTA();
      alert(`âœ… Marked all ${songs.length} songs as owned!`);
    };

    window.clearAllOwned = async () => {
      if(viewingProfile) return;
      if(!confirm(`âš ï¸ CLEAR ALL owned songs?`)) return;
      const count = ownedTracks.length;
      await saveOwnedTracksSafe([], { reason: 'explicit_clear', allowEmpty: true });
      updateOwnedCount();
      updateMobileWindowState({ reset: true });
      scheduleSongListRender('clear-all-owned');
      updateStickyCTA();
      alert(`ðŸ—‘ï¸ Cleared ${count} owned songs.`);
    };

    async function addBandMember(){
      alert('Band Members is temporarily disabled.');
      return;
    }

    async function viewBandMember(username){
      alert('Band Members is temporarily disabled.');
      return;
    }
    function backToMyProfile(){
      alert('Band Members is temporarily disabled.');
      return;
    }

    // --------------------- Preview & two-track (simple) ---------------
    function onPreviewClick(id){
      const b = songs.find(s => s.id === id); if(!selectedSong){ selectedSong = b; render(); setupEventListeners(); alert('Main track selected. Click Preview on another track to compare.'); return; }
      previewSong = b; displayTwoTrackPreview(selectedSong, previewSong);
    }
    function displayTwoTrackPreview(A,B){
      const comp = mashupCompatibility(A,B); const pct = Math.round(comp.total);
      alert(`${A.title} â†’ ${B.title}\nCompatibility: ${pct}%\nBPM diff: ${Math.abs(A.bpm-B.bpm)}\n${bpmShiftSuggestion(A.bpm,B.bpm)}`);
    }

    // -------------------- Sandbox functions --------------------------
    function sandboxInit(){ const el=document.getElementById('sandbox'); if(!el) return; if(!el.dataset.bound){ el.dataset.bound='1'; el.addEventListener('dragover', (e)=>e.preventDefault()); el.addEventListener('drop', (e)=>{ e.preventDefault(); const id=e.dataTransfer.getData('text/plain'); const track = songs.find(s=>s.id===id); if(!track) return; if(sandboxTracks.find(t=>t.id===id)) return; if(sandboxTracks.length>=4){ alert('Sandbox limit: 4 tracks'); return; } sandboxTracks.push(track); renderSandbox(); }); } if(!sandboxTracks.length && sandboxIds.length){ sandboxTracks = sandboxIds.map(id=> songs.find(s=>s.id===id)).filter(Boolean).slice(0,4); } renderSandbox(); }
    function persistSandbox(){ sandboxIds = sandboxTracks.map(t=>t.id); localStorage.setItem(getNamespacedKey('sandboxTrackIds'), JSON.stringify(sandboxIds)); }
    function addToSandbox(id){ const track=songs.find(s=>s.id===id); if(!track) return; if(sandboxTracks.find(t=>t.id===id)){ alert('Track already in sandbox'); return; } if(sandboxTracks.length>=4){ alert('Sandbox limit: 4 tracks'); return; } sandboxTracks.push(track); renderSandbox(); renderSongList(); }
    function renderSandbox(){ const el=document.getElementById('sandbox'); if(!el) return; el.innerHTML = sandboxTracks.map((t,i)=>`<div class="flex items-center gap-3 panel p-2 mb-2"><div class="w-10 h-10 rounded" style="background:${camelotColors[t.camelot]||'#666'};display:flex;align-items:center;justify-content:center">${t.camelot}</div><div style="flex:1"><div class="font-semibold">${t.title}</div><div class="small-muted text-xs">${t.artist} â€¢ ${t.genre} â€¢ ${t.bpm} BPM â€¢ ${t.key}</div></div><button class="ml-2 px-2 py-1 bg-red-600/40" onclick="removeSandbox('${t.id}')">âœ•</button></div>`).join('') || `<div class="small-muted p-2">Drop tracks here</div>`; persistSandbox(); const info=document.getElementById('sandboxInfo'); if(sandboxTracks.length===0){ if(info) info.textContent=''; return; } const bpms=sandboxTracks.map(s=>s.bpm); const keys=sandboxTracks.map(s=>s.camelot); const bpmRange=`${Math.min(...bpms)}â€“${Math.max(...bpms)}`; const bpmDiffs=bpms.length>1?Math.max(...bpms)-Math.min(...bpms):0; const genreBlend=getGenreBlendScore(sandboxTracks); if(info) info.innerHTML=`BPM range: ${bpmRange} (Î” ${bpmDiffs}) â€¢ Key set: ${[...new Set(keys)].join(', ')} â€¢ Genre-blend: ${Math.round(genreBlend*100)}%`; }
    function removeSandbox(id){ sandboxTracks=sandboxTracks.filter(s=>s.id!==id); renderSandbox(); }
    function clearSandbox(){ sandboxTracks=[]; sandboxIds=[]; renderSandbox(); }
    function getGenreBlendScore(list){ if(!list.length) return 0; const counts={}; list.forEach(s=>counts[s.genre]=(counts[s.genre]||0)+1); const max=Math.max(...Object.values(counts)); return max/list.length; }

    // NOTE:
    // Import / Export was intentionally removed.
    // Profiles persist automatically via Firebase or localStorage.
    // Do not reintroduce manual JSON import/export without a migration plan.

    // -------------------- Help/What's New config ---------------------
    const HELP_SECTION_FEATURES = {
      setlist: 'hasSetlist',
      live: 'hasLiveProfile',
      offline: 'hasOfflineMode',
      owned: 'hasOwnedToggle'
    };
    const HELP_SECTION_IDS = {
      setlist: 'help-setlist',
      live: 'help-live',
      offline: 'offlineHelp',
      owned: 'ownedHelp'
    };
    const HELP_FAQ_FEATURES = {
      go_live_disabled: 'hasLiveProfile',
      cant_see_setlist: 'hasSetlist',
      offline_mode: 'hasOfflineMode',
      owned_count_wrong: 'hasOwnedToggle'
    };

    function getWhatsNewItems(){
      if(Array.isArray(whatsNewState?.items)) return whatsNewState.items;
      if(Array.isArray(whatsNewState)) return whatsNewState;
      if(Array.isArray(window.DEFAULT_WHATS_NEW?.items)) return window.DEFAULT_WHATS_NEW.items;
      return [];
    }

    function buildListElement(items, listTag = 'ol'){
      const list = document.createElement(listTag);
      items.forEach((line) => {
        const li = document.createElement('li');
        li.textContent = line;
        list.appendChild(li);
      });
      return list;
    }

    function buildHelpSectionElement(section, { listTag = 'ol', includeFeatures = true, includeIds = true } = {}){
      const wrapper = document.createElement('div');
      wrapper.className = 'helpSection';
      if(includeIds && section?.id){
        const sectionId = HELP_SECTION_IDS[section.id] || `help-${section.id}`;
        wrapper.id = sectionId;
      }
      const featureKey = HELP_SECTION_FEATURES[section?.id];
      if(includeFeatures && featureKey){
        wrapper.dataset.helpFeature = featureKey;
      }
      const title = document.createElement('h3');
      title.textContent = section?.title || '';
      wrapper.appendChild(title);

      const content = document.createElement('div');
      if(includeFeatures && featureKey){
        content.dataset.helpContent = '';
      }
      const bullets = Array.isArray(section?.bullets)
        ? section.bullets
        : Array.isArray(section?.body)
          ? section.body
          : [];
      if(bullets.length){
        content.appendChild(buildListElement(bullets, listTag));
      }
      const steps = Array.isArray(section?.steps) ? section.steps : [];
      if(steps.length){
        const stepsLabel = document.createElement('p');
        stepsLabel.className = 'small-muted';
        stepsLabel.textContent = 'Steps';
        content.appendChild(stepsLabel);
        content.appendChild(buildListElement(steps, 'ol'));
      }
      wrapper.appendChild(content);

      if(includeFeatures && featureKey){
        const coming = document.createElement('p');
        coming.className = 'helpComing';
        coming.dataset.helpComing = '';
        coming.textContent = 'Coming soon.';
        wrapper.appendChild(coming);
      }
      return wrapper;
    }

    function renderHelpContentInto({ helpData, quickStartEl, basicSectionsEl, faqListEl, advancedSectionsEl, includeFeatures = true, includeIds = true } = {}){
      if(!helpData) return;
      const quickStart = Array.isArray(helpData?.basic?.quickStart) ? helpData.basic.quickStart : [];
      if(quickStartEl){
        quickStartEl.innerHTML = '';
        const isListEl = ['OL','UL'].includes(quickStartEl.tagName);
        if(isListEl){
          quickStart.forEach((line) => {
            const li = document.createElement('li');
            li.textContent = line;
            quickStartEl.appendChild(li);
          });
        } else {
          quickStartEl.appendChild(buildListElement(quickStart, 'ol'));
        }
      }
      if(basicSectionsEl){
        basicSectionsEl.innerHTML = '';
        const sections = Array.isArray(helpData?.basic?.sections) ? helpData.basic.sections : [];
        sections.forEach(section => {
          basicSectionsEl.appendChild(buildHelpSectionElement(section, { listTag: 'ol', includeFeatures, includeIds }));
        });
      }
      if(faqListEl){
        faqListEl.innerHTML = '';
        const faqs = Array.isArray(helpData?.basic?.faq) ? helpData.basic.faq : [];
        faqs.forEach((faq) => {
          const detail = document.createElement('details');
          detail.className = 'helpFaq';
          detail.dataset.questionId = faq.id || '';
          const featureKey = HELP_FAQ_FEATURES[faq.id];
          if(includeFeatures && featureKey){
            detail.dataset.helpFeature = featureKey;
            detail.dataset.helpFeatureMode = 'item';
          }
          const summary = document.createElement('summary');
          summary.textContent = faq.q || '';
          detail.appendChild(summary);
          const answers = Array.isArray(faq.a) ? faq.a : [];
          answers.forEach((line) => {
            const p = document.createElement('p');
            p.textContent = line;
            detail.appendChild(p);
          });
          faqListEl.appendChild(detail);
        });
      }
      if(advancedSectionsEl){
        advancedSectionsEl.innerHTML = '';
        const sections = Array.isArray(helpData?.advanced?.sections) ? helpData.advanced.sections : [];
        sections.forEach(section => {
          advancedSectionsEl.appendChild(buildHelpSectionElement(section, { listTag: 'ul', includeFeatures: false, includeIds }));
        });
      }
    }

    function renderHelpContent(){
      const helpData = helpContentState || window.DEFAULT_HELP_CONTENT;
      renderHelpContentInto({
        helpData,
        quickStartEl: document.getElementById('helpQuickStartList'),
        basicSectionsEl: document.getElementById('helpBasicSections'),
        faqListEl: document.getElementById('helpFaqList'),
        advancedSectionsEl: document.getElementById('helpAdvancedSections'),
        includeFeatures: true
      });
      bindHelpFaqTracking();
      applyHelpFlags(getHelpFlags());
    }

    function renderHelpPreview(targetEl, helpData){
      if(!targetEl) return;
      targetEl.innerHTML = '';
      const basicWrapper = document.createElement('div');
      const basicTitle = document.createElement('h4');
      basicTitle.textContent = 'Basic';
      basicWrapper.appendChild(basicTitle);
      const quickTitle = document.createElement('div');
      quickTitle.className = 'text-xs text-cyan-200 font-semibold';
      quickTitle.textContent = 'Quick Start';
      basicWrapper.appendChild(quickTitle);
      const quickList = document.createElement('div');
      basicWrapper.appendChild(quickList);
      const sectionsContainer = document.createElement('div');
      const faqContainer = document.createElement('div');
      renderHelpContentInto({
        helpData,
        quickStartEl: quickList,
        basicSectionsEl: sectionsContainer,
        faqListEl: faqContainer,
        advancedSectionsEl: null,
        includeFeatures: false,
        includeIds: false
      });
      basicWrapper.appendChild(sectionsContainer);
      if(faqContainer.children.length){
        const faqTitle = document.createElement('div');
        faqTitle.className = 'text-xs text-cyan-200 font-semibold mt-2';
        faqTitle.textContent = 'FAQ';
        basicWrapper.appendChild(faqTitle);
        basicWrapper.appendChild(faqContainer);
      }
      targetEl.appendChild(basicWrapper);

      const advancedWrapper = document.createElement('div');
      advancedWrapper.className = 'mt-3';
      const advancedTitle = document.createElement('h4');
      advancedTitle.textContent = 'Advanced';
      advancedWrapper.appendChild(advancedTitle);
      const advancedContainer = document.createElement('div');
      renderHelpContentInto({
        helpData,
        quickStartEl: null,
        basicSectionsEl: null,
        faqListEl: null,
        advancedSectionsEl: advancedContainer,
        includeFeatures: false,
        includeIds: false
      });
      advancedWrapper.appendChild(advancedContainer);
      targetEl.appendChild(advancedWrapper);
    }

    function cloneConfig(data){
      return data ? JSON.parse(JSON.stringify(data)) : null;
    }

    function splitLines(value){
      return (value || '')
        .split('\\n')
        .map(line => line.trim())
        .filter(Boolean);
    }

    function escapeHtml(value){
      return String(value ?? '')
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/\"/g,'&quot;')
        .replace(/'/g,'&#39;');
    }

    function parseCommaList(value){
      return (value || '')
        .split(',')
        .map(item => item.trim())
        .filter(Boolean);
    }

    function moveItem(list, fromIndex, toIndex){
      if(!Array.isArray(list)) return;
      if(fromIndex < 0 || fromIndex >= list.length) return;
      if(toIndex < 0 || toIndex >= list.length) return;
      const [item] = list.splice(fromIndex, 1);
      list.splice(toIndex, 0, item);
    }

    async function loadRemoteConfig(){
      if(configLoadPromise) return configLoadPromise;
      if(!window.configService){
        renderHelpContent();
        return null;
      }
      configLoadPromise = Promise.all([
        window.configService.getHelpContent({ firestore, defaults: window.DEFAULT_HELP_CONTENT }),
        window.configService.getWhatsNew({ firestore, defaults: window.DEFAULT_WHATS_NEW })
      ]).then(([helpData, whatsNewData]) => {
        if(helpData) helpContentState = helpData;
        if(whatsNewData) whatsNewState = whatsNewData;
        renderHelpContent();
      }).catch((err) => {
        console.warn('[config] load failed', err);
        renderHelpContent();
      });
      return configLoadPromise;
    }

    // --------------------- Help modal functions -----------------------
    let helpEditorState = null;
    let whatsNewEditorState = null;
    function normalizeHelpTarget(value){
      return value === 'setlist' || value === 'live' ? value : 'none';
    }
    function normalizeHelpSource(value){
      return value === 'menu' || value === 'setlist_icon' || value === 'live_icon' ? value : 'other';
    }
    function buildHelpOpenedPayload(source, target){
      const payload = { source, target };
      const appVersion = getAppVersion();
      if(appVersion) payload.appVersion = appVersion;
      return payload;
    }
    const MAX_WHATS_NEW_ITEMS = 8;
    function resolveFeatureFlagValue(value, fallback){
      return typeof value === 'boolean' ? value : fallback;
    }
    function resolveFeatureFlags(){
      const baseFlags = window.FEATURE_FLAGS || {};
      return {
        setlist: resolveFeatureFlagValue(baseFlags.setlist, !!document.getElementById('setlistBtn')),
        liveProfile: resolveFeatureFlagValue(baseFlags.liveProfile, true),
        offlineMode: resolveFeatureFlagValue(baseFlags.offlineMode, typeof readCachedTracks === 'function' && 'serviceWorker' in navigator),
        ownedToggle: resolveFeatureFlagValue(baseFlags.ownedToggle, !!document.getElementById('ownedFilterBtn')),
        statsTiles: resolveFeatureFlagValue(baseFlags.statsTiles, !!document.querySelector('[data-community-stat]'))
      };
    }
    function getHelpFlags(){
      const features = resolveFeatureFlags();
      return {
        hasSetlist: features.setlist,
        hasLiveProfile: features.liveProfile,
        hasOfflineMode: features.offlineMode,
        hasOwnedToggle: features.ownedToggle,
        hasStatsTiles: features.statsTiles
      };
    }

    function applyHelpFlags(flags){
      document.querySelectorAll('[data-help-feature]').forEach((el) => {
        const key = el.dataset.helpFeature;
        const enabled = !!flags[key];
        if(el.dataset.helpFeatureMode === 'item'){
          el.style.display = enabled ? '' : 'none';
          return;
        }
        const content = el.querySelector('[data-help-content]');
        const coming = el.querySelector('[data-help-coming]');
        if(content) content.style.display = enabled ? '' : 'none';
        if(coming) coming.style.display = enabled ? 'none' : 'block';
      });
    }

    function renderWhatsNew(features){
      const list = document.getElementById('whatsNewList');
      if(!list) return;
      const items = getWhatsNewItems();
      const activeFeatures = features || resolveFeatureFlags();
      const filtered = items.filter((item) => {
        const requires = Array.isArray(item?.requires) ? item.requires : [];
        if(requires.length === 0) return true;
        return requires.every(flag => activeFeatures[flag]);
      }).slice(0, MAX_WHATS_NEW_ITEMS);
      list.innerHTML = filtered.map((item) => {
        const dateLabel = item?.date ? ` <span class="small-muted">(${item.date})</span>` : '';
        return `<li>âœ… ${item.text}${dateLabel}</li>`;
      }).join('');
      const empty = document.getElementById('whatsNewEmpty');
      if(empty) empty.style.display = filtered.length ? 'none' : 'block';
    }

    function syncHelpVersion(){
      const helpVersion = document.getElementById('helpVersion');
      if(!helpVersion) return;
      const appVersion = getAppVersion();
      helpVersion.textContent = appVersion ? `Help updated for v${appVersion}` : '';
    }

    function syncHelpTabsA11y(){
      const tabs = document.querySelectorAll('.helpTabBtn');
      tabs.forEach(btn => {
        const isActive = btn.dataset.tab === helpTab;
        btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
        btn.tabIndex = isActive ? 0 : -1;
        btn.classList.toggle('active', isActive);
      });
    }

    function setHelpTab(tab){
      const helpContent = document.getElementById('helpContent');
      if(!helpContent) return;
      const panes = document.querySelectorAll('[data-help-pane]');
      helpScroll[helpTab] = helpContent.scrollTop;
      const previousTab = helpTab;
      helpTab = tab === 'advanced' ? 'advanced' : 'basic';
      panes.forEach(pane => {
        const isActive = pane.dataset.helpPane === helpTab;
        pane.style.display = isActive ? 'block' : 'none';
      });
      helpContent.scrollTop = helpScroll[helpTab] || 0;
      syncHelpTabsA11y();
      if(helpOpenedAt && (!helpTabTracked || previousTab !== helpTab)){
        track('help_tab_viewed', { tab: helpTab, target: helpOpenTarget });
        helpTabTracked = true;
      }
    }

    function bindHelpTabs(){
      const tabs = document.querySelectorAll('.helpTabBtn');
      tabs.forEach(btn => {
        const tab = btn.dataset.tab;
        btn.addEventListener('click', () => setHelpTab(tab));
        btn.addEventListener('keydown', (e) => {
          if(e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar'){
            e.preventDefault();
            setHelpTab(tab);
          }
        });
      });
      syncHelpTabsA11y();
    }

    function bindHelpFaqTracking(){
      document.querySelectorAll('.helpFaq').forEach((faq) => {
        if(faq.dataset.bound === 'true') return;
        faq.dataset.bound = 'true';
        faq.addEventListener('toggle', () => {
          const questionId = faq.dataset.questionId;
          if(!questionId) return;
          track('help_faq_toggled', {
            questionId,
            state: faq.open ? 'open' : 'closed'
          });
        });
      });
    }

    function openHelpModal(options = {}){
      const modal = document.getElementById('helpModal');
      if(!modal) return;
      const target = normalizeHelpTarget(options?.target);
      const source = normalizeHelpSource(options?.source);
      helpOpenTarget = target;
      helpOpenSource = source;
      helpOpenedAt = Date.now();
      helpTabTracked = false;
      track('help_opened', buildHelpOpenedPayload(source, target));
      const features = resolveFeatureFlags();
      renderWhatsNew(features);
      syncHelpVersion();
      applyHelpFlags(getHelpFlags());
      helpTab = 'basic';
      helpScroll = { basic: 0, advanced: 0 };
      setHelpTab('basic');
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden','false');
      const activeTab = document.querySelector('.helpTabBtn.active');
      if(activeTab){ activeTab.focus(); } else { modal.focus(); }
      const targetId = target === 'setlist' ? 'help-setlist' : target === 'live' ? 'help-live' : null;
      if(targetId){
        setTimeout(() => {
          const targetEl = document.getElementById(targetId);
          if(targetEl){
            targetEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 0);
      }
    }
    function openHelp(){
      openHelpModal({ source: 'menu', target: 'none' });
    }
    function closeHelp(){
      const modal = document.getElementById('helpModal');
      if(!modal) return;
      if(helpOpenedAt){
        const timeOpenMs = Math.max(0, Date.now() - helpOpenedAt);
        track('help_closed', { timeOpenMs, target: helpOpenTarget });
      }
      helpOpenedAt = null;
      helpOpenTarget = 'none';
      helpOpenSource = 'other';
      helpTabTracked = false;
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden','true');
    }

    function closeAdminEditorModal(id){
      const modal = document.getElementById(id);
      if(modal) modal.remove();
    }

    function getEditorUpdatedBy(){
      return firebaseAuth?.currentUser?.email || currentUser?.username || firebaseAuth?.currentUser?.uid || 'admin';
    }

    function renderAdminHelpEditor(){
      const modal = document.getElementById('adminHelpEditorModal');
      if(!modal || !helpEditorState) return;
      const form = modal.querySelector('[data-editor-form]');
      const preview = modal.querySelector('[data-editor-preview]');
      if(!form) return;
      const basic = helpEditorState.basic || { quickStart: [], sections: [], faq: [] };
      const advanced = helpEditorState.advanced || { sections: [] };
      const quickStartRows = (basic.quickStart || []).map((line, index) => `
        <div class="admin-editor-row">
          <input class="admin-editor-input" data-field="quickStart" data-index="${index}" value="${escapeHtml(line)}" />
          <div class="admin-editor-inline-actions">
            <button class="admin-editor-btn" data-action="move-up" data-target="quickStart" data-index="${index}">â†‘</button>
            <button class="admin-editor-btn" data-action="move-down" data-target="quickStart" data-index="${index}">â†“</button>
            <button class="admin-editor-btn" data-action="remove-item" data-target="quickStart" data-index="${index}">Remove</button>
          </div>
        </div>
      `).join('') || '<div class="text-xs text-gray-400">No quick start steps yet.</div>';

      const basicSectionRows = (basic.sections || []).map((section, index) => `
        <div class="mt-2 p-2 border border-white/10 rounded-lg space-y-2">
          <div class="text-xs text-cyan-200 font-semibold">Section ${index + 1}</div>
          <input class="admin-editor-input" data-field="basic-section-id" data-index="${index}" value="${escapeHtml(section.id || '')}" placeholder="id (setlist, live, offline...)" />
          <input class="admin-editor-input" data-field="basic-section-title" data-index="${index}" value="${escapeHtml(section.title || '')}" placeholder="Title" />
          <textarea class="admin-editor-textarea" data-field="basic-section-bullets" data-index="${index}" placeholder="One line per bullet">${escapeHtml(((section.bullets || section.body) || []).join('\\n'))}</textarea>
          <textarea class="admin-editor-textarea" data-field="basic-section-steps" data-index="${index}" placeholder="Optional steps (one per line)">${escapeHtml((section.steps || []).join('\\n'))}</textarea>
          <div class="admin-editor-inline-actions">
            <button class="admin-editor-btn" data-action="move-up" data-target="basicSections" data-index="${index}">â†‘</button>
            <button class="admin-editor-btn" data-action="move-down" data-target="basicSections" data-index="${index}">â†“</button>
            <button class="admin-editor-btn" data-action="remove-item" data-target="basicSections" data-index="${index}">Remove</button>
          </div>
        </div>
      `).join('') || '<div class="text-xs text-gray-400">No basic sections yet.</div>';

      const faqRows = (basic.faq || []).map((faq, index) => `
        <div class="mt-2 p-2 border border-white/10 rounded-lg space-y-2">
          <div class="text-xs text-cyan-200 font-semibold">FAQ ${index + 1}</div>
          <input class="admin-editor-input" data-field="faq-id" data-index="${index}" value="${escapeHtml(faq.id || '')}" placeholder="id (go_live_disabled...)" />
          <input class="admin-editor-input" data-field="faq-q" data-index="${index}" value="${escapeHtml(faq.q || '')}" placeholder="Question" />
          <textarea class="admin-editor-textarea" data-field="faq-a" data-index="${index}" placeholder="Answer lines">${escapeHtml((faq.a || []).join('\\n'))}</textarea>
          <div class="admin-editor-inline-actions">
            <button class="admin-editor-btn" data-action="move-up" data-target="faq" data-index="${index}">â†‘</button>
            <button class="admin-editor-btn" data-action="move-down" data-target="faq" data-index="${index}">â†“</button>
            <button class="admin-editor-btn" data-action="remove-item" data-target="faq" data-index="${index}">Remove</button>
          </div>
        </div>
      `).join('') || '<div class="text-xs text-gray-400">No FAQ entries yet.</div>';

      const advancedSectionRows = (advanced.sections || []).map((section, index) => `
        <div class="mt-2 p-2 border border-white/10 rounded-lg space-y-2">
          <div class="text-xs text-cyan-200 font-semibold">Advanced ${index + 1}</div>
          <input class="admin-editor-input" data-field="advanced-section-id" data-index="${index}" value="${escapeHtml(section.id || '')}" placeholder="id (sorting...)" />
          <input class="admin-editor-input" data-field="advanced-section-title" data-index="${index}" value="${escapeHtml(section.title || '')}" placeholder="Title" />
          <textarea class="admin-editor-textarea" data-field="advanced-section-bullets" data-index="${index}" placeholder="One line per bullet">${escapeHtml(((section.bullets || section.body) || []).join('\\n'))}</textarea>
          <textarea class="admin-editor-textarea" data-field="advanced-section-steps" data-index="${index}" placeholder="Optional steps (one per line)">${escapeHtml((section.steps || []).join('\\n'))}</textarea>
          <div class="admin-editor-inline-actions">
            <button class="admin-editor-btn" data-action="move-up" data-target="advancedSections" data-index="${index}">â†‘</button>
            <button class="admin-editor-btn" data-action="move-down" data-target="advancedSections" data-index="${index}">â†“</button>
            <button class="admin-editor-btn" data-action="remove-item" data-target="advancedSections" data-index="${index}">Remove</button>
          </div>
        </div>
      `).join('') || '<div class="text-xs text-gray-400">No advanced sections yet.</div>';

      form.innerHTML = `
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">Version</div>
          <input class="admin-editor-input" data-field="help-version" value="${escapeHtml(helpEditorState.version ?? 1)}" />
        </div>
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">Quick Start Steps</div>
          ${quickStartRows}
          <button class="admin-editor-btn mt-2" data-action="add-item" data-target="quickStart">+ Add Step</button>
        </div>
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">Basic Sections</div>
          ${basicSectionRows}
          <button class="admin-editor-btn mt-2" data-action="add-item" data-target="basicSections">+ Add Section</button>
        </div>
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">FAQ</div>
          ${faqRows}
          <button class="admin-editor-btn mt-2" data-action="add-item" data-target="faq">+ Add FAQ</button>
        </div>
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">Advanced Sections</div>
          ${advancedSectionRows}
          <button class="admin-editor-btn mt-2" data-action="add-item" data-target="advancedSections">+ Add Advanced Section</button>
        </div>
      `;

      if(preview){
        renderHelpPreview(preview, helpEditorState);
      }
    }

    async function saveHelpEditor(){
      if(!window.configService) return alert('Config service unavailable');
      const status = document.querySelector('#adminHelpEditorModal [data-editor-status]');
      if(status) status.textContent = 'Saving...';
      try{
        const payload = window.configService.validateHelpDoc(helpEditorState);
        if(!payload) throw new Error('Validation failed. Fill all required fields.');
        const saved = await window.configService.saveHelpContent({
          firestore,
          data: payload,
          updatedBy: getEditorUpdatedBy()
        });
        helpContentState = saved;
        helpEditorState = cloneConfig(saved);
        renderHelpContent();
        renderAdminHelpEditor();
        if(status) status.textContent = 'Saved âœ…';
      }catch(err){
        console.warn('[admin] help save failed', err);
        if(status) status.textContent = `Save failed: ${err.message || err}`;
        alert(`Help save failed: ${err.message || err}`);
      }
    }

    function openAdminHelpEditor(){
      if(!isAdmin()) return alert('Admin only');
      closeAdminEditorModal('adminHelpEditorModal');
      helpEditorState = cloneConfig(helpContentState || window.DEFAULT_HELP_CONTENT);
      if(!helpEditorState){
        helpEditorState = { version: 1, basic: { quickStart: [], sections: [], faq: [] }, advanced: { sections: [] } };
      }
      helpEditorState.basic = helpEditorState.basic || { quickStart: [], sections: [], faq: [] };
      helpEditorState.basic.quickStart = helpEditorState.basic.quickStart || [];
      helpEditorState.basic.sections = helpEditorState.basic.sections || [];
      helpEditorState.basic.faq = helpEditorState.basic.faq || [];
      helpEditorState.advanced = helpEditorState.advanced || { sections: [] };
      helpEditorState.advanced.sections = helpEditorState.advanced.sections || [];
      const modal = document.createElement('div');
      modal.id = 'adminHelpEditorModal';
      modal.className = 'admin-editor-modal';
      modal.innerHTML = `
        <div class="admin-editor-card">
          <div class="admin-editor-header">
            <div>
              <div class="text-lg font-bold text-white">Help Editor</div>
              <div class="text-xs text-cyan-200">Edit basic + advanced help content. One line per bullet or step.</div>
            </div>
            <button class="admin-editor-btn" data-action="close-editor">Close</button>
          </div>
          <div class="admin-editor-body">
            <div class="admin-editor-columns">
              <div data-editor-form></div>
              <div>
                <div class="text-sm font-semibold text-cyan-100 mb-2">Preview</div>
                <div class="admin-editor-preview" data-editor-preview></div>
              </div>
            </div>
            <div class="flex items-center justify-between gap-3 flex-wrap">
              <div class="text-xs text-cyan-200" data-editor-status></div>
              <div class="admin-editor-actions">
                <button class="admin-editor-btn" data-action="reset-help">Reset to defaults</button>
                <button class="admin-editor-btn" data-action="save-help">Save & Publish</button>
              </div>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      renderAdminHelpEditor();
      modal.addEventListener('click', safeOn('click', (e) => {
        const btn = closestFromEvent(e, '[data-action]', { within: modal });
        if(!btn) return;
        const action = btn.dataset?.action;
        if(!action) return;
        if(action === 'close-editor'){ closeAdminEditorModal('adminHelpEditorModal'); return; }
        if(action === 'save-help'){ saveHelpEditor(); return; }
        if(action === 'reset-help'){
          helpEditorState = cloneConfig(window.DEFAULT_HELP_CONTENT);
          renderAdminHelpEditor();
          return;
        }
        const target = btn.dataset?.target;
        const index = Number(btn.dataset?.index);
        if(!target) return;
        if(action === 'add-item'){
          if(target === 'quickStart') helpEditorState.basic.quickStart.push('New step');
          if(target === 'basicSections') helpEditorState.basic.sections.push({ id: 'new_section', title: 'New Section', bullets: ['New bullet'], steps: [] });
          if(target === 'faq') helpEditorState.basic.faq.push({ id: 'new_faq', q: 'New question?', a: ['New answer.'] });
          if(target === 'advancedSections') helpEditorState.advanced.sections.push({ id: 'new_advanced', title: 'New Advanced Section', bullets: ['New bullet'], steps: [] });
          renderAdminHelpEditor();
          return;
        }
        if(action === 'remove-item'){
          if(Number.isNaN(index)) return;
          if(target === 'quickStart') helpEditorState.basic.quickStart.splice(index, 1);
          if(target === 'basicSections') helpEditorState.basic.sections.splice(index, 1);
          if(target === 'faq') helpEditorState.basic.faq.splice(index, 1);
          if(target === 'advancedSections') helpEditorState.advanced.sections.splice(index, 1);
          renderAdminHelpEditor();
          return;
        }
        if(action === 'move-up' || action === 'move-down'){
          if(Number.isNaN(index)) return;
          const delta = action === 'move-up' ? -1 : 1;
          if(target === 'quickStart') moveItem(helpEditorState.basic.quickStart, index, index + delta);
          if(target === 'basicSections') moveItem(helpEditorState.basic.sections, index, index + delta);
          if(target === 'faq') moveItem(helpEditorState.basic.faq, index, index + delta);
          if(target === 'advancedSections') moveItem(helpEditorState.advanced.sections, index, index + delta);
          renderAdminHelpEditor();
        }
      }, { action: 'admin-help-click' }));
      modal.addEventListener('input', safeOn('input', (e) => {
        const target = getEventElement(e);
        const field = target?.dataset?.field;
        if(!field) return;
        const index = Number(target.dataset?.index);
        const value = target.value;
        if(field === 'help-version'){ helpEditorState.version = Number(value) || 1; }
        if(field === 'quickStart'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.quickStart[index] = value;
        }
        if(field === 'basic-section-id'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.sections[index].id = value;
        }
        if(field === 'basic-section-title'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.sections[index].title = value;
        }
        if(field === 'basic-section-bullets'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.sections[index].bullets = splitLines(value);
        }
        if(field === 'basic-section-steps'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.sections[index].steps = splitLines(value);
        }
        if(field === 'faq-id'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.faq[index].id = value;
        }
        if(field === 'faq-q'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.faq[index].q = value;
        }
        if(field === 'faq-a'){
          if(Number.isNaN(index)) return;
          helpEditorState.basic.faq[index].a = splitLines(value);
        }
        if(field === 'advanced-section-id'){
          if(Number.isNaN(index)) return;
          helpEditorState.advanced.sections[index].id = value;
        }
        if(field === 'advanced-section-title'){
          if(Number.isNaN(index)) return;
          helpEditorState.advanced.sections[index].title = value;
        }
        if(field === 'advanced-section-bullets'){
          if(Number.isNaN(index)) return;
          helpEditorState.advanced.sections[index].bullets = splitLines(value);
        }
        if(field === 'advanced-section-steps'){
          if(Number.isNaN(index)) return;
          helpEditorState.advanced.sections[index].steps = splitLines(value);
        }
        const preview = modal.querySelector('[data-editor-preview]');
        if(preview) renderHelpPreview(preview, helpEditorState);
      }, { action: 'admin-help-input' }));
    }

    function renderWhatsNewPreview(container, items){
      if(!container) return;
      container.innerHTML = items.map(item => `<div class="text-sm mb-2">âœ… ${escapeHtml(item.text || '')}</div>`).join('') || '<div class="text-xs text-gray-400">No preview items.</div>';
    }

    function renderWhatsNewEditor(){
      const modal = document.getElementById('adminWhatsNewEditorModal');
      if(!modal || !whatsNewEditorState) return;
      const form = modal.querySelector('[data-editor-form]');
      const preview = modal.querySelector('[data-editor-preview]');
      if(!form) return;
      const items = whatsNewEditorState.items || [];
      const itemRows = items.map((item, index) => `
        <div class="mt-2 p-2 border border-white/10 rounded-lg space-y-2">
          <div class="text-xs text-cyan-200 font-semibold">Item ${index + 1}</div>
          <input class="admin-editor-input" data-field="whatsnew-id" data-index="${index}" value="${escapeHtml(item.id || '')}" placeholder="id" />
          <input class="admin-editor-input" data-field="whatsnew-text" data-index="${index}" value="${escapeHtml(item.text || '')}" placeholder="Text" />
          <input class="admin-editor-input" data-field="whatsnew-requires" data-index="${index}" value="${escapeHtml((item.requires || []).join(', '))}" placeholder="requires (comma-separated flags)" />
          <div class="admin-editor-inline-actions">
            <button class="admin-editor-btn" data-action="move-up" data-target="whatsNew" data-index="${index}">â†‘</button>
            <button class="admin-editor-btn" data-action="move-down" data-target="whatsNew" data-index="${index}">â†“</button>
            <button class="admin-editor-btn" data-action="remove-item" data-target="whatsNew" data-index="${index}">Remove</button>
          </div>
        </div>
      `).join('') || '<div class="text-xs text-gray-400">No Whatâ€™s New items yet.</div>';

      form.innerHTML = `
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">Version</div>
          <input class="admin-editor-input" data-field="whatsnew-version" value="${escapeHtml(whatsNewEditorState.version ?? 1)}" />
        </div>
        <div class="admin-editor-section">
          <div class="text-sm font-semibold text-white mb-2">Items</div>
          ${itemRows}
          <button class="admin-editor-btn mt-2" data-action="add-item" data-target="whatsNew">+ Add Item</button>
        </div>
      `;
      renderWhatsNewPreview(preview, items);
    }

    async function saveWhatsNewEditor(){
      if(!window.configService) return alert('Config service unavailable');
      const status = document.querySelector('#adminWhatsNewEditorModal [data-editor-status]');
      if(status) status.textContent = 'Saving...';
      try{
        const payload = window.configService.validateWhatsNewDoc(whatsNewEditorState);
        if(!payload) throw new Error('Validation failed. Add at least one item.');
        const saved = await window.configService.saveWhatsNew({
          firestore,
          data: payload,
          updatedBy: getEditorUpdatedBy()
        });
        whatsNewState = saved;
        whatsNewEditorState = cloneConfig(saved);
        renderWhatsNew();
        renderWhatsNewEditor();
        if(status) status.textContent = 'Saved âœ…';
      }catch(err){
        console.warn('[admin] whats new save failed', err);
        if(status) status.textContent = `Save failed: ${err.message || err}`;
        alert(`What's New save failed: ${err.message || err}`);
      }
    }

    function openAdminWhatsNewEditor(){
      if(!isAdmin()) return alert('Admin only');
      closeAdminEditorModal('adminWhatsNewEditorModal');
      whatsNewEditorState = cloneConfig(whatsNewState || window.DEFAULT_WHATS_NEW);
      if(!whatsNewEditorState){
        whatsNewEditorState = { version: 1, items: [] };
      }
      whatsNewEditorState.items = whatsNewEditorState.items || [];
      const modal = document.createElement('div');
      modal.id = 'adminWhatsNewEditorModal';
      modal.className = 'admin-editor-modal';
      modal.innerHTML = `
        <div class="admin-editor-card">
          <div class="admin-editor-header">
            <div>
              <div class="text-lg font-bold text-white">Whatâ€™s New Editor</div>
              <div class="text-xs text-cyan-200">Edit release bullets shown in Help.</div>
            </div>
            <button class="admin-editor-btn" data-action="close-editor">Close</button>
          </div>
          <div class="admin-editor-body">
            <div class="admin-editor-columns">
              <div data-editor-form></div>
              <div>
                <div class="text-sm font-semibold text-cyan-100 mb-2">Preview</div>
                <div class="admin-editor-preview" data-editor-preview></div>
              </div>
            </div>
            <div class="flex items-center justify-between gap-3 flex-wrap">
              <div class="text-xs text-cyan-200" data-editor-status></div>
              <div class="admin-editor-actions">
                <button class="admin-editor-btn" data-action="reset-whatsnew">Reset to defaults</button>
                <button class="admin-editor-btn" data-action="save-whatsnew">Save & Publish</button>
              </div>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      renderWhatsNewEditor();
      modal.addEventListener('click', safeOn('click', (e) => {
        const btn = closestFromEvent(e, '[data-action]', { within: modal });
        if(!btn) return;
        const action = btn.dataset?.action;
        if(!action) return;
        if(action === 'close-editor'){ closeAdminEditorModal('adminWhatsNewEditorModal'); return; }
        if(action === 'save-whatsnew'){ saveWhatsNewEditor(); return; }
        if(action === 'reset-whatsnew'){
          whatsNewEditorState = cloneConfig(window.DEFAULT_WHATS_NEW);
          renderWhatsNewEditor();
          return;
        }
        const target = btn.dataset?.target;
        const index = Number(btn.dataset?.index);
        if(!target) return;
        if(action === 'add-item' && target === 'whatsNew'){
          whatsNewEditorState.items.push({ id: 'new_item', text: 'New update', requires: [] });
          renderWhatsNewEditor();
          return;
        }
        if(action === 'remove-item' && target === 'whatsNew'){
          if(Number.isNaN(index)) return;
          whatsNewEditorState.items.splice(index, 1);
          renderWhatsNewEditor();
          return;
        }
        if((action === 'move-up' || action === 'move-down') && target === 'whatsNew'){
          if(Number.isNaN(index)) return;
          const delta = action === 'move-up' ? -1 : 1;
          moveItem(whatsNewEditorState.items, index, index + delta);
          renderWhatsNewEditor();
        }
      }, { action: 'admin-whatsnew-click' }));
      modal.addEventListener('input', safeOn('input', (e) => {
        const target = getEventElement(e);
        const field = target?.dataset?.field;
        if(!field) return;
        const index = Number(target.dataset?.index);
        const value = target.value;
        if(field === 'whatsnew-version'){ whatsNewEditorState.version = Number(value) || 1; }
        if(field === 'whatsnew-id'){
          if(Number.isNaN(index)) return;
          whatsNewEditorState.items[index].id = value;
        }
        if(field === 'whatsnew-text'){
          if(Number.isNaN(index)) return;
          whatsNewEditorState.items[index].text = value;
        }
        if(field === 'whatsnew-requires'){
          if(Number.isNaN(index)) return;
          whatsNewEditorState.items[index].requires = parseCommaList(value);
        }
        renderWhatsNewPreview(modal.querySelector('[data-editor-preview]'), whatsNewEditorState.items);
      }, { action: 'admin-whatsnew-input' }));
    }

    async function maybeLoadSharedProfile(){
      if(!profileParam){ viewingProfile = null; return; }
      friendSearchTerm = profileParam;
      if(!firebaseAuth?.currentUser){ friendLookupError = 'Sign in required to view other profiles.'; return; }
      if(currentUser && (currentUser.username === profileParam || currentUser.uid === profileParam)){
        viewingProfile = null; setProfileQueryParam(null); return;
      }
      const matches = await fetchProfilesByField('usernameLower', normalizeUsernameLower(profileParam));
      const profile = matches[0] || await loadProfileForViewing(profileParam);
      if(profile){
        viewingProfile = normalizeProfileShape(profile, profile.username || profile.uid);
        setProfileQueryParam(viewingProfile.username || viewingProfile.uid || '');
        view = 'profile';
      } else {
        friendLookupError = `No profile found for â€˜${profileParam}â€™`;
      }
    }

    const helpModal = document.getElementById('helpModal');
    if(helpModal){
      helpModal.addEventListener('click',(e)=>{
        const target = getEventElement(e);
        if(target === helpModal) closeHelp();
      });
      bindHelpTabs();
      bindHelpFaqTracking();
      renderHelpContent();
    }
    bindTourEvents();
    window.addEventListener('resize', ()=>{ if(tourState.isOpen) updateTourUI(); });
    window.addEventListener('scroll', ()=>{ if(tourState.isOpen) updateTourUI(); }, true);
    document.addEventListener('keydown', safeOn('keydown', (e)=>{
      if(tourState.isOpen){
        if(e.key === 'Escape'){
          skipTour();
          return;
        }
        trapTourFocus(e);
        return;
      }
      if(e.key === 'Escape'){ closeHelp(); }
    }, { action: 'global-keydown' }));

    // ----------------------- Init / Auth check ------------------------
    loadOverridesFromStorage();
    handleNetworkStatusChange();
    window.addEventListener('online', ()=>{ handleNetworkStatusChange(); if(!songs.length) loadSongs(); });
    window.addEventListener('offline', handleNetworkStatusChange);
    if('serviceWorker' in navigator){
      window.addEventListener('load', ()=>{
        navigator.serviceWorker.register('/sw.js').catch(err=>console.warn('SW registration failed', err));
      });
    }
    initCommunityMetrics();
    async function checkAuth(){
      if (firebaseEnabled && firebaseAuth) {
        setupFirebaseAuthListener();
        const fbUser = firebaseAuth.currentUser;
        if (fbUser) return;
      }
      const cachedProfile = await hydrateFromLocalCacheOnly();
      if(cachedProfile){
        await enterAppWithProfile(cachedProfile, { loadOverrides: false, skipPersist: true });
        renderSignedOutState();
        return;
      }
      await loadRemoteConfig();
      showLoginScreen();
    }

    updatePerformanceMode();
    reducedMotionQuery?.addEventListener?.('change', updatePerformanceMode);
    navigator?.connection?.addEventListener?.('change', updatePerformanceMode);
    if(mobileViewportQuery?.addEventListener){
      mobileViewportQuery.addEventListener('change', () => {
        updateMobileWindowState({ reset: true });
        scheduleSongListRender('viewport-change');
        updateStickyCTA();
      });
    } else {
      window.addEventListener('resize', () => {
        updateMobileWindowState({ reset: true });
        scheduleSongListRender('viewport-resize');
        updateStickyCTA();
      }, { passive: true });
    }

    if(!localStorage.getItem('hasSeenLanding')) showLandingPage(); else checkAuth();

    // ------------------ Drag/drop support ---------------------------
    document.addEventListener('dragstart', safeOn('dragstart', (e)=>{
      const card = closestFromEvent(e, '.song-card');
      if(card){
        const songId = card.getAttribute('data-song-id');
        if(songId) e.dataTransfer.setData('text/plain', songId);
      }
    }, { action: 'drag-song-card' }));
    // ---------------- Expose some helpers for debugging ----------------
    window.openHelp = openHelp; window.openHelpModal = openHelpModal; window.closeHelp = closeHelp; window.render = render; window.loadSongs = loadSongs; window.renderSongList = renderSongList; window.renderSetlist = renderSetlist; window.viewFriendProfile = viewFriendProfile; window.startTour = startTour; window.refreshLiveNowUsers = refreshLiveNowUsers;
    window.__perfState = {
      get listRenderCount(){ return listRenderCount; },
      get maxMobileCards(){ return maxMobileCardsRendered; }
    };
  </script>
</body>
</html>
